<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/04/Linux%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/04/Linux%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/" class="post-title-link" itemprop="url">Linux发送http请求</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-04 20:11:27 / Modified: 20:19:05" itemprop="dateCreated datePublished" datetime="2020-12-04T20:11:27+08:00">2020-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">运维技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://home.cnblogs.com/u/kaleidoscope/">kaleidoscopic</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kaleidoscope/p/9719841.html">https://www.cnblogs.com/kaleidoscope/p/9719841.html</a></p>
<h2 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h2><h3 id="curl命令模拟Get请求："><a href="#curl命令模拟Get请求：" class="headerlink" title="curl命令模拟Get请求："></a>curl命令模拟Get请求：</h3><p>1、使用curl命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://www.baidu.com&quot;     如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span><br><span class="line">curl -i &quot;http://www.baidu.com&quot;  显示全部信息</span><br><span class="line">curl -I &quot;http://www.baidu.com&quot;  只显示头部信息</span><br><span class="line">curl -v &quot;http://www.baidu.com&quot;  显示get请求全过程解析</span><br></pre></td></tr></table></figure>

<p>2、使用wget命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;http://www.baidu.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="curl命令模拟Get请求携带参数（linux）："><a href="#curl命令模拟Get请求携带参数（linux）：" class="headerlink" title="curl命令模拟Get请求携带参数（linux）："></a>curl命令模拟Get请求携带参数（linux）：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com</span><br></pre></td></tr></table></figure>

<p>上述命令在linux系统，get请求携带的参数只到version=1，”&amp;”符号在linux系统中为后台运行的操作符，此处需要使用反斜杠”\”转义，即：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://127.0.0.1:80/xcloud/test?version=1\&amp;client_version=1.1.0\&amp;seq=1001\&amp;host=aaa.com</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h2><p>1、使用curl命令，通过-d参数，把访问参数放在里面，如果没有参数，则不需要-d，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;username=user1&amp;password=123&quot; &quot;www.test.com/login&quot;</span><br></pre></td></tr></table></figure>

<p>2、使用wget命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget –post-data &#x27;username=user1&amp;password=123&#x27; http://www.baidu.com</span><br></pre></td></tr></table></figure>

<p>3、发送格式化json请求</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -k -H &quot;Content-type: application/json&quot; -X POST -d &#x27;&#123;&quot;version&quot;:&quot;6.6.0&quot;, &quot;from&quot;:&quot;mu&quot;, &quot;product_version&quot;:&quot;1.1.1.0&quot;&#125;&#x27; https://10.10.10.10:80/test</span><br></pre></td></tr></table></figure>

<h2 id="curl和wget区别"><a href="#curl和wget区别" class="headerlink" title="curl和wget区别"></a>curl和wget区别</h2><p>curl模拟的访问请求一般直接在控制台显示，而wget则把结果保存为一个文件。如果结果内容比较少，需要直接看到结果可以考虑使用curl进行模拟请求，如果返回结果比较多，则可考虑wget进行模拟请求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">算法（八）之快速排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-04 18:00:41" itemprop="dateCreated datePublished" datetime="2020-12-04T18:00:41+08:00">2020-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-08 13:46:18" itemprop="dateModified" datetime="2020-12-08T13:46:18+08:00">2020-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="快排原理"><a href="#快排原理" class="headerlink" title="快排原理"></a>快排原理</h2><ol>
<li>随机选择一个元素作为基准元素（pivot），并且让基准元素和数列首元素交换位置。解决最大值或最小值本身就是第一个元素，退化成O(n^2^)。</li>
<li>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。</li>
</ol>
<p>虽然快速排序的平均时间复杂度是O(nlogn)，但最坏情况下的时间复杂度是O(n^2^)。</p>
<h2 id="元素的交换"><a href="#元素的交换" class="headerlink" title="元素的交换"></a>元素的交换</h2><ul>
<li>双边循环法。</li>
<li>单边循环法</li>
</ul>
<h4 id="双边循环法"><a href="#双边循环法" class="headerlink" title="双边循环法"></a>双边循环法</h4><p><strong>原则</strong>：</p>
<ol>
<li>选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。<img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207112907329.png" alt="image-20201207112907329" style="zoom: 50%;"></li>
<li>从right指针开始，让指针所指向的元素和基准元素做比较。如果大于或等于pivot，则指针向左移动；如果小于pivot，则right指针停止移动，切换到left指针。 <img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207132506437.png" alt="image-20201207132506437" style="zoom:50%;">

</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex&gt;=endIndex)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition(arrays, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort(arrays,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">    quickSort(arrays,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arrays[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line">    <span class="keyword">while</span> (left!=right)&#123;</span><br><span class="line">      <span class="comment">//控制right 指针比较并左移</span></span><br><span class="line">      <span class="keyword">while</span> (left&lt;right &amp;&amp; arrays[right]&gt;pivot)&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">      <span class="keyword">while</span> (left&lt;right &amp;&amp; arrays[left]&lt;=pivot)&#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//交换left和right 指针所指向的元素</span></span><br><span class="line">      <span class="keyword">if</span>(right&gt;left)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arrays[right];</span><br><span class="line">        arrays[right] = arrays[left];</span><br><span class="line">        arrays[left] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pivot 和指针重合点交换</span></span><br><span class="line">    arrays[startIndex] = arrays[left];</span><br><span class="line">    arrays[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="单边循环法"><a href="#单边循环法" class="headerlink" title="单边循环法"></a>单边循环法</h4><p><strong>原理</strong>：</p>
<ol>
<li>首先选定基准元素pivot。同时，设置一个mark指针指向数列起始位置，这个mark指针代表小于基准元素的区域边界<img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207135733083.png" alt="image-20201207135733083" style="zoom:50%;"></li>
<li>如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1；第二，让最新遍历到的元素和mark指针所 在位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。 <img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207135924557.png" alt="image-20201207135924557" style="zoom:50%;">

</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex&gt;=endIndex)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition2(arrays, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort2(arrays,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">    quickSort2(arrays,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arrays[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= startIndex+<span class="number">1</span>;i&lt;=endIndex;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrays[i]&lt; pivot)&#123;</span><br><span class="line">        mark++;</span><br><span class="line">        <span class="keyword">int</span> temp = arrays[mark];</span><br><span class="line">        arrays[mark] = arrays[i];</span><br><span class="line">        arrays[i] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arrays[startIndex] = arrays[mark];</span><br><span class="line">    arrays[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用一个集合栈来代替递归的函数栈 </span></span><br><span class="line">  Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">  <span class="comment">// 整个数列的起止下标，以哈希的形式入栈 </span></span><br><span class="line">  Map rootParam = <span class="keyword">new</span> HashMap();</span><br><span class="line">  rootParam.put(<span class="string">&quot;startIndex&quot;</span>, startIndex);</span><br><span class="line">  rootParam.put(<span class="string">&quot;endIndex&quot;</span>, endIndex);</span><br><span class="line">  quickSortStack.push(rootParam);</span><br><span class="line">  <span class="comment">// 循环结束条件：栈为空时 </span></span><br><span class="line">  <span class="keyword">while</span> (!quickSortStack.isEmpty()) &#123; </span><br><span class="line">    <span class="comment">// 栈顶元素出栈，得到起止下标 </span></span><br><span class="line">    Map&lt;String, Integer&gt; param = quickSortStack.pop(); </span><br><span class="line">    <span class="comment">// 得到基准元素位置 </span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, param.get(<span class="string">&quot;startIndex&quot;</span>), param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">    <span class="comment">// 根据基准元素分成两部分, 把每一部分的起止下标入栈 </span></span><br><span class="line">    <span class="keyword">if</span> (param.get(<span class="string">&quot;startIndex&quot;</span>) &lt; pivotIndex - <span class="number">1</span>) &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">      leftParam.put(<span class="string">&quot;startIndex&quot;</span>, param.get(<span class="string">&quot;startIndex&quot;</span>));</span><br><span class="line">      leftParam.put(<span class="string">&quot;endIndex&quot;</span>, pivotIndex - <span class="number">1</span>);</span><br><span class="line">      quickSortStack.push(leftParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pivotIndex + <span class="number">1</span> &lt; param.get(<span class="string">&quot;endIndex&quot;</span>)) &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">      rightParam.put(<span class="string">&quot;startIndex&quot;</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">      rightParam.put(<span class="string">&quot;endIndex&quot;</span>, param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">      quickSortStack.push(rightParam);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法（七）之排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-04 10:18:11 / Modified: 17:59:00" itemprop="dateCreated datePublished" datetime="2020-12-04T10:18:11+08:00">2020-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="排序算法时间复杂度对比"><a href="#排序算法时间复杂度对比" class="headerlink" title="排序算法时间复杂度对比"></a>排序算法时间复杂度对比</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2^)</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2^)</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2^)</td>
</tr>
<tr>
<td>希尔排序</td>
<td>性能略优于O(n^2^),但又比不上O(nlog<del>2</del>n)</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog<del>2</del>n)</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog<del>2</del>n)</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog<del>2</del>n)</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n)</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n)</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 更新为最后一次交换元素的位置</span></span><br><span class="line">          lastExchangeIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortBorder = lastExchangeIndex;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    bubbleSort2(array);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>排序过程就像钟摆一样，第1轮从左到右，第2轮从右到左，第3轮再从左到右……</p>
<p>在大部分元素已经有序的情况下能发挥优势，减少排序的回合数；代码量几乎增加了1倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 有元素交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在偶数轮之前，将isSorted重新标记为true</span></span><br><span class="line">      isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 偶数轮，从右向左比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length - i - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">          array[j - <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一轮：从左到右，先从2开始比较，找到最大值</span></span><br><span class="line">    <span class="comment">//第二轮：从右到左，从8开始比较，找到最小值</span></span><br><span class="line">    <span class="comment">//之后轮询继续比较</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">算法（六）之二叉堆实现优先级队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-03 20:10:44" itemprop="dateCreated datePublished" datetime="2020-12-03T20:10:44+08:00">2020-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-04 09:42:58" itemprop="dateModified" datetime="2020-12-04T09:42:58+08:00">2020-12-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的特点是先进先出（FIFO）。 </p>
<ul>
<li>入队列，将新元素置于队尾。</li>
<li>出队列，队头元素最先被移出。</li>
</ul>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列不再遵循先入先出的原则，而是分为两种情况。</p>
<ul>
<li>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 </li>
<li>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队 </li>
</ul>
<h2 id="优先队列实现"><a href="#优先队列实现" class="headerlink" title="优先队列实现"></a>优先队列实现</h2><p>利用线性数据结构并非不能实现，但是时间复杂度较高。因此可以利用二叉堆的特性来实现优先队列。最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。</p>
<p><strong>二叉堆的特性</strong>：</p>
<ul>
<li><p>最大堆的堆顶是整个堆中的最大元素。 </p>
</li>
<li><p>最小堆的堆顶是整个堆中的最小元素。 </p>
</li>
</ul>
<p><strong>二叉堆的时间复杂度</strong>：</p>
<p>插入和删除操作都是O(logn)，构建二叉堆的时间复杂度为O(n)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列初始长度为</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队 * <span class="doctag">@param</span> key 入队元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列长度超出范围，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= array.length) &#123;</span><br><span class="line">      resize();</span><br><span class="line">    &#125;</span><br><span class="line">    array[size++] = key;</span><br><span class="line">    upAdjust();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;the queue is empty !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取堆顶元素</span></span><br><span class="line">    <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 让最后一个元素移动到堆顶</span></span><br><span class="line">    array[<span class="number">0</span>] = array[--size];</span><br><span class="line">    downAdjust();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “上浮”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex]) &#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childIndex] = array[parentIndex];</span><br><span class="line">      childIndex = parentIndex;</span><br><span class="line">      parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “下沉”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp 保存父节点的值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">        childIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点大于任何一个孩子的值，直接跳出</span></span><br><span class="line">      <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childIndex];</span><br><span class="line">      parentIndex = childIndex;</span><br><span class="line">      childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 队列扩容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列容量翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">    priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/" class="post-title-link" itemprop="url">算法（五）之二叉堆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-03 09:52:39" itemprop="dateCreated datePublished" datetime="2020-12-03T09:52:39+08:00">2020-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-04 09:58:54" itemprop="dateModified" datetime="2020-12-04T09:58:54+08:00">2020-12-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆本质上是一种完全二叉树，它分为两个类型。 </p>
<ol>
<li><p>最大堆。 最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值</p>
</li>
<li><p>最小堆。最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p>
<img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200307460.png" alt="image-20201203200307460" style="zoom:80%;">

</li>
</ol>
<p>二叉堆的根节点叫作<strong>堆顶</strong>。最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>插入节点：单一节点上浮，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li>
<li>删除节点：单一节点下沉，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li>
<li>构建二叉堆：要所有非叶子节点依次“下沉”，时间复杂度是O(n)</li>
</ul>
<p><strong>时间复杂度推导</strong></p>
<p>n为节点数，level为层级</p>
<ul>
<li>插入和删除：f(n) = level-1; n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=log<del>2</del>(n+1)-1，所以时间复杂度为O(log<del>2</del>n)</li>
<li>构建二叉堆：满二叉树堆则f(n) = 2^level-1^；n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=2^log(n+1)^-2=n-1,所以为O(n)</li>
</ul>
<h2 id="自我调整"><a href="#自我调整" class="headerlink" title="自我调整"></a>自我调整</h2><p>这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。</p>
<ol>
<li>插入节点 </li>
</ol>
<p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是 0。这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节点“上浮”，和父节点交换位置。继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。继续比较，最终新节点0“上浮”到了堆顶位置。<br><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203105517492.png" alt="image-20201203105517492"></p>
<ol start="2">
<li>删除节点 </li>
</ol>
<p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点。例如删除最小堆的堆顶节点1。这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到原本堆顶的位置。接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果左、右孩子节点中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。</p>
<img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203194844232.png" alt="image-20201203194844232">

<ol start="3">
<li>构建二叉堆</li>
</ol>
<p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，**<font color="red">本质就是让所有 非叶子节点依次“下沉”</font>**。</p>
<p>如下图的无序完全二叉树，找到第一个非叶子节点即10，与其子节点比较，节点6与节点10交互位置。数组方式存储，则下一个节点为节点3，与其子节点比较，节点3与节点2交互位置。下一个节点为1，与字节点比较，不用交换位置。最后一个节点为7，与其子节点比较，节点7下沉，与节点1交互位置，继续与子节点比较，子节点为6和5，最后于5节点交换位置。</p>
<img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200122412.png" alt="image-20201203200122412" style="zoom:80%;">

<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childrenIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&gt;<span class="number">0</span> &amp;&amp; temp&lt;array[parentIndex])&#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childrenIndex] = array[parentIndex];</span><br><span class="line">      childrenIndex = parentIndex;</span><br><span class="line">      parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childrenIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> array  待调整的堆</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parentIndex  要“下沉”的父节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> parentIndex,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&lt;length)&#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span>(childrenIndex+<span class="number">1</span>&lt;length &amp;&amp; array[childrenIndex+<span class="number">1</span>]&lt;array[childrenIndex])&#123;</span><br><span class="line">        childrenIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">      <span class="keyword">if</span>(temp&lt;array[childrenIndex])&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childrenIndex];</span><br><span class="line">      parentIndex = childrenIndex;</span><br><span class="line">      childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeapTree</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">      downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    upAdjust(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    buildHeapTree(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除是用最后一个节点值替换要删除的节点，之后再下沉自我调整</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    downAdjust(array,<span class="number">1</span>,array.length);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉堆的使用场景"><a href="#二叉堆的使用场景" class="headerlink" title="二叉堆的使用场景"></a>二叉堆的使用场景</h2><p>二叉堆是实现<strong>堆排序</strong>及<strong>优先队列</strong>的基础</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">算法（四）之树及二叉树和遍历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-01 13:43:57" itemprop="dateCreated datePublished" datetime="2020-12-01T13:43:57+08:00">2020-12-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-03 10:42:20" itemprop="dateModified" datetime="2020-12-03T10:42:20+08:00">2020-12-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="树概念"><a href="#树概念" class="headerlink" title="树概念"></a>树概念</h2><p>树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。 </p>
<ol>
<li>有且仅有一个特定的称为根的节点。</li>
<li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 <img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134605336.png" alt="image-20201201134605336" style="zoom: 33%;">

</li>
</ol>
<p>在上图中，节点1是根节点（root）；节点5、6、7、8是树的末端，没有“孩子”，被称为叶子节点（leaf）。图中的虚线部分，是根节点1的其中一个子树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134818417.png" alt="image-20201201134818417" style="zoom: 33%;"></p>
<p>树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如下。</p>
<p>在上图中，节点4的上一级节点，是节点4的<strong>父节点（parent）</strong>；从节点4衍生出来的节点，是节点4的<strong>孩子节点（child）</strong>；和节点4同级，由同一个父节点衍生出来的节点，是节点4的<strong>兄弟节点（sibling）</strong></p>
<p>树的最大层级数，被称为树的高度或深度。显然，上图这个树的高度是4。</p>
<h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135228229.png" alt="image-20201201135228229" style="zoom: 33%;"><br>二叉树节点的两个孩子节点，一个被称为<strong>左孩子（left child）</strong>，一个被称为<strong>右孩子（right child）</strong>。这两个孩子节点的顺序是固定的，就像人的左手就是左手，右手就是右手，不能够颠倒或混淆。</p>
<p>二叉树还有两种特殊形式，一个叫作<strong>满二叉树</strong>，另一个叫作<strong>完全二叉树</strong></p>
<h3 id="什么是满二叉树"><a href="#什么是满二叉树" class="headerlink" title="什么是满二叉树"></a>什么是满二叉树</h3><p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。简单点说，满二叉树的每一个分支都是满的。一棵深度为k且有2^K^-1个节点的二叉树称为满二叉树。满二叉树每一层的结点个数都达到了最大值, 即满二叉树的第i层上有2^i-1^个节点（i&gt;=1）<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135513962.png" alt="image-20201201135513962" style="zoom:33%;"></p>
<h3 id="什么是完全二叉树"><a href="#什么是完全二叉树" class="headerlink" title="什么是完全二叉树"></a>什么是完全二叉树</h3><p>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135646991.png" alt="image-20201201135646991" style="zoom:33%;"><br>在上图中，二叉树编号从1到12的12个节点，和前面满二叉树编号从1到12的节点位置完全对应。因此这个树是完全二叉树。<br>完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树</p>
<h3 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h3><p>链式存储结构。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140333971.png" alt="image-20201201140333971" style="zoom:25%;"></p>
<ul>
<li>存储数据的data变量 </li>
<li>指向左孩子的left指针 </li>
<li>指向右孩子的right指针</li>
</ul>
<p>数组。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140524048.png" alt="image-20201201140524048" style="zoom:25%;"><br>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p>
<p><strong>为什么这样设计</strong><br>因为这样可以更方便地在数组中定位二叉树的孩子节点和 父节点。</p>
<p>假设一个父节点的下标是parent，那么它的左孩子节点下标就是2×parent +1；右孩子节点下标就是2×parent + 2。<br>反过来，假设一个左孩子节点的下标是leftChild，那么它的父节点下标就是（leftChild-1）/ 2。<br>假如节点4在数组中的下标是3，节点4是节点2的左孩子，节点2的下标可以直接<br>通过计算得出。节点2的下标 = (3-1)/2 = 1 </p>
<p>显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p>
<p><strong>什么样的二叉树最适合用数组表示呢？</strong></p>
<p>一种特殊的完全二叉树，就是用数组来存储的。</p>
<h3 id="二叉树应用"><a href="#二叉树应用" class="headerlink" title="二叉树应用"></a>二叉树应用</h3><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行<strong>查找操作和维持相对顺序</strong>这两个方面。 </p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>二叉树的树形结构使它很适合扮演索引的角色。 <strong>二叉查找树（binary search tree）</strong>主要作用就是进行查找操作</p>
<p><strong>二叉查找树</strong><br>二叉查找树在二叉树的基础上增加了以下几个条件。 <font color="red"><strong>为了查找方便</strong></font>。</p>
<ul>
<li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值 </li>
<li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值 </li>
<li>左、右子树也都是二叉查找树<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141125488.png" alt="image-20201201141125488" style="zoom:25%;">
对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度是一样的。这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。 
#### **维持相对顺序**
二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。因此二叉查找树还有另一个名字——二叉排序树（binary sort tree）。 

</li>
</ul>
<h4 id="二叉查找树（二叉排序树）的问题"><a href="#二叉查找树（二叉排序树）的问题" class="headerlink" title="二叉查找树（二叉排序树）的问题"></a>二叉查找树（二叉排序树）的问题</h4><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141637961.png" alt="image-20201201141637961" style="zoom:25%;">
在根节点为10的节点情况下，插入9、8、7节点时，会出现如图的情况。查询节点的时间复杂度退化成O(n)。

<h4 id="二叉树自平衡"><a href="#二叉树自平衡" class="headerlink" title="二叉树自平衡"></a>二叉树自平衡</h4><p>二叉树自平衡的方式有多种，如红黑树、AVL树、树堆等</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>从节点之间位置关系的角度来看，二叉树的遍历分为4种</p>
<ul>
<li><p><strong>前序遍历</strong>：输出顺序是根节点、左子树、右子树。</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200256982.png" alt="image-20201201200256982" style="zoom:25%;">
</li>
<li><p><strong>中序遍历</strong>：输出顺序是左子树、根节点、右子树</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200341762.png" alt="image-20201201200341762" style="zoom:25%;">
</li>
<li><p><strong>后序遍历</strong>：输出顺序是左子树、右子树、根节点</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200417902.png" alt="image-20201201200417902" style="zoom:25%;">
</li>
<li><p>层序遍历。层级输出</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201202112654756.png" alt="image-20201202112654756" style="zoom:25%;">

</li>
</ul>
<p>从更宏观的角度来看，二叉树的遍历归结为两大类。</p>
<ul>
<li><p>深度优先遍历（前序遍历、中序遍历、后序遍历）。 所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。</p>
</li>
<li><p>广度优先遍历（层序遍历）。就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点 。</p>
<p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。 </p>
</li>
</ul>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(LinkedList list)</span> </span>&#123;</span><br><span class="line">    TreeNode treeNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(list) || list.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object o = list.removeFirst();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(o)) &#123;</span><br><span class="line">      treeNode = <span class="keyword">new</span> TreeNode();</span><br><span class="line">      treeNode.date = o;</span><br><span class="line">      treeNode.leftNode = createTree(list);</span><br><span class="line">      treeNode.rightNode = createTree(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeachWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode treeNode = root;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (treeNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        stack.push(treeNode.leftNode);</span><br><span class="line">        treeNode = treeNode.leftNode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop != <span class="keyword">null</span>) &#123;</span><br><span class="line">          treeNode = pop.rightNode;</span><br><span class="line">          stack.push(treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    Object date;</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList list = <span class="keyword">new</span> LinkedList(Arrays</span><br><span class="line">        .asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">7</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">10</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="number">4</span>&#125;));</span><br><span class="line">    TreeNode treeNode = createTree(list);</span><br><span class="line">    preOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    preOrderForeachWithStack(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    inOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    postOrderForeach(treeNode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderForeach</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">    TreeNode treeNode = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(treeNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.print(treeNode.date+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(treeNode.leftNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.leftNode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(treeNode.rightNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.rightNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">算法之数据结构线性结构和非线性结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-01 13:27:08" itemprop="dateCreated datePublished" datetime="2020-12-01T13:27:08+08:00">2020-12-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-03 10:25:20" itemprop="dateModified" datetime="2020-12-03T10:25:20+08:00">2020-12-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mr-wuxiansheng/">Mr_伍先生</a></p>
<p>出处：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html">https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html</a></p>
<h2 id="线性结构："><a href="#线性结构：" class="headerlink" title="线性结构："></a>线性结构：</h2><p>一、概念</p>
<ol>
<li><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</p>
</li>
<li><p>线性结构拥有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</p>
</li>
<li><p>线性结构中存在两种操作受限的使用场景，即队列和栈。栈的操作只能在线性表的一端进行，就是我们常说的先进后出（FILO），队列的插入操作在线性表的一端进行而其他操作在线性表的另一端进行，先进先出（FIFO），由于线性结构存在两种存储结构，因 此队列和栈各存在两个实现方式。</p>
</li>
</ol>
<p>二、部分实现</p>
<ol>
<li><p>顺序表（顺序存储）</p>
<p>　　按照我们的习惯，存放东西时，一般是找一块空间，然后将需要存放的东西依次摆放，这就是顺序存储。计算机中的顺序存储是指在内存中用一块地址连续的空间依次存放数据元素，用这种方式存储的线性表叫顺序表其特点是表中相邻的数据元素在内存中存储位置也相邻，如下图：</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809140928262-492338500.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置线性表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     T tmp = <span class="keyword">default</span>(T);</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> len = GetLength() - <span class="number">1</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (i.Equals(len - i))</span><br><span class="line"><span class="number">10</span>         &#123;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>         tmp = data[i];</span><br><span class="line"><span class="number">15</span>         data[i] = data[len - i];</span><br><span class="line"><span class="number">16</span>         data[len - i] = tmp;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表（链式存储）</p>
<p>　　假如我们现在要存放一些物品，但是没有足够大的空间将所有的物品一次性放下（电脑中使用链式存储不是因为内存不够先事先说明一下…，具体原因后续会说到），同时设定我们因为脑容量很小，为了节省空间，只能记住一件物品位置。此时我们很机智的找到了解决方案：存放物品时每放置一件物品就在物品上贴一个小纸条，标明下一件物品放在那里，只记住第一件物品的位置，寻找的时候从第一件物品开始寻找，通过小纸条我们可以找到所有的物品，这就是链式存储。链表实现的时候不再像线性表一样只存储数据即可，还有下一个数据元素的地址，因此先定义一个节点类(Node)，记录物品信息和下一件物品的位置，我们把物品本身叫做数据域，存储下一件物品地址信息的小纸条称为引用域。链表结构示意图如下：</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809143506652-1333091670.png" alt="img"></p>
<p>　　寻找物品的时候发现了一个问题，我们从一件物品找下一件物品的时候很容易，但是如果要找上一件物品就得从头开始找，真的很麻烦。为了解决这个问题我们又机智了一把，模仿之前的做法，在存放物品的时候多放置一个小纸条记录上一件物品的位置，这样就可以很快的找到上一件物品了。我们把这种方式我们称为双向链表，前面只放置一张小纸条的方式称为单向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置单链表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; oldHead = Head;</span><br><span class="line"> <span class="number">5</span>     Node&lt;T&gt; tmp ;</span><br><span class="line"> <span class="number">6</span>     Head = <span class="keyword">null</span>;    <span class="comment">//清空链表，解除Head跟oldHead之间的相同引用</span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="keyword">while</span> (oldHead != <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">9</span>     &#123;</span><br><span class="line"><span class="number">10</span>         tmp = Head;</span><br><span class="line"><span class="number">11</span>         Head = oldHead;</span><br><span class="line"><span class="number">12</span>         <span class="comment">//解除Head跟oldHead之间的相同引用</span></span><br><span class="line"><span class="number">13</span>         oldHead = oldHead.Next;</span><br><span class="line"><span class="number">14</span>         Head.Next = tmp;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure>

<p>　　由于数据存储结构不同导致使用场景上的巨大差异，顺序表由于元素连续具有随机存储的特点，所以查找数据很方便效率很高，但是插入、删除操作为了确保数据元素连续，需要移动大量的数据导致效率很低。而链表由于存储空间不要求连续，插入、删除只需修改相邻元素的引用域地址即可，所以效率很高，但查询需要从头引用开始遍历链表，效率很低。因此，如果只是进行查找操作而不经常插入、删除线性表中的数据元素，则使用顺序存储结构，反之，使用链式存储结构。</p>
</li>
<li><p>栈</p>
<p>　　其实成功完成顺序表和链表之后，栈已经没太多可说的了，主要是逻辑上的不同，毕竟栈也是一种特殊的线性结构。栈是一种操作限定在表尾部进行的线性表，表尾称为栈顶（Top），另一端固定不动，称为栈底（Bottom）。进栈、出栈示意图如下：</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809151153090-1514548602.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链栈入驻</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; tmp = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Top == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Top = tmp;</span><br><span class="line"> <span class="number">8</span>     &#125;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>     &#123;</span><br><span class="line"><span class="number">11</span>         tmp.Next = Top;</span><br><span class="line"><span class="number">12</span>         Top = tmp;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     Num++;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">//顺序栈入栈</span></span><br><span class="line"><span class="number">18</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">19 </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">21</span>     &#123;</span><br><span class="line"><span class="number">22</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"><span class="number">25</span>     data[++Top] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列</p>
<p>　　队列与栈类似，仅仅是逻辑有一丢丢不同。队列是一种插入操作限定在表尾其他操作限定在表头的线性表。把进行插入操作的表尾称为队尾（Rear）,把进行其它操作的头部称为队首（Front）。入队、出队示意图如下：</p>
<img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809152906777-1048463470.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链队入队</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Rear == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Rear = node;</span><br><span class="line"> <span class="number">8</span>         Front = Rear;</span><br><span class="line"> <span class="number">9</span>     &#125;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">11</span>     &#123;</span><br><span class="line"><span class="number">12</span>         Rear.Next = node;</span><br><span class="line"><span class="number">13</span>         Rear = Rear.Next;</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     ++num;</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span> <span class="comment">//循环队列入队</span></span><br><span class="line"><span class="number">19</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">20 </span>&#123;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">22</span>     &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span>     data[++Rear] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="非线性结构："><a href="#非线性结构：" class="headerlink" title="非线性结构："></a>非线性结构：</h2><h3 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a><strong>一、相关概念</strong></h3><p>　　树作为一种应用广泛的一对多非线性数据结构，不仅有数据间的指向关系，还有层级关系，示例见图一。因树的结构比较复杂，为了简化操作及存储，我们一般将树转换为二叉树处理，因此本文主要讨论二叉树。</p>
<ol>
<li><p><strong>二叉树</strong><br>　　二叉树是每个节点最多拥有两个子节点的树结构，若移除根节点则其余节点会被分成两个互不相交的子树，分别称为左子树和右子树。二叉树是有序树，左右子树有严格的次序，若颠倒则成为一棵不一样的二叉树。</p>
</li>
<li><p><strong>满二叉树</strong>　　</p>
<p>​       满二叉树，顾名思义除叶子节点外所有节点都拥有两个孩子，且叶子节点在同一层的二叉树，示例见图二。</p>
</li>
<li><p><strong>完全二叉树</strong>　　</p>
<p>​        完全二叉树，移除最后一层节点后是满二叉树，且最后一层的节点都连续集中在最左面，示例见图三。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812141855625-736751376.png" alt="img"></p>
</li>
</ol>
<h3 id="二、二叉树存储结构"><a href="#二、二叉树存储结构" class="headerlink" title="二、二叉树存储结构"></a>二、二叉树存储结构</h3><ol>
<li><p><strong>顺序存储</strong>　　</p>
<p>​        根据完全二叉树的特性，可以计算出任意节点n的双亲节点及左右孩子节点的序号，因此完全二叉树的节点可以按照从上到下从左到右的顺序依次存储到一维数组中。非完全二叉树存储时应先将其改造为完全二叉树，以空替代不存在的节点，比较浪费存储空间，存储示意图见图四。</p>
</li>
<li><p><strong>链式存储</strong></p>
<p>　　树结构链式存储类似线性结构链式存储，先定义包含数据域和引用域的节点(Node)，然后通过引用域存储节点之间的关系。根据二叉树的结构来看，节点Node至少包含数据域(Data)，引用域(左孩子LChild、右孩子RChild)，为了方便通过孩子节点查找父节点，引用域中可以考虑添加父节点引用(Parent)，存储示意图见图五。</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812161601265-1301764954.png" alt="img"> </p>
</li>
</ol>
<h3 id="三、树与二叉树的转换"><a href="#三、树与二叉树的转换" class="headerlink" title="三、树与二叉树的转换"></a>三、树与二叉树的转换</h3><ol>
<li><p>树转二叉树</p>
<p><strong>加线</strong>，所有兄弟结点之间加一条连线。<br><strong>抹线</strong>，对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。</p>
<p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812155626000-1300189010.png" alt="img"></p>
</li>
<li><p>二叉树转树</p>
<p><strong>加线</strong>，若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来。<br><strong>抹线</strong>，删除原二叉树中所有结点与其右孩子结点的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812160125515-698914833.png" alt="img"></p>
</li>
</ol>
<h3 id="四、树遍历实现"><a href="#四、树遍历实现" class="headerlink" title="四、树遍历实现"></a>四、树遍历实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"> <span class="number">2</span> <span class="comment">/// 先序遍历（DLR）</span></span><br><span class="line"> <span class="number">3</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"> <span class="number">4</span> <span class="comment">/// &lt;![CDATA[首先访问跟节点，然后遍历左子树，最后右子树]]&gt;</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function"> 6 </span>&#123;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     Print(root);</span><br><span class="line"><span class="number">13</span>     PreOrder(root.LChild);</span><br><span class="line"><span class="number">14</span>     PreOrder(root.RChild);</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/// 中序遍历（LDR）</span></span><br><span class="line"><span class="number">19</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">20</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后根节点，最后遍历右子树]]&gt;</span></span><br><span class="line"><span class="number">21</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">22 </span>&#123;</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">24</span>     &#123;</span><br><span class="line"><span class="number">25</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     InOrder(root.LChild);</span><br><span class="line"><span class="number">29</span>     Print(root);</span><br><span class="line"><span class="number">30</span>     InOrder(root.RChild);</span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">34</span> <span class="comment">/// 后序遍历（LRD）</span></span><br><span class="line"><span class="number">35</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">36</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后遍历右子树，最后遍历根节点]]&gt;</span></span><br><span class="line"><span class="number">37</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">38 </span>&#123;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">40</span>     &#123;</span><br><span class="line"><span class="number">41</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">42</span>     &#125;</span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>     PostOrder(root.LChild);</span><br><span class="line"><span class="number">45</span>     PostOrder(root.RChild);</span><br><span class="line"><span class="number">46</span>     Print(root);</span><br><span class="line"><span class="number">47</span> &#125;</span><br><span class="line"><span class="number">48</span> </span><br><span class="line"><span class="number">49</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">50</span> <span class="comment">/// 层序遍历</span></span><br><span class="line"><span class="number">51</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">52</span> <span class="comment">/// &lt;![CDATA[从上向下从左到右]]&gt;</span></span><br><span class="line"><span class="number">53</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">54 </span>&#123;</span><br><span class="line"><span class="number">55</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">56</span>     &#123;</span><br><span class="line"><span class="number">57</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">58</span>     &#125;</span><br><span class="line"><span class="number">59</span>     CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt; sq = <span class="keyword">new</span> CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt;(<span class="number">50</span>);</span><br><span class="line"><span class="number">60</span>     sq.In(root);</span><br><span class="line"><span class="number">61</span>     <span class="keyword">while</span> (!sq.IsEmpty())</span><br><span class="line"><span class="number">62</span>     &#123;</span><br><span class="line"><span class="number">63</span>         Node&lt;<span class="keyword">char</span>&gt; tmp = sq.Out();</span><br><span class="line"><span class="number">64</span>         Print(tmp);</span><br><span class="line"><span class="number">65</span> </span><br><span class="line"><span class="number">66</span>         <span class="keyword">if</span> (tmp.LChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">67</span>         &#123;</span><br><span class="line"><span class="number">68</span>             sq.In(tmp.LChild);</span><br><span class="line"><span class="number">69</span>         &#125;</span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">71</span>         <span class="keyword">if</span> (tmp.RChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">72</span>         &#123;</span><br><span class="line"><span class="number">73</span>             sq.In(tmp.RChild);</span><br><span class="line"><span class="number">74</span>         &#125;</span><br><span class="line"><span class="number">75</span>     &#125;</span><br><span class="line"><span class="number">76</span> &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">java线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-30 18:15:44 / Modified: 18:16:32" itemprop="dateCreated datePublished" datetime="2020-11-30T18:15:44+08:00">2020-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/java%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/java%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">java并发集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-30 18:15:10 / Modified: 18:15:34" itemprop="dateCreated datePublished" datetime="2020-11-30T18:15:10+08:00">2020-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/30/java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/30/java%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">java集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-30 18:12:46" itemprop="dateCreated datePublished" datetime="2020-11-30T18:12:46+08:00">2020-11-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-02 12:00:25" itemprop="dateModified" datetime="2020-12-02T12:00:25+08:00">2020-12-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>数组</strong></p>
<p>​    开辟连续内存地址空间，数组长度固定，不能进行扩容，顺序存储。</p>
<hr>
<p><strong>List集合</strong></p>
<p>​    list集合可以使用数组或链表存储数据。</p>
<ul>
<li><p>ArrayList 使用数组进行存储。查找、更新效率高，插入、删除效率低，顺序存储，扩容为旧数组</p>
</li>
<li><p>LinkedList 使用双向链表进行存储。查找、更新效率低，插入、删除效率高，随机存储，不需要考虑扩容。<font color="red">使用二分查找法</font></p>
</li>
<li><p>Vector 使用数组进行存储，使用synchronized保证线程安全</p>
</li>
</ul>
<hr>
<p><strong>Map哈希表</strong></p>
<ul>
<li><p>HashMap 1.7使用数组+单链表  1.8使用数组+单链表/红黑树(提升插入和查找的效率)，原容量的二倍扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_INITIAL_CAPACITY <span class="comment">//初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</span></span><br><span class="line">MAXIMUM_CAPACITY <span class="comment">//哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</span></span><br><span class="line">DEFAULT_LOAD_FACTOR <span class="comment">//默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span></span><br><span class="line">TREEIFY_THRESHOLD <span class="comment">//如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。</span></span><br><span class="line">UNTREEIFY_THRESHOLD <span class="comment">// 在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。</span></span><br><span class="line">MIN_TREEIFY_CAPACITY <span class="comment">//在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash <span class="comment">//计算下标</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedHashMap  继承HashMap,多了二个自定义的继承HashMap的Node(增加了Entry&lt;K,V&gt; before, after)类的Entry类型的变量head、tail。通过head和tail节点记录数据的<font color="red">插入顺序或者访问顺序。</font>默认是插入顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head; <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail; <span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">//访问顺序，默认为false</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TreeMap  使用红黑树，可以自定义<font color="red">比较器</font>。自动通过key比较大小，如果key相等，则覆盖value的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//根节点</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WeakHashMap 弱键值对，与HashMap类似，使用的是数组+单链表，涉及到扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;(); <span class="comment">//弱引用队列</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弱引用——&gt;回收之后会存入引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashTable 线程安全的，与HashMap类似，使用数组+单链表，涉及到扩容。使用同步块synchronized，保证线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EnumMap</p>
</li>
</ul>
<hr>
<p><strong>Set集合</strong></p>
<ul>
<li><p>HashSet 使用的是HashMap进行数据存储，value为Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedHashSet 继承HashSet，使用LinkedHashMap进行数据存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TreeSet 成员变量m的类型为TreeMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p><strong>Stack栈</strong> 先进后出（FILO），synchronized同步块保证线程安全，继承Vector，底层使用数组保存数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Vector,线程同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>BitSet位图</strong> 使用数组存储，每位存储的值为0或者1，使用位运算。二倍原数组长度扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] words;</span><br><span class="line"><span class="comment">//计算value[值为0,1]在那个数组里下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;  <span class="comment">//ADDRESS_BITS_PER_WORD=6,&gt;&gt;6表示除以2的6次方即64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算bitIndex的值 1L&lt;&lt;64 还是等于为1</span></span><br><span class="line">(words[wordIndex] &amp; (<span class="number">1L</span> &lt;&lt; bitIndex)) != <span class="number">0</span></span><br><span class="line"><span class="comment">//设置bitIndex的值为1</span></span><br><span class="line">words[wordIndex] |= (<span class="number">1L</span> &lt;&lt; bitIndex);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Queue队列</strong></p>
<ul>
<li><p>ArrayDeque 双端队列</p>
</li>
<li><p>PriorityQueue 优先级队列</p>
</li>
<li><p>BlockingQueue 堵塞队列</p>
<ul>
<li><p><strong>LinkedBlockingQueue</strong> 的容量是没有上限的（说的不准确，在不指定时容量为Integer.MAX_VALUE，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong> 在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
</li>
<li><p><strong>DelayQueue</strong>（基于PriorityQueue来实现的）是一个存放Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。 </p>
</li>
<li><p><strong>PriorityBlockingQueue</strong> 是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。</p>
</li>
<li><p><strong>SynchronousQueue</strong> 一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没 有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null 元素。</p>
<p>同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p>
<p> 看起来很有意思吧。队列竟然是没有内部容量的。这个队列其实是BlockingQueue的一种实现。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。它给我们提供了在线程之间交换单一元素的极轻量级方法</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>add</strong></td>
<td>增加一个元索           如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td>
</tr>
<tr>
<td><strong>remove</strong></td>
<td>移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</td>
</tr>
<tr>
<td><strong>element</strong></td>
<td>返回队列头部的元素 ，如果队列为空，则抛出一个NoSuchElementException异常</td>
</tr>
<tr>
<td><strong>offer</strong></td>
<td>添加一个元素并返回true    如果队列已满，则返回false</td>
</tr>
<tr>
<td><strong>poll</strong></td>
<td>移除并返问队列头部的元素  如果队列为空，则返回null</td>
</tr>
<tr>
<td><strong>peek</strong></td>
<td>返回队列头部的元素       如果队列为空，则返回null</td>
</tr>
<tr>
<td><strong>put</strong></td>
<td>添加一个元素           如果队列满，则阻塞</td>
</tr>
<tr>
<td><strong>take</strong></td>
<td>移除并返回队列头部的元素   如果队列为空，则阻塞</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
