<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>注册中心对比</title>
      <link href="2021/02/08/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/"/>
      <url>2021/02/08/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h3 id="consul、eureka、nacos对比"><a href="#consul、eureka、nacos对比" class="headerlink" title="consul、eureka、nacos对比"></a>consul、eureka、nacos对比</h3><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><ul><li>eureka 不支持</li><li>consul 支持 但用起来偏麻烦，不太符合springBoot框架的命名风格，支持动态刷新</li><li>nacos 支持 用起来简单，符合springBoot的命名风格，支持动态刷新</li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><ul><li>eureka<ul><li>应用内/外：直接集成到应用中，依赖于应用自身完成服务的注册与发现，</li><li>CAP原则：遵循AP（可用性+分离容忍）原则，有较强的可用性，服务注册快，但牺牲了一定的一致性。</li><li>版本迭代：目前已经不进行升级</li><li>集成支持：只支持SpringCloud集成</li><li>访问协议：HTTP</li><li>雪崩保护：支持雪崩保护</li><li>界面：英文界面，不符合国人习惯</li><li>上手：容易</li></ul></li><li>consul<ul><li>应用内/外：属于外部应用，侵入性小</li><li>CAP原则：遵循CP原则（一致性+分离容忍） 服务注册稍慢，由于其一致性导致了在Leader挂掉时重新选举期间真个consul不可用。</li><li>版本迭代：目前仍然进行版本迭代</li><li>集成支持：支持SpringCloud K8S集成</li><li>访问协议：HTTP/DNS</li><li>雪崩保护：不支持雪崩保护</li><li>界面：英文界面，不符合国人习惯</li><li>上手：复杂一点</li></ul></li><li>nacos<ul><li>应用内/外：属于外部应用，侵入性小</li><li>CAP原则：通知遵循CP原则（一致性+分离容忍） 和AP原则（可用性+分离容忍）</li><li>版本迭代：目前仍然进行版本迭代</li><li>集成支持：支持Dubbo 、SpringCloud、K8S集成</li><li>访问协议：HTTP/动态DNS/UDP</li><li>雪崩保护：支持雪崩保护</li><li>界面：中文界面，符合国人习惯</li><li>上手：极易，中文文档，案例，社区活跃</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> consul </tag>
            
            <tag> eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC调用理解</title>
      <link href="2021/02/08/RPC%E8%B0%83%E7%94%A8%E7%90%86%E8%A7%A3/"/>
      <url>2021/02/08/RPC%E8%B0%83%E7%94%A8%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>rpc只是一种概念，可以有很多种的实现方式，可以直接http来做，接触到很多公司后端服务之间的调用就是直接通过http来做的，这种实现的方式好处就太多了，简单，现成可用的库很多，缺点也很多，性能，系统伸缩性等都有比较明显的限制。</p><p>  更加成熟的分布式后端解决方案应该还是类似于阿里的那一套基于服务化的系统设计，一般情况下都有一个config中心，用于注册进程和服务的信息，进程之间直接建立连接发起rpc请求，对于业务层面，一般情况下都是提供比较简洁的同步接口，类似于如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service = config.get_service(<span class="string">&quot;fjs&quot;</span>)</span><br><span class="line">res = service.hello(<span class="string">&quot;你好&quot;</span>)<span class="number">12</span></span><br></pre></td></tr></table></figure><p>  通过这种同步的rpc方式，构建出可伸缩的后端系统。（个人觉得这里提供如上的一种简洁的同步的api接口是非常重要的，因为也接触过node.js的一些rpc方案，通过注册回调的方式来实现rpc来回，感觉这对上层写业务来说是一种灾难，这方面node.js确实感觉没有太好的方案，好像fib.js不错，java这方面做的应该是最好的，所以能够找到很多java的服务框架，python其实也可以有很好的实现，毕竟有greenlet这种协程方案。）</p><p>上面好像说了很多无关内容，主要是为了引入接下来的内容，要实现跨进程的通信，那么首先肯定要建立连接，这个时候就会有一些差异了：</p><blockquote><p>（1）对于每一次rpc请求，都单独建立一个tcp连接，请求完成之后关闭连接，每一个请求都需要独占一个tcp连接<br>（2）类似于（1）中实现，只不过对tcp连接做了缓存，类似于连接池的方案，每一次rpc请求都需要独占连接<br>（3）只建立一个连接，请求都共享这个连接，通过一些请求id来标示返回的数据应该属于哪一个请求。</p></blockquote><hr><p>对于上述三种实现，第一种最简单，但是也是可能问题最大的，例如如果进程大量的发起请求，那么将会有大量的tcp连接建立，关闭，开销会比较的大，而且还有可能会出端口耗尽的风险，毕竟tcp有TIME_WAIT这种状态。</p><p>对于第二种就稍微好了一些，但是要维护一个连接池，实现难度就稍大了点。</p><p>对于第三种，这种系统开销最小，但是需要实现请求id的分配和映射，同时还需要有对长连接的状态监测，实现起来难度也稍大。</p><hr><p>对于现在实际工业界的用法，第一种应该很少，相对来说第二种和第三种用的都还算比较的普遍，接下来是一些自己总结的比较实用的一些代码实现方案：</p><ul><li>专门抽出来一个连接管理器，每一次在发起rpc请求的时候，都需要在连接器中申请一个连接，连接管理器负责连接状态监测</li><li>每次在获取连接的时候，对于获取的连接，都应该做一次连接状态的监测，确保连接确实是正常的，常用的方法就是直接select.select来试一下</li><li>最好要根据rpc请求的一些状态，来主动的处理连接，例如出现了一些意料之外的异常，那么为了安全，最好应该将当前主动关闭</li><li>如果语言有上下文管理器，类似于python的with语句，那应该将其利用起来，通过上下文管理来捕获外部代码的一些异常，从而在一些特殊情况下主动关闭连接</li><li>对于第三种类型的长连接实现，最好要实现一个应用层的心跳，因为同一条连接上关联的请求太多，为了减小伤害面积，能够尽早发现异常连接状态越好，那么其实tcp的keepalive就应该够了，那么为啥要实现应用层的心跳呢？这里其实还有另外的考虑，tcp的保活定时器是系统层面上的东西，对于自己的代码其实并不能感知到，就算是对面的进程因为永久性的阻塞而无法服务了，其实保活定时器是无法处理这种情况的</li><li>客户端rpc的超时一定要有，另外服务端，如果是并发的，不管是线程还是协程，都一定要监控运行状态，防止永久性的阻塞造成内存泄露，设定一些阈值，在需要的时候直接终止正在执行的rpc请求</li><li>能用开源的io层实现就尽量用优秀的开源软件来实现，不要自己去写，首先自己写的不管是性能还是系统的鲁棒性估计都有问题，其次，实现的肯定会有各种问题</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日志之ELK简单使用</title>
      <link href="2021/02/07/%E6%97%A5%E5%BF%97%E4%B9%8BELK%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/07/%E6%97%A5%E5%BF%97%E4%B9%8BELK%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>ELK(Elasticsearch + Logstash + Kibana)-&gt;EFK由ElasticSearch、Fluentd和Kiabana三个开源工具组成<br><a href="https://www.jianshu.com/p/09cbd7fb369a">https://www.jianshu.com/p/09cbd7fb369a</a></p><p>业界是采用ELK(Elasticsearch + Logstash + Kibana)来管理日志。Logstash是一个具有实时渠道能力的数据收集引擎,但和fluentd相比，它在效能上表现略逊一筹，故而逐渐被fluentd取代，ELK也随之变成EFK。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>其它</title>
      <link href="2021/02/07/%E5%85%B6%E5%AE%83/"/>
      <url>2021/02/07/%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<p>//redisson<br><dependency><br>    <groupId>org.redisson</groupId><br>    <artifactId>redisson-spring-boot-starter</artifactId><br>    <version>3.13.6</version><br></dependency></p><p>//rocketmq<br><dependency><br>    <groupId>org.apache.rocketmq</groupId><br>    <artifactId>rocketmq-spring-boot-starter</artifactId><br>    <version>2.1.1</version><br></dependency></p><p>//sentry 异常监控平台  Sentry来收集线上错误日志并进行告警、监控及任务分配处理<br><dependency><br>    <groupId>io.sentry</groupId><br>    <artifactId>sentry-spring-boot-starter</artifactId><br></dependency><br><dependency><br>    <groupId>io.sentry</groupId><br>    <artifactId>sentry-logback</artifactId><br></dependency></p><p>@EnableDubbo //使用下面的配置可以不用使用注解，springboot自动配置机制</p><dependency>  <groupId>org.apache.dubbo</groupId>  <artifactId>dubbo-spring-boot-starter</artifactId>  <version>2.7.7</version></dependency><p>@EnableNacosConfig  //使用下面的配置可以不用使用注解，springboot自动配置机制<br>//作用：可以将配置信息注入到environment对象中，方便存取，且可以使用@value注入属性，也可以使用nacos定义的注解注入属性。配置项查看相关的properties<br>//@NacosValue(value = “${alone88.name}”, autoRefreshed = true)<br><dependency><br>  <groupId>com.alibaba.boot</groupId><br>  <artifactId>nacos-config-spring-boot-starter</artifactId><br>  <version>0.2.7</version><br></dependency></p><p>nacos:<br>  config:<br>    server-addr: localhost:8848<br>    namespace: 65711e90-5040-467a-8d59-4c3b2050b9c4<br>    data-id: order-service<br>    bootstrap:<br>      enable: true<br>    type: yaml<br>    auto-refresh: true</p><p>//nacos配置中心定义的注解<br>@Configuration<br>@EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = “127.0.0.1:8848”))<br>@NacosPropertySource(dataId = “example”, autoRefreshed = true)<br>public class NacosConfiguration {</p><p>}</p><p>@NacosValue(value = “${useLocalCache:false}”, autoRefreshed = true)<br>private boolean useLocalCache;</p><p>@EnableNacosDiscovery //使用下面的配置可以不用使用注解，springboot自动配置机制<br>//作用：使用nacos进行服务注册和发现。处理@NacosInjected，注入服务。配置项查看相关的properties<br>//注册 ApplicationContextHolder.class,AnnotationNacosInjectedBeanPostProcessor.class NamingServiceBeanBuilder.class,NamingMaintainServiceBeanBuilder.class<br>//@NacosInjected: An annotation to inject {@link ConfigService} or {@link NamingService} instance into the target Bean.<br><dependency><br>  <groupId>com.alibaba.boot</groupId><br>  <artifactId>nacos-discovery-spring-boot-starter</artifactId><br>  <version>0.2.7</version><br></dependency></p><p>//nacos服务发现定义的注解<br>@Configuration<br>@EnableNacosDiscovery(globalProperties = @NacosProperties(serverAddr = “127.0.0.1:8848”))<br>public class NacosConfiguration {</p><p>}<br>@NacosInjected<br>private NamingService namingService;</p><p>//dubbo和nacos的springboot的starter包都依赖这个包，是一个基于spring的扩展基础包。<br><dependency><br>    <groupId>com.alibaba.spring</groupId><br>    <artifactId>spring-context-support</artifactId><br>    <version>[latest version]</version><br></dependency></p><p>spring cloud 原理是：通过spring-cloud-commons定义了一系列的的api，如服务注册、发现,负载均衡，断路器</p><p>cloud nacos NacosDiscoveryProperties中存放NamingService,实现了DiscoveryClient，实现了服务发现。</p><p>//spring-boot properties属性配置，正规配置就应该这样写<br>@ConfigurationProperties(DUBBO_PREFIX)<br>class DubboConfigurationProperties {<br>    @NestedConfigurationProperty<br>    private Config config = new Config();<br>}</p><p>@AutoConfigureAfter(DubboRelaxedBindingAutoConfiguration.class)<br>@EnableConfigurationProperties(DubboConfigurationProperties.class)<br>@Import(ServiceBeanIdConflictProcessor.class)<br>public class DubboAutoConfiguration {</p><p>}</p><p>dubbo-admin这边默认group都是dubbo<br>dubbo metadata的group是dubbo<br>dubbo registry的group是DEFAULT_GROUP<br>dubbo config-contener是dubbo/dubbo.properties</p><p>doSubscribe(url, listener, serviceNames);<br>notifySubscriber(url, listener, instances);<br>subscribeEventListener(serviceName, url, listener);</p><p> scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();<br>            scheduledExecutorService.scheduleAtFixedRate({}，30，30，TimeUnit.SECONDS）</p><h1 id="Dubbo-配置项"><a href="#Dubbo-配置项" class="headerlink" title="Dubbo 配置项"></a>Dubbo 配置项</h1><p>dubbo:</p><h1 id="Spring-Cloud-Alibaba-Dubbo-专属配置"><a href="#Spring-Cloud-Alibaba-Dubbo-专属配置" class="headerlink" title="Spring Cloud Alibaba Dubbo 专属配置"></a>Spring Cloud Alibaba Dubbo 专属配置</h1><p>  cloud:<br>    subscribed-services: ‘’ # 设置订阅的应用列表，默认为 * 订阅所有应用</p><h1 id="Dubbo-提供者的协议"><a href="#Dubbo-提供者的协议" class="headerlink" title="Dubbo 提供者的协议"></a>Dubbo 提供者的协议</h1><p>  protocol:<br>    name: dubbo<br>    port: -1</p><h1 id="Dubbo-提供服务的扫描基础包"><a href="#Dubbo-提供服务的扫描基础包" class="headerlink" title="Dubbo 提供服务的扫描基础包"></a>Dubbo 提供服务的扫描基础包</h1><p>  scan:<br>    base-packages: cn.iocoder.mall.tradeservice.rpc</p><h1 id="Dubbo-服务提供者的配置"><a href="#Dubbo-服务提供者的配置" class="headerlink" title="Dubbo 服务提供者的配置"></a>Dubbo 服务提供者的配置</h1><p>  provider:<br>    filter: -exception<br>    validation: true # 开启 Provider 参数校验<br>    version: 1.0.0 # 服务的版本号</p><h1 id="Dubbo-服务消费者的配置"><a href="#Dubbo-服务消费者的配置" class="headerlink" title="Dubbo 服务消费者的配置"></a>Dubbo 服务消费者的配置</h1><p>  consumer:<br>    ErrorCodeRpc:<br>      version: 1.0.0<br>    ProductSkuRpc:<br>      version: 1.0.0<br>    UserAddressRpc:<br>      version: 1.0.0<br>    PriceRpc:<br>      version: 1.0.0<br>    CouponCardRpc:<br>      version: 1.0.0<br>    PayTransactionRpc:<br>      version: 1.0.0</p><p>grant all on nacos.* to ‘nacos’@’%’ identified by ‘nacos’ with grant option;</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘nacos’@’%’ identified by ‘nacos’ WITH GRANT OPTION;</p><p>grant all privileges on <em>.</em> to ‘nacos’@’localhost’ ;</p><p>bean初始化：<br>doGetBean{}</p><h2 id="Object-sharedInstance-getSingleton-beanName-缓存"><a href="#Object-sharedInstance-getSingleton-beanName-缓存" class="headerlink" title="Object sharedInstance = getSingleton(beanName); //缓存"></a>Object sharedInstance = getSingleton(beanName); //缓存</h2><h2 id="getSingleton-String-beanName-ObjectFactory-lt-gt-singletonFactory-获取对象"><a href="#getSingleton-String-beanName-ObjectFactory-lt-gt-singletonFactory-获取对象" class="headerlink" title="getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) //获取对象"></a>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) //获取对象</h2><p>singletonsCurrentlyInCreation.add(beanName) //1.</p><p>调用ObjectFactory的createBean方法</p><p>二种情况<br>Object bean = resolveBeforeInstantiation(beanName, mbdToUse); 对象直接返回<br>Object beanInstance = doCreateBean(beanName, mbdToUse, args);<br>    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>        this.singletonFactories.put(beanName, singletonFactory); //三级<br>        this.earlySingletonObjects.remove(beanName); //二级<br>        this.registeredSingletons.add(beanName);</p><p>singletonsCurrentlyInCreation.remove(beanName) // 最后<br>this.singletonObjects.put(beanName, singletonObject);<br>this.singletonFactories.remove(beanName);<br>this.earlySingletonObjects.remove(beanName);</p><p>通过三级缓存生成二级缓存。</p><p>springboot 增加Filter<br>方案一：<br>1、 @WebFilter(urlPatterns = “/<em>“) public class MemberFilter implements Filter {}<br>2、 @ServletComponentScan(basePackages = {“com.example.controller.filter”})<br>方案二：<br>@Bean<br>public FilterRegistrationBean filterProxy() {<br>    FilterRegistrationBean registrationBean = new FilterRegistrationBean();<br>    DelegatingFilterProxy httpBasicFilter = new DelegatingFilterProxy();<br>    registrationBean.setFilter(httpBasicFilter);<br>    Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;();<br>    m.put(“targetBeanName”, “memberFilter”);<br>    m.put(“targetFilterLifecycle”, “true”);<br>    registrationBean.setInitParameters(m);<br>    List<String> urlPatterns = new ArrayList<String>();<br>    urlPatterns.add(“/</String></String></em>“);<br>    registrationBean.setUrlPatterns(urlPatterns);<br>    return registrationBean;<br>}</p><p>DelegatingFilterProxyRegistrationBean</p><p>springSecurityFilterChain</p><p>资源服务器<br>@EnableResourceServer -&gt; @Import(ResourceServerConfiguration.class) -&gt;ResourceServerConfiguration extends WebSecurityConfigurerAdapter 类上有@Configuration<br>@EnableResourceServer<br>public class ResourceServerConfig extends ResourceServerConfigurerAdapter{}</p><p>认证服务器逻辑实现<br>@EnableAuthorizationServer-&gt;@Import({AuthorizationServerEndpointsConfiguration.class, AuthorizationServerSecurityConfiguration.class})</p><p>AuthorizationServerEndpointsConfiguration-&gt;@Import(TokenKeyEndpointRegistrar.class)-&gt;注册TokenKeyEndpoint.class<br>AuthorizationServerSecurityConfiguration extends WebSecurityConfigurerAdapter(类上有@Configuration) -&gt;@Import({ ClientDetailsServiceConfiguration.class, AuthorizationServerEndpointsConfiguration.class })</p><p>ClientDetailsServiceConfiguration -&gt; 配置ClientDetailsServiceConfiguration</p><p>@EnableAuthorizationServer<br>public class AuthorizationConfig extends AuthorizationServerConfigurerAdapter{}</p><p>@EnableOAuth2Client -》@Import(OAuth2ClientConfiguration.class)</p><p>spring-security-oauth2-autoconfigure.jar<br>@EnableOAuth2Sso -&gt;@EnableOAuth2Client  @Import({ OAuth2SsoDefaultConfiguration.class, OAuth2SsoCustomConfiguration.class,<br>    ResourceServerTokenServicesConfiguration.class })</p><p>security:<br>  oauth2:<br>    client:<br>      client-id: sso-server<br>      client-secret: deepblueai@2018<br>      user-authorization-uri: ${sso.auth.server}/oauth/authorize<br>      access-token-uri: ${sso.auth.server}/oauth/token<br>      scope: server<br>    resource:<br>      jwt:<br>        key-value: jwt:token:deepblue</p><p>spring bean注入扩展类<br>BeanDefinitionRegistryPostProcessor</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring的bean加载及生命周期</title>
      <link href="2021/02/07/spring%E7%9A%84bean%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2021/02/07/spring%E7%9A%84bean%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring容器启动"><a href="#Spring容器启动" class="headerlink" title="Spring容器启动"></a>Spring容器启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 会初始化一个BeanFactory,为默认的DefaultListableBeanFactory</span></span><br><span class="line">    <span class="comment">// 会初始化一个beanDefinition的读取器，同时向容器中注册了7个spring的后置处理器(包括BeanPostProcessor和BeanFactoryPostProcessor)</span></span><br><span class="line">    <span class="comment">// 会初始化一个扫描器，后面似乎并没有用到这个扫描器，在refresh()中使用的是重新new的一个扫描器。</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// 将配置类注册进BeanDefinitionMap中</span></span><br><span class="line">    <span class="comment">//将传入的配置类annotatedClasses解析成BeanDefinition(实际类型为AnnotatedGenericBeanDefinition)，然后放入到BeanDefinitionMap中，这样后面在ConfigurationClassPostProcessor中能解析annotatedClasses，例如demo中的AppConfig类，只有解析了AppConfig类，才能知道Spring要扫描哪些包(因为在AppConfig类中添加了@ComponentScan注解)，只有知道要扫描哪些包了，才能扫描出需要交给Spring管理的bean有哪些，这样才能利用Spring来创建bean。</span></span><br><span class="line">    register(annotatedClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring容器刷新"><a href="#spring容器刷新" class="headerlink" title="spring容器刷新"></a>spring容器刷新</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"> <span class="number">2</span>    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"> <span class="number">3</span>        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"> <span class="number">4</span>        <span class="comment">// 初始化属性配置文件、检验必须属性以及监听器</span></span><br><span class="line"> <span class="number">5</span>        prepareRefresh();</span><br><span class="line"> <span class="number">6</span>        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"> <span class="number">7</span>        <span class="comment">// 给beanFactory设置序列化id</span></span><br><span class="line"> <span class="number">8</span>        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"> <span class="number">9</span>        <span class="comment">// 向beanFactory中注册了两个BeanPostProcessor,以及三个和环境相关的bean</span></span><br><span class="line"><span class="number">10</span>        <span class="comment">// 这两个后置处理器为ApplicationContextAwareProcessor和ApplicationListenerDetector</span></span><br><span class="line"><span class="number">11</span>        <span class="comment">// 前一个后置处理是为实现了ApplicationContextAware接口的类，回调setApplicationContext()方法，</span></span><br><span class="line"><span class="number">12</span>        <span class="comment">// 后一个处理器时用来检测ApplicationListener类的，当某个Bean实现了ApplicationListener接口的bean被创建好后，会被加入到监听器列表中</span></span><br><span class="line"><span class="number">13</span>        prepareBeanFactory(beanFactory);</span><br><span class="line"><span class="number">14</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">15</span>            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="number">16</span>            <span class="comment">// 空方法，由子类实现</span></span><br><span class="line"><span class="number">17</span>            postProcessBeanFactory(beanFactory);</span><br><span class="line"><span class="number">18</span>            <span class="comment">// 执行所有的BeanFactoryPostProcessor，包括自定义的，以及spring内置的。默认情况下，容器中只有一个BeanFactoryPostProcessor,即：Spring内置的，ConfigurationClassPostProcessor(这个类很重要)</span></span><br><span class="line"><span class="number">19</span>            <span class="comment">// 会先执行实现了BeanDefinitionRegistryPostProcessor接口的类，然后执行BeanFactoryPostProcessor的类</span></span><br><span class="line"><span class="number">20</span>            <span class="comment">// ConfigurationClassPostProcessor类的postProcessorBeanFactory()方法进行了@Configuration类的解析，@ComponentScan的扫描，以及@Import注解的处理</span></span><br><span class="line"><span class="number">21</span>            <span class="comment">// 经过这一步以后,会将所有交由spring管理的bean所对应的BeanDefinition放入到beanFactory的beanDefinitionMap中</span></span><br><span class="line"><span class="number">22</span>            <span class="comment">// 同时ConfigurationClassPostProcessor类的postProcessorBeanFactory()方法执行完后，向容器中添加了一个后置处理器————ImportAwareBeanPostProcessor</span></span><br><span class="line"><span class="number">23</span>            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"><span class="number">24</span>            <span class="comment">// 注册所有的BeanPostProcessor，因为在方法里面调用了getBean()方法，所以在这一步，实际上已经将所有的BeanPostProcessor实例化了</span></span><br><span class="line"><span class="number">25</span>            <span class="comment">// 为什么要在这一步就将BeanPostProcessor实例化呢？因为后面要实例化bean，而BeanPostProcessor是用来干预bean的创建过程的，所以必须在bean实例化之前就实例化所有的BeanPostProcessor(包括开发人员自己定义的)</span></span><br><span class="line"><span class="number">26</span>            <span class="comment">// 最后再重新注册了ApplicationListenerDetector，这样做的目的是为了将ApplicationListenerDetector放入到后置处理器的最末端</span></span><br><span class="line"><span class="number">27</span>            registerBeanPostProcessors(beanFactory);</span><br><span class="line"><span class="number">28</span>            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="number">29</span>           <span class="comment">// 初始化MessageSource，用来做消息国际化。在一般项目中不会用到消息国际化</span></span><br><span class="line"><span class="number">30</span>            initMessageSource();</span><br><span class="line"><span class="number">31</span>            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="number">32</span>            <span class="comment">// 初始化事件广播器，如果容器中存在了名字为applicationEventMulticaster的广播器，则使用该广播器</span></span><br><span class="line"><span class="number">33</span>            <span class="comment">// 如果没有，则初始化一个SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="number">34</span>            <span class="comment">// 事件广播器的用途是，发布事件，并且为所发布的时间找到对应的事件监听器。</span></span><br><span class="line"><span class="number">35</span>            initApplicationEventMulticaster();</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">37</span>            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="number">38</span>            <span class="comment">// 执行其他的初始化操作，例如和SpringMVC整合时，需要初始化一些其他的bean，但是对于纯spring工程来说，onFresh方法是一个空方法</span></span><br><span class="line"><span class="number">39</span>            onRefresh();</span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">41</span>            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="number">42</span>            <span class="comment">// 这一步会将自定义的listener的bean名称放入到事件广播器中</span></span><br><span class="line"><span class="number">43</span>            <span class="comment">// 同时还会将早期的ApplicationEvent发布(对于单独的spring工程来说，在此时不会有任何ApplicationEvent发布，但是和springMVC整合时，springMVC会执行onRefresh()方法，在这里会发布事件)</span></span><br><span class="line"><span class="number">44</span>            registerListeners();</span><br><span class="line"><span class="number">45</span>            <span class="comment">// 实例化剩余的非懒加载的单例bean(注意：剩余、非懒加载、单例)</span></span><br><span class="line"><span class="number">46</span>            <span class="comment">// 为什么说是剩余呢？如果开发人员自定义了BeanPosrProcessor，而BeanPostProcessor在前面已经实例化了，所以在这里不会再实例化，因此这里使用剩余一词</span></span><br><span class="line"><span class="number">47</span>            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"><span class="number">48</span>            <span class="comment">// 结束refresh，主要干了一件事，就是发布一个事件ContextRefreshEvent，通知大家spring容器refresh结束了。</span></span><br><span class="line"><span class="number">49</span>            finishRefresh();</span><br><span class="line"><span class="number">50</span>        &#125;</span><br><span class="line"><span class="number">51</span>        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="number">52</span>            <span class="comment">// 出异常后销毁bean</span></span><br><span class="line"><span class="number">53</span>            destroyBeans();</span><br><span class="line"><span class="number">54</span>            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line"><span class="number">55</span>            cancelRefresh(ex);</span><br><span class="line"><span class="number">56</span>            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="number">57</span>            <span class="keyword">throw</span> ex;</span><br><span class="line"><span class="number">58</span>        &#125;</span><br><span class="line"><span class="number">59</span>        <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="number">60</span>           <span class="comment">// 在bean的实例化过程中，会缓存很多信息，例如bean的注解信息，但是当单例bean实例化完成后，这些缓存信息已经不会再使用了，所以可以释放这些内存资源了</span></span><br><span class="line"><span class="number">61</span>            resetCommonCaches();</span><br><span class="line"><span class="number">62</span>        &#125;</span><br><span class="line"><span class="number">63</span>    &#125;</span><br><span class="line"><span class="number">64</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.beanName先从map中获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">//2.判断beanName是否在singletonsCurrentlyInCreation中</span></span><br><span class="line"><span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"><span class="comment">//3.如果存在singletonsCurrentlyInCreation中，则从earlySingletonObjects中获取，</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//4. 如果为空，从singletonFactories中获取ObjectFactory，如果singletonFactory不为空，获取bean</span></span><br><span class="line"><span class="comment">// 存入earlySingletonObjects中，删除singletonFactories中的beanName</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/q6zs7xRjpcB4YxLw6w477w">Spring源码系列之容器启动流程</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Mjg2NjUzNw==&mid=2247483679&idx=1&sn=03a08c6844397a6d2610d89577eb8558&scene=21#wechat_redirect">看Bean的创建过程</a></p><p><a href="https://www.cnblogs.com/duanxz/p/3787884.html">spring加载及刷新容器流程</a></p><p><a href="https://blog.csdn.net/finalcola/article/details/81449140">spring创建bean流程</a></p><hr><h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法，再执行BeanFactoryPostProcessor的postProcessBeanFactory方法</p><h2 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a><font color="red">ConfigurationClassPostProcessor</font></h2><ul><li>(1) @Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？</li><li>(2) Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？</li><li>(3) Spring什么时候解析了@Import注解，如何解析的？</li><li>(4) Spring什么时候解析了@Bean注解？</li></ul><p><a href="https://blog.csdn.net/qq_34436819/article/details/100944204">ConfigurationClassPostProcessor详解</a></p><hr><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><h2 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h2><h2 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h2><h2 id="InstantiationAwareBeanPostProcessorAdapter"><a href="#InstantiationAwareBeanPostProcessorAdapter" class="headerlink" title="InstantiationAwareBeanPostProcessorAdapter"></a>InstantiationAwareBeanPostProcessorAdapter</h2><h2 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a><font color="red">AutowiredAnnotationBeanPostProcessor</font></h2><p>bean的后置处理器用来处理@Autowired的注入</p><h2 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a><font color="red">CommonAnnotationBeanPostProcessor</font></h2><p>用来处理如@Resource，@PostConstruct等符合JSR-250规范的注解</p><h2 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a><font color="red">RequiredAnnotationBeanPostProcessor</font></h2><h2 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a><font color="red">PersistenceAnnotationBeanPostProcessor</font></h2><p>用来支持JPA</p><h2 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a><font color="red">EventListenerMethodProcessor</font></h2><p>注册EventListenerMethodProcessor，用来处理方法上加了@EventListener注解的方法</p><h2 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a><font color="red">DefaultEventListenerFactory</font></h2><p>事件监听器的工厂</p><hr><h2 id="SmartInitializingSingleton"><a href="#SmartInitializingSingleton" class="headerlink" title="SmartInitializingSingleton"></a>SmartInitializingSingleton</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现SmartInitializingSingleton的接口后，当所有单例 bean 都初始化完成以后， Spring的IOC容器会回调该接口的afterSingletonsInstantiated()方法。主要应用场合就是在所有单例 bean 创建完成之后，可以在该回调中做一些事情。</p><hr><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><a href="https://blog.csdn.net/f641385712/article/details/88904983">Spring AOP详解</a></p><p><a href="https://blog.csdn.net/f641385712/article/details/89303088">SpringAOP引入增强</a></p><p><a href="https://blog.csdn.net/chuzunyuan9004/article/details/100984276">spring aop</a></p><h3 id="切面编程之spring的AOP和AspectJ的区别"><a href="#切面编程之spring的AOP和AspectJ的区别" class="headerlink" title="切面编程之spring的AOP和AspectJ的区别"></a>切面编程之spring的AOP和AspectJ的区别</h3><p>①选择spring的AOP还是AspectJ?<br>spring确实有自己的AOP。功能已经基本够用了，除非你的要在接口上动态代理或者方法拦截精确到getter和setter。这些都是写奇葩的需求，一般不使用。<br>②在使用AOP的时候，你是用xml还是注解的方式（@Aspect）？<br>1）如果使用xml方式，不需要任何额外的jar包。<br>2）如果使用@Aspect方式，你就可以在类上直接一个@Aspect就搞定，不用费事在xml里配了。但是这需要额外的jar包（ aspectjweaver.jar）。因为spring直接使用AspectJ的注解功能，注意只是使用了它 的注解功能而已。并不是核心功能 ！！！<br>注意到文档上还有一句很有意思的话：文档说到 是选择spring AOP还是使用full aspectJ？<br>什么是full aspectJ？如果你使用”full aspectJ”。就是说你可以实现基于接口的动态代理，等等强大的功能。而不仅仅是aspectj的 注-解-功-能 ！！！<br>如果用full AspectJ。比如说Load-Time Weaving的方式 还 需要额外的jar包 spring-instrument.jar<br>当然，无论是使用spring aop还是 aspectj都需要aspectjweaver.jar spring-aop.jar这两个jar包</p><p>spring有自己的AOP实现与aspectj的实现不同比较麻烦，马士兵的教程所讲的是spring整合了aspectj的AOP马士兵没有将spring自己的aop，在视频的末尾他说一般情况用不到spring自己的AOP你可以仔细听听，spring在做声明式事物处理时就没有用aspectj嘛！springAOP是设计用于在应用服务器环境下实现AOP，切入点与方面均由普通Java对象实现，其中连接点模型与AspectJ相同，只是远不如AspectJ丰富。针对你的问题spring有两组AOP一组是spring本身的一组是整合AspectJ，就好比在国际上一个中国人说英语是因为大家都说英语（好比AspectJ），但中国人还有自己的语言中文（spring自己的AOP）</p><h3 id="AOP植入方式"><a href="#AOP植入方式" class="headerlink" title="AOP植入方式"></a>AOP植入方式</h3><p>AOP有三种植入切面的方法：其一是编译期织入，这要求使用特殊的Java编译器，AspectJ是其中的代表者；其二是类装载期织入，而这要求使用特殊的类装载器，AspectJ和AspectWerkz是其中的代表者；其三为动态代理织入，在运行期为目标类添加增强生成子类的方式，Spring AOP采用动态代理织入切面。<br>Spring AOP使用了两种代理机制，一种是基于JDK的动态代理，另一种是基于CGLib的动态代理，之所以需要两种代理机制，很大程度上是因为JDK本身只提供基于接口的代理，不支持类的代理。</p><h3 id="Aop实战"><a href="#Aop实战" class="headerlink" title="Aop实战"></a>Aop实战</h3><p><a href="https://blog.csdn.net/flyfeifei66/article/details/82784321">Spring提供了四种类型的Aop支持 </a></p><h3 id="AOP通知"><a href="#AOP通知" class="headerlink" title="AOP通知"></a>AOP通知</h3><p>前置通知：org.springframework.aop.MethodBeforeAdvice<br>后置通知：org.springframework.aop.AfterReturningAdvice<br>环绕通知：org.aopalliance.intercept.MethodInterceptor<br>异常通知：org.springframework.aop.ThrowsAdvice</p><p>[<a href="https://www.cnblogs.com/chaoesha/p/13037368.html">面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？</a></p><p><img src="/2021/02/07/spring%E7%9A%84bean%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20160113113029764" alt="img"></p><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性占位符工具类</span></span><br><span class="line">PropertyPlaceholderHelper</span><br><span class="line"><span class="comment">//资源工具类</span></span><br><span class="line">ResourceUtils</span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line">AnnotationAttributes extends LinkedHashMap&lt;String, Object&gt;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">ClassUtils</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">WebApplicationContextUtils</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">AnnotatedElementUtils</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">AnnotationUtils</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring学习笔记</title>
      <link href="2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="对象bean实例化"><a href="#对象bean实例化" class="headerlink" title="对象bean实例化"></a>对象bean实例化</h2><ul><li>构造函数对象实例化</li><li>静态工厂方法实例化</li><li>工厂方法实例化</li></ul><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><ul><li>带参构造函数对象实例化注入属性</li><li>set方法</li><li>注解注入</li><li>ref标签<br>普通属性注入</li><li>property标签</li><li>配置PropertyPlaceholderConfigurer</li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>标签配置depends-on</li><li>注解@DependsOn</li></ul><h2 id="延迟加载-阻止预初始化"><a href="#延迟加载-阻止预初始化" class="headerlink" title="延迟加载(阻止预初始化)"></a>延迟加载(阻止预初始化)</h2><ul><li>标签配置lazy-init=true</li><li>对容器层次default-lazy-init=true</li></ul><h2 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h2><p>如单例对象中需要注入原型对象，如果直接依赖注入，会导致注入的是单例对象，因为只会注入一次</p><ul><li>可以使用ApplicationContextAware,通过applicationContext属性获取bean，即使用getBean方法</li><li>标签配置lookup-method，指定方法name，指定使用的类。或者使用注解@Lookup。使用的是CGLIB库的方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果</li><li>标签配置replaced-method,需要继承MethodReplacer，也是使用的是CGLIB库的方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果</li></ul><h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><ul><li>sigleton</li><li>prototype</li><li>request</li><li>session</li><li>application</li><li>websockct</li></ul><p>后面四个，如果不使用springmvc则需要进行配置，Servlet2.5需要注册RequestContextListener或者ServletRequestListener或者RequestContextFilter。<br>都是绑定请求对象到服务请求的Thread上，才使得bean在之后的调用链上可见。Servlet3.0之后，这些都能够通过WebApplicationInitializer接口实现</p><h3 id="自定义scope"><a href="#自定义scope" class="headerlink" title="自定义scope"></a>自定义scope</h3><p>1、实现Scope接口，重写get和remove方法<br>2、配置CustomScopeConfurer</p><h2 id="自定义Bean的生命周期"><a href="#自定义Bean的生命周期" class="headerlink" title="自定义Bean的生命周期"></a>自定义Bean的生命周期</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行顺序为先注解-》接口实现-》自定义的方法</p><ul><li><p>InitializeingBean（afterPropertiesSet()） </p></li><li><p>@PostConstruct</p></li><li><p>DisposableBean（destroy()）</p></li><li><p>@PreDestroy</p></li><li><p>init-method</p></li><li><p>destroy-method</p></li></ul><p>Bean后置处理器<br>后置处理器包含二个方法，初始化之前的方法和初始化之后的方法</p><ul><li>接口==BeanPostProcessor==</li></ul><h3 id="生命周期接口"><a href="#生命周期接口" class="headerlink" title="生命周期接口"></a>生命周期接口</h3><p>接口==Lifecycle==，为任何有自己生命周期需求的对象定义了一些基本的方法（如停止和启动一些后台进程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>; <span class="comment">//开始</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口==LifecycleProcessor==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;  <span class="comment">//刷新</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;    <span class="comment">//关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类==DefaultLifecycleProcessor==会等到配置的时间超时再调用回调。默认每阶段的时间是30s，可以通过timeoutPerShutdownPhase修改超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultLifecycleProcessor</span> <span class="keyword">implements</span> <span class="title">LifecycleProcessor</span>, <span class="title">BeanFactoryAware</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动关闭顺序"><a href="#启动关闭顺序" class="headerlink" title="启动关闭顺序"></a>启动关闭顺序</h3><ul><li>==Phased==(getPhased) 定义了执行的顺序。Bean直接存在depends-on的关系，被依赖的一方要更早的启动，关闭的更早。然而有时候直接的依赖是未知的，而开发者仅仅知道哪一种类型更早的进行初始化，就可以实现Phased接口</li><li>接口==SmartLifecycle== extends Lifecycle,Phased(提供了isAutoStartup,stop(Runnable callback)方法)</li><li>当启动时，拥有最低phased的对象优先启动，当关闭时，相反。未实现Phased和SmartLifecycle接口的对象，phased默认值为0</li><li>SmartLifecycle 中的stop方法，回调函数，在关闭流程完成之后调用回调中的run()方法，可以做到异步关闭</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">        callback.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优雅关闭spring的ioc容器"><a href="#优雅关闭spring的ioc容器" class="headerlink" title="优雅关闭spring的ioc容器"></a>优雅关闭spring的ioc容器</h3><p>ConfigurableApplicationContext调用registerShutdownHook()；</p><h3 id="aware接口"><a href="#aware接口" class="headerlink" title="aware接口"></a>aware接口</h3><p>aware接口的方法回调发生在属性配置完成之后，初始化回调之前，后置处理器之前</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210119112030740-1612677917089.png" alt="image-20210119112030740"></p><h2 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h2><p>父子Bean，子Bean可以继承父Bean的元数据配置，父类可以是抽象类，使用abstract=”true”标识。</p><p>ChildBeanDefinition</p><h2 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h2><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>可以配置多个BeanPostProcessor，通过order属性控制执行顺序，实现Ordered接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>操作Bean的配置元数据，即读取配置元数据，bean实例化之前修改它，也是可以配置多个，通过order控制执行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>是Spring IoC容器实例化逻辑的可插拔点。如果开发者的初始化代码很复杂，相当于需要写很多的xml信息，可以使用java语言来表达。可以创建自己的FactoryBean，在类中编写复杂的初始化代码，然后将自定义的FactoryBean插入容器中。</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120100739444-1612677926892.png" alt="image-20210120100739444"></p><p>如果需要返回的是FactoryBean对象，则使用getBean(“&amp;myBean”)，如果获取FactoryBean生成的对象，则使用getBean(“myBean”)</p><h2 id="扩展点实战"><a href="#扩展点实战" class="headerlink" title="扩展点实战"></a>扩展点实战</h2><h3 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h3><p>底层是继承抽象类PlaceholderConfigurerSupport，抽象类继承抽象类PropertyResourceConfigurer，抽象类继承PropertiesLoaderSupport和实现了BeanFactoryPostProcessor接口，完成了读取配置文件，替换占位符${}。</p><p>以前在xml中配置jdbc.properties，或者在xml中使用&lt;conetext:property-placeholder location=”classpath:jdbc.properties”&gt;</p><h3 id="PropertyOverrideConfigurer"><a href="#PropertyOverrideConfigurer" class="headerlink" title="PropertyOverrideConfigurer"></a>PropertyOverrideConfigurer</h3><p>底层是继承抽象类PropertyResourceConfigurer,属性覆盖。</p><h2 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h2><ul><li>@Required</li><li>@Autowired</li><li>JSR-250注解支持：@Resource、@PostConstruct、@PreDestroy、@ManagedBean可以替代@Component</li><li>JSR-330注解支持：@Inject可以代替@Autowired、@Qualifier、@Named可以替代@Component、@Provider</li><li>@Primary,指定一个优先提供的特殊bean。当存在多个bean时，使用是未指定特定的bean，会使用注解标识的bean</li></ul><p>CommonAnnotationBeanPostProcessor不但能识别@Resource注解，而且能识别JSR-250生命周期注解</p><h2 id="类路径扫描及组件管理"><a href="#类路径扫描及组件管理" class="headerlink" title="类路径扫描及组件管理"></a>类路径扫描及组件管理</h2><p>通过扫描类路径的方式来隐式检测候选组件的方式。候选组件是匹配过滤条件的类库。</p><ul><li>@Configuration @Bean  @Import  @DependsOn @ImportSource</li><li>@Repository @Component @Service @Controller</li><li>元注解如@RestController</li><li>@ControllerAdvice</li><li>@ComponentScan</li></ul><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120111448978-1612677932522.png" alt="image-20210120111448978"></p><h2 id="基于java的容器配置"><a href="#基于java的容器配置" class="headerlink" title="基于java的容器配置"></a>基于java的容器配置</h2><h3 id="AnnotationConfigApplicationContext指定加载的配置类"><a href="#AnnotationConfigApplicationContext指定加载的配置类" class="headerlink" title="AnnotationConfigApplicationContext指定加载的配置类"></a>AnnotationConfigApplicationContext指定加载的配置类</h3><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120112308757-1612677934627.png" alt="image-20210120112308757"></p><h3 id="使用编程式构建容器"><a href="#使用编程式构建容器" class="headerlink" title="使用编程式构建容器"></a>使用编程式构建容器</h3><p>AnnotationConfigApplicationContext对象有注册bean的方法</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120112510068-1612677936569.png" alt="image-20210120112510068"></p><h3 id="使用scan开启组件扫描"><a href="#使用scan开启组件扫描" class="headerlink" title="使用scan开启组件扫描"></a>使用scan开启组件扫描</h3><p>@ComponentScan(basePackages=”com.hufei”)或在xml中配置&lt;context:component-scan base-package=”com.hufei”&gt;</p><p>或者在ctx中使用scan方法，需要refresh方法，刷新容器</p><h2 id="环境抽象"><a href="#环境抽象" class="headerlink" title="环境抽象"></a>环境抽象</h2><p>Environment是一个集成到容器中的特殊抽象，它针对应用的环境建立了profile和properties二个关键的概念。</p><p>@Profile(“dev”) 表示对应dev环境下，配置才会生效。可以通过指定配置文件spring.profiles.active属性指定环境，也可以通过ctx.getEnvironment().setActiveProfiles(“dev”)，再刷新容器。@Profile(“default”)如果未指定，则使用此默认。</p><p>@PropertySource将PropertySource增加到Spring的Environment中。@PropertySource(“classpath:app.properties”)。路径还可以使用占位符。@PropertySource(“classpath:/com/${my.placeholder:default/path}/app.properties”)</p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120114552069-1612677939086.png" alt="image-20210120114552069"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalMessageSource</span> <span class="keyword">extends</span> <span class="title">MessageSource</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingMessageSource</span> <span class="keyword">extends</span> <span class="title">MessageSourceSupport</span> <span class="keyword">implements</span> <span class="title">HierarchicalMessageSource</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMessageSource</span> <span class="keyword">extends</span> <span class="title">MessageSourceSupport</span> <span class="keyword">implements</span> <span class="title">HierarchicalMessageSource</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResourceBasedMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractMessageSource</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBundleMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractResourceBasedMessageSource</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReloadableResourceBundleMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractResourceBasedMessageSource</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMessageSource</span> <span class="keyword">extends</span> <span class="title">AbstractMessageSource</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="事件监听-观察者模式"><a href="#事件监听-观察者模式" class="headerlink" title="事件监听(观察者模式)"></a>事件监听(观察者模式)</h2><p>ApplicationEvent</p><p>ApplicationListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleApplicationEventMulticaster</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationEventMulticaster</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationEventMulticaster</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ApplicationEventMulticaster</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120160456974-1612677942764.png" alt="image-20210120160456974"></p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><ul><li>事件类A实现ApplicationEvent接口</li><li>发布事件类B，实现ApplicationEventPublisherAware接口，重写setApplicationEventPublisher方法，注入事件发布对象，发布事件</li><li>配置事件监听类C，实现ApplicationListener，重写onApplicationEvent方法</li></ul><h3 id="注解自定义事件"><a href="#注解自定义事件" class="headerlink" title="注解自定义事件"></a>注解自定义事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener(&#123;xxxEvent.class,xxxEvent.class&#125;)</span> <span class="comment">//事件监听</span></span><br><span class="line"><span class="meta">@Async</span> <span class="comment">//异步处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(xxEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120162529783-1612677945009.png" alt="image-20210120162529783"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120162546973-1612677946793.png" alt="image-20210120162546973"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210120162618110-1612677948850.png" alt="image-20210120162618110"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用spring-aop</span></span><br><span class="line"><span class="comment">// 注册bean的名称为:org.springframework.aop.config.internalAutoProxyCreator</span></span><br><span class="line">InfrastructureAdvisorAutoProxyCreator.class</span><br><span class="line">APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用AspectJ</span></span><br><span class="line">AnnotationAwareAspectJAutoProxyCreator</span><br></pre></td></tr></table></figure><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><ul><li><p>Advice 通知                                          会被DefaultPointcutAdvisor包装</p></li><li><p>Interceptor extends Advice  拦截器     会被DefaultPointcutAdvisor包装   </p></li><li><p>MethodInterceptor extends Interceptor   方法拦截器     MethodInterceptor会被DefaultPointcutAdvisor包装</p></li><li><p>Advisor 增强器  Advice getAdvice();获取增强  </p></li><li><p>PointcutAdvisor extends Advisor   带切入点的增强器 public Pointcut getPointcut() ; 获取切入点</p></li><li><p>ProxyFactory extends ProxyCreatorSupport extends AdvisedSupport  extends ProxyConfig implements Advised</p></li><li><p>GlobalAdvisorAdapterRegistry有实例：DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry</p></li><li><p>MethodBeforeAdviceAdapter 、AfterReturningAdviceAdapter 、 ThrowsAdviceAdapter 继承AdvisorAdapter，会适配Advice</p></li><li><p>MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice</p></li><li><p>AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice</p></li><li><p>ThrowsAdviceInterceptor implements MethodInterceptor, AfterAdvice</p></li><li><p>ProxyFactoryBean   </p></li><li><p>AbstractAutoProxyCreator extends ProxyProcessorSupport extends ProxyConfig implements Ordered, BeanClassLoaderAware, AopInfrastructureBean</p></li><li><p>DefaultAopProxyFactory implements AopProxyFactory</p></li><li><p>JdkDynamicAopProxy implements AopProxy, InvocationHandler</p></li><li><p>ObjenesisCglibAopProxy</p></li><li><pre><code class="java">List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);//AdvisedSupport中     AdvisorChainFactory advisorChainFactory = new DefaultAdvisorChainFactory();this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);//通过这个类获取到MethodInterceptor实例返回的是封装的InterceptorAndDynamicMethodMatcher实例，存入ConcurrentHashMapAdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 引入增强</span><br><span class="line"></span><br><span class="line">Introduction可以在不改动目标类定义的情况下，为目标类增加新的属性和行为。**&#96;一个Java类，没有实现A接口，在不修改Java类的情况下，使其具备A接口的功能。&#96;**&lt;font color&#x3D;&#39;red&#39;&gt;只能应用于类级别的拦截&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">[AOP引入增强详解及AOP增强类](https:&#x2F;&#x2F;blog.csdn.net&#x2F;f641385712&#x2F;article&#x2F;details&#x2F;89303088)</span><br><span class="line"></span><br><span class="line">## 资源处理</span><br><span class="line"></span><br><span class="line">Java的标准java.net.URL类和各种URL前缀的标准处理程序并不足以满足所有对低级资源的访问。例如，没有标准化的URL实现可用于访问需要从类路径获取的资源，或相对于ServletContext的资源。Spring的Resource接口就是为了弥补不足。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public interface InputStreamSource &#123;</span><br><span class="line">InputStream getInputStream() throws IOException;</span><br><span class="line">&#125;</span><br><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line">    &#x2F;&#x2F;以下方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210122114124625-1612677954183.png" alt="image-20210122114124625"></p><h3 id="内置资源实现"><a href="#内置资源实现" class="headerlink" title="内置资源实现"></a>内置资源实现</h3><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210122114705114-1612677957074.png" alt="image-20210122114705114"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210122114724545-1612677958891.png" alt="image-20210122114724545"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210122114741609-1612677961146.png" alt="image-20210122114741609"></p><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext实现了ResourceLoader，通过ClassPathXmlApplicationContext获取的是ClassPathResource，通过FileSystemXmlApplicationContext获取的是FileSystemResource，对于WebApplicationContext，获取到的是ServletContextResource。</p><p>也可以指定获取的Resource对象</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125110027705-1612677962996.png" alt="image-20210125110027705"></p><h3 id="ResourceLoaderAware"><a href="#ResourceLoaderAware" class="headerlink" title="ResourceLoaderAware"></a>ResourceLoaderAware</h3><p>用于标识期望通过ResourceLoader接口提供的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="资源依赖"><a href="#资源依赖" class="headerlink" title="资源依赖"></a>资源依赖</h3><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125111409585-1612677965203.png" alt="image-20210125111409585"></p><h2 id="Bean验证"><a href="#Bean验证" class="headerlink" title="Bean验证"></a>Bean验证</h2><ul><li>支持Bean Validation 1.0 （JSR-303）</li><li>Bean Validation 1.1(JSR-349)</li><li>Spring Validation</li></ul><p>Spring应用程序可以选择全局启用Bean验证，并专门用于所有验证需求。应用程序还可以为每个DataBinder实例注册额外的Spring Validation实例，这对于插入验证逻辑而不使用注解的情况可能是有用的。</p><h3 id="Validator接口"><a href="#Validator接口" class="headerlink" title="Validator接口"></a>Validator接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"><span class="comment">//验证这个验证器是否支持所提供的类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">    <span class="comment">//验证给定的对象，并在验证出错误的情况下，将错误信息注册到给定的错误对象</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ValidationUtils.rejectIfEmpty(e,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;name empty&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h2><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125133527744-1612677968272.png" alt="image-20210125133527744"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpelExpressionParser</span><br><span class="line">SpelExpression</span><br></pre></td></tr></table></figure><h2 id="数据缓冲器和编解码器"><a href="#数据缓冲器和编解码器" class="headerlink" title="数据缓冲器和编解码器"></a>数据缓冲器和编解码器</h2><p>Spring数据缓冲器和编解码器用于处理网络传输过程中的数据解析。</p><h3 id="数据缓冲器"><a href="#数据缓冲器" class="headerlink" title="数据缓冲器"></a>数据缓冲器</h3><p>DataBuffer接口定义了一个字节缓冲区的抽象。引入的原因是Netty。Netty并不使用标准的java.nio.ByteBuffer，而是提供ByteBuf作为代替。Spring的DataBuffer是ByteBuf的一个简单的抽象，也可以在非Netty平台（Servlet3.1+）上使用。</p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125150404283-1612677970417.png" alt="image-20210125150404283"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125150426114-1612677973730.png" alt="image-20210125150426114"></p><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125150645445-1612677976389.png" alt="image-20210125150645445"></p><p><img src="/2021/02/07/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210125150653993-1612677977889.png" alt="image-20210125150653993"></p><p>springboot 自动装配（@EnableAutoConfiguration或@SpringBootApplication）</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控之自定义trace拦截</title>
      <link href="2021/02/07/%E7%9B%91%E6%8E%A7%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89trace%E6%8B%A6%E6%88%AA/"/>
      <url>2021/02/07/%E7%9B%91%E6%8E%A7%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89trace%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<p>想要跟踪请求，第一个想到的就是当请求来时生成一个traceId放在ThreadLocal里，然后打印时去取就行了。但在不改动原有输出语句的前提下自然需要日志框架的支持了，搜索的一番发现主流日志框架都提供了MDC功能。</p><p>MDC 介绍<br>MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。MDC 可以看成是一个与当前线程绑定的Map，可以往其中添加键值对。MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p><p>简而言之，MDC就是日志框架提供的一个InheritableThreadLocal，项目代码中可以将键值对放入其中，然后使用指定方式取出打印即可。</p><p>简单总结一下主要思路：</p><p>当请求来的时候，用Filter拦截，主要初始化请求的上下文，包括MDC，配置文件中打印MDC中的traceId和spanId。<br>微服务之间调用时，服务调用方需要传递当前的上线文，这个时候解析上下文，spanId自增。以下例子使用的是自定义映射上下文和MDC,只使用MDC就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTEXT_KEY = <span class="string">&quot;CONTEXT_KEY&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SPAN = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次请求唯一记录值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String traceId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一次请求的多次处理唯一标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String spanId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求ip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;ProjectContext&gt; LOCAL = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProjectContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProjectContext context = LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(context)) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> ProjectContext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nextSpan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(getContext())) &#123;</span><br><span class="line">            initContext();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(getContext().getSpanId())) &#123;</span><br><span class="line">            getContext().setSpanId(DEFAULT_SPAN);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的spanId</span></span><br><span class="line">        String span = getContext().getSpanId();</span><br><span class="line">        <span class="keyword">if</span> (span.endsWith(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            span = span.substring(<span class="number">0</span>, span.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到切割位置</span></span><br><span class="line">        <span class="keyword">int</span> p = span.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        String last = span.substring(p + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 最后需要自增的原数据</span></span><br><span class="line">        <span class="keyword">int</span> lastId = Integer.parseInt(last);</span><br><span class="line">        <span class="comment">// 完成自增并设置设置到spanId中</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            getContext().setSpanId(String.valueOf(lastId + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getContext().setSpanId(span.substring(<span class="number">0</span>, p) + (lastId + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 透传上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> contextString 被序列化的上下文字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fromString</span><span class="params">(String contextString)</span> </span>&#123;</span><br><span class="line">        ProjectContext context = GsonUtil.toBean(contextString, ProjectContext.class);</span><br><span class="line"></span><br><span class="line">        fromContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fromContext</span><span class="params">(ProjectContext context)</span> </span>&#123;</span><br><span class="line">        LOCAL.set(context);</span><br><span class="line">        nextSpan();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(ProjectContext context)</span> </span>&#123;</span><br><span class="line">        LOCAL.set(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initContext</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        initContext();</span><br><span class="line"></span><br><span class="line">        ProjectContext context = getContext();</span><br><span class="line"></span><br><span class="line">        context.setIp(ip);</span><br><span class="line"></span><br><span class="line">        setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProjectContext context = <span class="keyword">new</span> ProjectContext();</span><br><span class="line">        context.setTraceId(String.valueOf(genLogId()));</span><br><span class="line">        context.setSpanId(DEFAULT_SPAN);</span><br><span class="line"></span><br><span class="line">        setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">genLogId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(((System.currentTimeMillis() % <span class="number">86400000L</span>) + RANDOM.nextDouble()) * <span class="number">100000.0D</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GsonUtil.toJson(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;requestWrapperFilter&quot;, urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRACE_ID = <span class="string">&quot;trace&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPAN_ID = <span class="string">&quot;span&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化请求链路信息：唯一key，日志初始化，body包装防止获取日志打印时后续不能继续使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String contextString = ((HttpServletRequest) request).getHeader(ProjectContext.CONTEXT_KEY);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(contextString)) &#123;</span><br><span class="line">            ProjectContext.fromString(contextString);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无内容时，也自动初始化</span></span><br><span class="line">            ProjectContext.initContext();</span><br><span class="line">        &#125;</span><br><span class="line">        initLog();</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MDC.put(TRACE_ID, ProjectContext.getContext().getTraceId());</span><br><span class="line">        MDC.put(SPAN_ID, ProjectContext.getContext().getSpanId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProjectContext projectContext = ProjectContext.getContext();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(projectContext)) &#123;</span><br><span class="line">                requestTemplate.header(CONTEXT_KEY, projectContext.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过改变默认logging.pattern.level=%5p，增加需要打印的字段，例： logger.pattern.level=%5p [${traceId:-}],输出的日志中会输出traceId字段的值。</p>]]></content>
      
      
      <categories>
          
          <category> APM </category>
          
          <category> trace </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trace </tag>
            
            <tag> APM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控之Skywalking简单使用</title>
      <link href="2021/02/07/%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/07/%E7%9B%91%E6%8E%A7%E4%B9%8BSkywalking%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>分布式应用，会存在各种问题。解决这些难题，除了要应用自己做一些监控埋点外，还可以有一些外围的系统进行主动探测和主动发现。SkyWalking 是观察性分析平台和应用性能管理系统。提供分布式追踪、服务格遥测分析、度量聚合和可视化一体化解决方案。</p><p>大概原理：针对各种不同客户端实现不同的指标采集，统一通过grpc/http发送到apm服务端，然后经过分析引擎后存储到es/h2/mysql等存储系统，最后由前端通过查询引擎进行展现。 </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">docker network create skywalking-net</span><br><span class="line"><span class="meta">#</span><span class="bash">OAP</span></span><br><span class="line">docker pull apache/skywalking-oap-server:8.3.0-es7</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># skywalking 单机</span></span></span><br><span class="line">docker run --name oap --network skywalking-net --restart always -p 11800:11800 -p 12800:12800 -d -e SW_STORAGE=elasticsearch7 -e SW_STORAGE_ES_CLUSTER_NODES=elasticsearch:9200 apache/skywalking-oap-server:latest-es7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># skywalking kubernetes</span></span></span><br><span class="line">https://github.com/apache/skywalking-kubernetes#deploy-skywalking-backend-to-kubernetes-cluster</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 集群版本</span></span></span><br><span class="line">https://github.com/SkyAPM/document-cn-translation-of-skywalking/blob/master/docs/zh/8.0.0/setup/backend/backend-cluster.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># skywalking操作文档</span></span></span><br><span class="line">https://github.com/SkyAPM/document-cn-translation-of-skywalking/blob/master/docs/zh/8.0.0/README.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># skywalking-ui</span></span></span><br><span class="line">docker run --name oap-ui -p8080:8080 --network skywalking-net --restart always -d -e SW_OAP_ADDRESS=oap:12800 apache/skywalking-ui</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 使用外置elasticsearch.yml，容器化elasticsearch时把它挂载进来</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##先把elasticsearch容器中的config/elasticsearch.yml拷贝可编辑的目录</span></span></span><br><span class="line">docker cp elasticsearch:/usr/share/elasticsearch/config/elasticsearch.yml /mydata/elasticsearch/elasticsearch.yml</span><br><span class="line">vim /mydata/elasticsearch/elasticsearch.yml</span><br><span class="line">docker run -p 9200:9200 -p 9300:9300 --name elasticsearch \</span><br><span class="line">  -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; \</span><br><span class="line">  -e &quot;discovery.type=single-node&quot; \</span><br><span class="line">  -e &quot;cluster.name=elasticsearch&quot; \</span><br><span class="line">  -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">  -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">  -v /mydata/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">  -d elasticsearch:7.9.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改内置/config/elasticsearch.yml文件</span></span></span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 表示当前elasticsearch单节点模式，非集群，不配置的话，本版本elasticsearch启动30秒后就挂掉了</span></span></span><br><span class="line">docker run --name elasticsearch  -p 9200:9200 -p 9300:9300 -d --network skywalking-net -e &quot;discovery.type=single-node&quot; elasticsearch:7.9.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#容器化镜像，注意--net skywalking-net代码看上面网络创建</span></span></span><br><span class="line">docker run -d --name kibana -e “I18N_LOCALE=zh-CN” --link=elasticsearch:elasticsearch --net skywalking-net -p 5601:5601 kibana:7.9.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># elasticsearch安装IK分词器</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入elasticsearch容器</span></span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#下载并安装ik分词器</span></span></span><br><span class="line">elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.9.1/elasticsearch-analysis-ik-7.9.1.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#退出容器</span></span></span><br><span class="line">exit</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#重启elasticsearch容器</span></span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><h2 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Environment variables</span></span><br><span class="line">SW_AGENT_COLLECTOR_BACKEND_SERVICES与skywalking.collector.backend_service含义相同。如SW_AGENT_COLLECTOR_BACKEND_SERVICES=localhost:11800</span><br><span class="line"></span><br><span class="line">SW_AGENT_NAME与skywalking.agent.service_name 含义相同。如SW_AGENT_NAME=order-service</span><br><span class="line"><span class="meta">#</span><span class="bash">VM options</span></span><br><span class="line">-javaagent:D:\资料\apache-skywalking-apm-es7-8.3.0\apache-skywalking-apm-bin-es7\agent\skywalking-agent.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Java Agent是插件化、可插拔的。Skywalking的插件分为三种：</p><ul><li>引导插件：在agent的 <code>bootstrap-plugins</code> 目录下</li><li>内置插件：在agent的 <code>plugins</code> 目录下</li><li>可选插件：在agent的 <code>optional-plugins</code> 目录下</li></ul><p>Java Agent只会启用 <code>plugins</code> 目录下的所有插件，<code>bootstrap-plugins</code> 目录以及 <code>optional-plugins</code> 目录下的插件不会启用。如需启用引导插件或可选插件，只需将JAR包移到 <code>plugins</code> 目录下，如需禁用某款插件，只需从 <code>plugins</code> 目录中移除即可。</p><h3 id="引导插件"><a href="#引导插件" class="headerlink" title="引导插件"></a>引导插件</h3><p>目前只有两款引导插件：</p><ul><li><code>apm-jdk-http-plugin</code> 用来是监测HttpURLConnection；</li><li><code>apm-jdk-threading-plugin</code> 用来监测Callable以及Runnable；</li></ul><p>有关引导插件的功能描述，可详见： <code>https://github.com/apache/skywalking/blob/v6.6.0/docs/en/setup/service-agent/java-agent/README.md#bootstrap-class-plugins</code> 。</p><h3 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h3><p>内置插件主要用来为业界主流的技术与框架提供支持。所支持的技术&amp;框架，详见 <code>https://github.com/apache/skywalking/blob/v6.6.0/docs/en/setup/service-agent/java-agent/Supported-list.md</code> 。</p><h3 id="可选插件"><a href="#可选插件" class="headerlink" title="可选插件"></a>可选插件</h3><p>关于可选插件的功能描述，可详见 <code>https://github.com/apache/skywalking/blob/v6.6.0/docs/en/setup/service-agent/java-agent/README.md</code> 。</p><h3 id="插件扩展"><a href="#插件扩展" class="headerlink" title="插件扩展"></a>插件扩展</h3><p>Skywalking生态还有一些插件扩展，例如Oracle、Resin插件等。这部分插件主要是由于许可证不兼容/限制，Skywalking无法将这部分插件直接打包到Skywalking安装包内，于是托管在这个地址： <code>https://github.com/SkyAPM/java-plugin-extensions</code> ，使用方式：</p><ul><li>前往 <code>https://github.com/SkyAPM/java-plugin-extensions/releases</code> ，下载插件JAR包</li><li>将JAR包挪到 <code>plugins</code> 目录即可启用。</li></ul><h3 id="插件实例"><a href="#插件实例" class="headerlink" title="插件实例"></a>插件实例</h3><p>忽略某些url不被追踪</p><ol><li><p>将apm-trace-ignore-plugin-8.0.1.jar 从optional-plugins 移动到 plugins 目录中</p></li><li><p>配置忽略url</p><p>方法一： 在 agent/config 目录下创建 apm-trace-ignore-plugin.config文件</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trace.ignore_path&#x3D;$&#123;SW_AGENT_TRACE_IGNORE_PATH:需要忽略的url&#125;</span><br><span class="line">eg：trace.ignore_path&#x3D;$&#123;SW_AGENT_TRACE_IGNORE_PATH:&#x2F;xxx&#x2F;**&#125;</span><br></pre></td></tr></table></figure><p>​    方法二： 直接使用环境变量 -Dskywalking.trace.ignore_path=需要忽略的url路径</p><h2 id="全局日志追踪-traceId-的使用"><a href="#全局日志追踪-traceId-的使用" class="headerlink" title="全局日志追踪 traceId 的使用"></a>全局日志追踪 traceId 的使用</h2><ol><li><p>依赖日志相关的jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.skywalking<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apm-toolkit-logback-1.x<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改logback配置信息</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- ConsoleAppender：把日志输出到控制台 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.mdc.TraceIdMDCPatternLogbackLayout&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      %clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; [%X&#123;tid&#125;] %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;</span><br><span class="line">          ]]&gt;<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE-LOG-ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE-LOG-ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;appender-ref ref=&quot;FILE-LOG-ASYNC&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="额外记录请求参数"><a href="#额外记录请求参数" class="headerlink" title="额外记录请求参数"></a>额外记录请求参数</h2><p>如果某个方法SkyWalking没有追踪，但是想追踪并输出一些额外的tag信息等。用此方法可以记录请求参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.skywalking<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apm-toolkit-trace<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码方式"><a href="#代码方式" class="headerlink" title="代码方式"></a>代码方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trace(operationName = &quot;requestWrapperFilter&quot;)</span> <span class="comment">//增加一个深度</span></span><br><span class="line">ActiveSpan.tag(<span class="string">&quot;request&quot;</span>, requestStr);  <span class="comment">//增加标签即页面上展示参数</span></span><br><span class="line">ActiveSpan.tag(<span class="string">&quot;response&quot;</span>, customHttpServletResponseWrapper.getContent()); <span class="comment">//增加标签显示返回值</span></span><br></pre></td></tr></table></figure><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trace(operationName = &quot;添加自定义的方法&quot;)</span></span><br><span class="line"><span class="meta">@Tags(&#123;</span></span><br><span class="line"><span class="meta">        @Tag(key = &quot;从方法参数中获取值&quot;, value = &quot;arg[0]&quot;), //key为tag的名称，value为内容</span></span><br><span class="line"><span class="meta">        @Tag(key = &quot;从返回值中获取值&quot;, value = &quot;returnedObj.name&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">trace</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;如果此方法没有被SkyWalking收集，但是又需要被收集到，可以加上@Trace注解&quot;</span>);</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;创建的名字&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步线程追踪"><a href="#异步线程追踪" class="headerlink" title="异步线程追踪"></a>异步线程追踪</h2><p>自定义线程</p><ul><li>使用注解：@TraceCrossThread</li><li>使用类：SupplierWrapper/RunnableWrapper。如new Thread(RunnableWrapper.of(() -&gt; log.info(“子线程的信息”))).start();</li></ul><p>spring async异步线程</p><ul><li>不需要额外处理，已经支持透传。</li></ul><h2 id="自定义显示服务实例"><a href="#自定义显示服务实例" class="headerlink" title="自定义显示服务实例"></a>自定义显示服务实例</h2><p>默认服务实例的名字是 uuid@hostname，这个在某些时候不一定好区分，因为我们希望自定义一个 instanceName 名字,使用<br>-Dskywalking.agent.instance_name=自定义的服务名</p><h2 id="和其它agent使用时候的处理"><a href="#和其它agent使用时候的处理" class="headerlink" title="和其它agent使用时候的处理"></a>和其它agent使用时候的处理</h2><p>当我们和其它的agent一起使用时，比如Arthas，其它的agent可能工作的不是那么好。添加参数: -Dskywalking.agent.is_cache_enhanced_class=true -Dskywalking.agent.class_cache_mode=MEMORY</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://blog.csdn.net/u010928589/article/details/106608864/">agent启动服务分析以及性能影响</a><br><a href="https://www.imooc.com/article/306199"><strong>手把手教你编写Skywalking插件</strong></a><br><a href="https://blog.csdn.net/snail_bi/article/details/102525736">skywalking-ui详解</a><br><a href="http://cmsblogs.com/?p=3549">源码解析系列文章</a><br><a href="https://zhuanlan.zhihu.com/p/125689524">SkyWalking-性能剖析</a><br><a href="https://blog.51cto.com/zero01/2463976">SkyWalking - 实现微服务监控告警</a><br><a href="https://www.jianshu.com/p/929af3d64f7f">全链路追踪技术选型：pinpoint vs skywalking</a><br><a href="https://www.jianshu.com/p/45cb1cd5a1be">APM分布式性能管理监控工具调研</a></p>]]></content>
      
      
      <categories>
          
          <category> APM </category>
          
          <category> trace </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trace </tag>
            
            <tag> APM </tag>
            
            <tag> SkyWalking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven详解</title>
      <link href="2021/02/05/maven%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/02/05/maven%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="scope属性"><a href="#scope属性" class="headerlink" title="scope属性"></a>scope属性</h2><ul><li><strong>compile</strong> <strong>（编译）</strong></li></ul><p>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath中可用，同时它们也会被打包。</p><ul><li><strong>provided</strong> <strong>（已提供）</strong></li></ul><p>provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。</p><ul><li><strong>runtime</strong> <strong>（运行时）</strong></li></ul><p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC<br>驱动实现。</p><ul><li><strong>test</strong> <strong>（测试）</strong></li></ul><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</p><ul><li><strong>system</strong> <strong>（系统）</strong></li></ul><p>system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构建应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个<strong>systemPath</strong>元素。注意该范围是不推荐使用的（建议尽量去从公共或定制的 Maven 仓库中引用依赖）。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;sun.jdk&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;tools&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.5.0&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;system&lt;&#x2F;scope&gt;</span><br><span class="line">      &lt;systemPath&gt;$&#123;java.home&#125;&#x2F;..&#x2F;lib&#x2F;tools.jar&lt;&#x2F;systemPath&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>import(导入)</strong></li></ul><p>import仅支持在<code>&lt;**dependencyManagement**&gt;</code>中的类型依赖项上。它表示要在指定的POM <code>&lt;**dependencyManagement**&gt;</code>部分中用有效的依赖关系列表替换的依赖关系。该scope类型的依赖项``实际上不会参与限制依赖项的可传递性。</p><h2 id="scope的依赖传递"><a href="#scope的依赖传递" class="headerlink" title="scope的依赖传递"></a>scope的依赖传递</h2><ul><li>当B对C的依赖的scope是<strong>test</strong>或者<strong>provided</strong>，则A不依赖C。</li><li>当B对C的依赖是scope是<strong>runtime</strong>或者<strong>compile</strong>，则A依赖C。且传递依赖的scope的<strong>规则：</strong>如果A对B的依赖是compile，那么A对C的依赖和B对C的依赖相同，否则和A对B的依赖保持一致。</li></ul><h2 id="optional属性"><a href="#optional属性" class="headerlink" title="optional属性"></a><strong>optional</strong>属性</h2><p><optional>true</optional>的作用是让依赖只被当前项目使用，而不会在模块间进行传递依赖。如b依赖c，而a依赖b。在b中设置了依赖c的属性<optional>true</optional>，此时a想要用c的类，需要a自己去依赖c，而且使用b中的类且类依赖c中的类，此时必须依赖c，否则报错。</p><h2 id="distributionManagement配置"><a href="#distributionManagement配置" class="headerlink" title="distributionManagement配置"></a>distributionManagement配置</h2><p>pom文件中，<distributionManagement>  标签的作用是指定mvn deploy的地址。</distributionManagement></p><p>maven会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情况下，直接编译打包时，maven会自动从镜像服务器上下载最新的快照版本。如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//最佳实践，本地上传到镜像服务器，生产上上传到正式版本库</span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.release.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">project.release.version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">project.release.version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>release<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">project.release.version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">project.release.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--定义snapshots库和releases库的nexus地址--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>  </span><br><span class="line">            http://172.17.103.59:8081/nexus/content/repositories/releases/  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>  </span><br><span class="line">            http://172.17.103.59:8081/nexus/content/repositories/snapshots/  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><p>需要在settings.xml文件中配置地址的用户名和密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="repositories配置"><a href="#repositories配置" class="headerlink" title="repositories配置"></a>repositories配置</h2><p>作用是指定jar的下载地址，即仓库地址。可以指定下载镜像版本和正式版本的仓库，在settings.xml中可以设置生效的配置，配置仓库的镜像地址，提高下载速度。如下<mirrorOf>*</mirrorOf>映射了所有的仓库的地址。先从镜像仓库下载，再到配置仓库下载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在settings.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Send all requests to the public group --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://nexus.xxx.com/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插件plugin"><a href="#插件plugin" class="headerlink" title="插件plugin"></a>插件plugin</h2><h3 id="dockerfile-maven-plugin"><a href="#dockerfile-maven-plugin" class="headerlink" title="dockerfile-maven-plugin"></a>dockerfile-maven-plugin</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>ip地址(push镜像的地址):5000/镜像name<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><strong>根目录下载创建Dockfile文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">MAINTAINER 作者信息</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;&#x2F;app.jar&quot;]</span><br><span class="line"># Add the service itself</span><br><span class="line">ADD target&#x2F;web-1.0-SNAPSHOT.jar &#x2F;app.jar</span><br></pre></td></tr></table></figure><p><strong>构建Docker镜像并发送到镜像仓库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package dockerfile:push</span><br></pre></td></tr></table></figure><h3 id="screw-maven-plugin"><a href="#screw-maven-plugin" class="headerlink" title="screw-maven-plugin"></a>screw-maven-plugin</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.smallbun.screw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>screw-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.smallbun.screw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>screw-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HikariCP --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql driver--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--username--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>magic_mirror<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--password--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>qAjTe#YHK8dev<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--driver--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">driverClassName</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">driverClassName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jdbc url--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcUrl</span>&gt;</span>jdbc:mysql://10.16.32.177:3306/magic_mirror_iot<span class="tag">&lt;/<span class="name">jdbcUrl</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生成文件类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileType</span>&gt;</span>WORD<span class="tag">&lt;/<span class="name">fileType</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打开文件输出目录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">openOutputDir</span>&gt;</span>false<span class="tag">&lt;/<span class="name">openOutputDir</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生成模板--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">produceType</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">produceType</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--文档名称 为空时:将采用[数据库名称-描述-版本号]作为文档名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileName</span>&gt;</span>sso<span class="tag">&lt;/<span class="name">fileName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>数据库文档生成<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>数据库文档<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>执行mvn命令生成数据库文档</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package screw:run</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos监控</title>
      <link href="2021/01/15/nacos%E7%9B%91%E6%8E%A7/"/>
      <url>2021/01/15/nacos%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>Nacos 0.8.0版本完善了监控系统，支持通过暴露metrics数据接入第三方监控系统监控Nacos运行状态，目前支持prometheus、elastic search和influxdb，下面结合prometheus和grafana如何监控Nacos，官网<a href="http://monitor.nacos.io/">grafana监控页面</a>。与elastic search和influxdb结合可自己查找相关资料</p><h2 id="搭建Nacos集群暴露metrics数据"><a href="#搭建Nacos集群暴露metrics数据" class="headerlink" title="搭建Nacos集群暴露metrics数据"></a>搭建Nacos集群暴露metrics数据</h2><p>按照<a href="https://nacos.io/zh-cn/docs/deployment.html">部署文档</a>搭建好Nacos集群</p><p>配置application.properties文件，暴露metrics数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include&#x3D;*</span><br></pre></td></tr></table></figure><p>访问{ip}:8848/nacos/actuator/prometheus，看是否能访问到metrics数据</p><h2 id="搭建prometheus采集Nacos-metrics数据"><a href="#搭建prometheus采集Nacos-metrics数据" class="headerlink" title="搭建prometheus采集Nacos metrics数据"></a>搭建prometheus采集Nacos metrics数据</h2><p>下载你想安装的prometheus版本，地址为<a href="https://prometheus.io/download/">download prometheus</a></p><h3 id="linux-amp-mac"><a href="#linux-amp-mac" class="headerlink" title="linux &amp; mac"></a>linux &amp; mac</h3><p>解压prometheus压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xvfz prometheus-*.tar.gz</span><br><span class="line">cd prometheus-*</span><br></pre></td></tr></table></figure><p>修改配置文件prometheus.yml采集Nacos metrics数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metrics_path: &#39;&#x2F;nacos&#x2F;actuator&#x2F;prometheus&#39;</span><br><span class="line">static_configs:</span><br><span class="line">  - targets: [&#39;&#123;ip1&#125;:8848&#39;,&#39;&#123;ip2&#125;:8848&#39;,&#39;&#123;ip3&#125;:8848&#39;]</span><br></pre></td></tr></table></figure><p>启动prometheus服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;prometheus --config.file&#x3D;&quot;prometheus.yml&quot;</span><br></pre></td></tr></table></figure><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>下载对应的windows版本并解压</p><p>修改配置文件prometheus.yml采集Nacos metrics数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metrics_path: &#39;&#x2F;nacos&#x2F;actuator&#x2F;prometheus&#39;</span><br><span class="line">static_configs:</span><br><span class="line">  - targets: [&#39;&#123;ip1&#125;:8848&#39;,&#39;&#123;ip2&#125;:8848&#39;,&#39;&#123;ip3&#125;:8848&#39;]</span><br></pre></td></tr></table></figure><p>启动prometheus服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus.exe --config.file&#x3D;prometheus.yml</span><br></pre></td></tr></table></figure><p>通过访问http://{ip}:9090/graph可以看到prometheus的采集数据，在搜索栏搜索nacos_monitor可以搜索到Nacos数据说明采集数据成功 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1LThVCQvoK1RjSZFwXXciCFXa-2832-1576.png" alt="IMAGE"></p><h2 id="搭建grafana图形化展示metrics数据"><a href="#搭建grafana图形化展示metrics数据" class="headerlink" title="搭建grafana图形化展示metrics数据"></a>搭建grafana图形化展示metrics数据</h2><p>和prometheus在同一台机器上安装grafana，使用 yum 安装grafana</p><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install grafana</span><br><span class="line">brew services start grafana</span><br></pre></td></tr></table></figure><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;grafana-releases&#x2F;release&#x2F;grafana-5.2.4-1.x86_64.rpm</span><br><span class="line">sudo service grafana-server start</span><br></pre></td></tr></table></figure><h3 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h3><p>参考文档：<a href="http://docs.grafana.org/installation/windows/">http://docs.grafana.org/installation/windows/</a></p><p>访问grafana: http://{ip}:3000</p><p>配置prometheus数据源 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1bTafCOLaK1RjSZFxXXamPFXa-2832-1568.png" alt="IMAGE"></p><p>导入Nacos grafana监控<a href="https://github.com/nacos-group/nacos-template/blob/master/nacos-grafana.json">模版</a> <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1JadVCPDpK1RjSZFrXXa78VXa-2742-1338.png" alt="IMAGE"></p><p>Nacos监控分为三个模块:</p><ul><li>nacos monitor展示核心监控项 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1PMpUCQvoK1RjSZFDXXXY3pXa-2832-1584.png" alt="IMAGE"></li><li>nacos detail展示指标的变化曲线 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1ZBF4CNjaK1RjSZFAXXbdLFXa-2742-1480.png" alt="IMAGE"></li><li>nacos alert为告警项 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1ALlUCFzqK1RjSZFCXXbbxVXa-2742-1476.png" alt="IMAGE"></li></ul><h2 id="配置grafana告警"><a href="#配置grafana告警" class="headerlink" title="配置grafana告警"></a>配置grafana告警</h2><p>当Nacos运行出现问题时，需要grafana告警通知相关负责人。grafana支持多种告警方式，常用的有邮件，钉钉和webhook方式</p><h3 id="钉钉告警"><a href="#钉钉告警" class="headerlink" title="钉钉告警"></a>钉钉告警</h3><p>钉钉可以通过配置钉钉机器人 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1eJ0RCSzqK1RjSZFjXXblCFXa-2742-1482.png" alt="IMAGE"></p><p>配置钉钉通知url <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1ERtQCSzqK1RjSZFjXXblCFXa-2832-1578.png" alt="IMAGE"></p><p>测试告警项 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1KvXPCHPpK1RjSZFFXXa5PpXa-996-504.png" alt="IMAGE"></p><h3 id="邮件告警"><a href="#邮件告警" class="headerlink" title="邮件告警"></a>邮件告警</h3><p>修改defaults.ini配置文件，增加邮件告警</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#################################### SMTP &#x2F; Emailing ##########################</span><br><span class="line">[smtp]</span><br><span class="line">enabled &#x3D; true</span><br><span class="line">host &#x3D; smtp.126.com:25</span><br><span class="line">user &#x3D; xxxxxx</span><br><span class="line">password &#x3D; xxxxx</span><br><span class="line">;cert_file &#x3D;</span><br><span class="line">;key_file &#x3D;</span><br><span class="line">skip_verify &#x3D; true</span><br><span class="line">from_address &#x3D; xxxxxx@126.com</span><br><span class="line"></span><br><span class="line">[emails]</span><br><span class="line">;welcome_email_on_sign_up &#x3D; false</span><br></pre></td></tr></table></figure><p>配置通知邮箱 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB12qyhCNnaK1RjSZFtXXbC2VXa-2832-1576.png" alt="IMAGE"></p><h2 id="Nacos-metrics含义"><a href="#Nacos-metrics含义" class="headerlink" title="Nacos metrics含义"></a>Nacos metrics含义</h2><h3 id="jvm-metrics"><a href="#jvm-metrics" class="headerlink" title="jvm metrics"></a>jvm metrics</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>system_cpu_usage</td><td>CPU使用率</td></tr><tr><td>system_load_average_1m</td><td>load</td></tr><tr><td>jvm_memory_used_bytes</td><td>内存使用字节，包含各种内存区</td></tr><tr><td>jvm_memory_max_bytes</td><td>内存最大字节，包含各种内存区</td></tr><tr><td>jvm_gc_pause_seconds_count</td><td>gc次数，包含各种gc</td></tr><tr><td>jvm_gc_pause_seconds_sum</td><td>gc耗时，包含各种gc</td></tr><tr><td>jvm_threads_daemon</td><td>线程数</td></tr></tbody></table><h3 id="Nacos-监控指标"><a href="#Nacos-监控指标" class="headerlink" title="Nacos 监控指标"></a>Nacos 监控指标</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>http_server_requests_seconds_count</td><td>http请求次数，包括多种(url,方法,code)</td></tr><tr><td>http_server_requests_seconds_sum</td><td>http请求总耗时，包括多种(url,方法,code)</td></tr><tr><td>nacos_timer_seconds_sum</td><td>Nacos config水平通知耗时</td></tr><tr><td>nacos_timer_seconds_count</td><td>Nacos config水平通知次数</td></tr><tr><td>nacos_monitor{name=’longPolling’}</td><td>Nacos config长连接数</td></tr><tr><td>nacos_monitor{name=’configCount’}</td><td>Nacos config配置个数</td></tr><tr><td>nacos_monitor{name=’dumpTask’}</td><td>Nacos config配置落盘任务堆积数</td></tr><tr><td>nacos_monitor{name=’notifyTask’}</td><td>Nacos config配置水平通知任务堆积数</td></tr><tr><td>nacos_monitor{name=’getConfig’}</td><td>Nacos config读配置统计数</td></tr><tr><td>nacos_monitor{name=’publish’}</td><td>Nacos config写配置统计数</td></tr><tr><td>nacos_monitor{name=’ipCount’}</td><td>Nacos naming ip个数</td></tr><tr><td>nacos_monitor{name=’domCount’}</td><td>Nacos naming域名个数</td></tr><tr><td>nacos_monitor{name=’failedPush’}</td><td>Nacos naming推送失败数</td></tr><tr><td>nacos_monitor{name=’avgPushCost’}</td><td>Nacos naming平均推送耗时</td></tr><tr><td>nacos_monitor{name=’leaderStatus’}</td><td>Nacos naming角色状态</td></tr><tr><td>nacos_monitor{name=’maxPushCost’}</td><td>Nacos naming最大推送耗时</td></tr><tr><td>nacos_monitor{name=’mysqlhealthCheck’}</td><td>Nacos naming mysql健康检查次数</td></tr><tr><td>nacos_monitor{name=’httpHealthCheck’}</td><td>Nacos naming http健康检查次数</td></tr><tr><td>nacos_monitor{name=’tcpHealthCheck’}</td><td>Nacos naming tcp健康检查次数</td></tr></tbody></table><h3 id="nacos-异常指标"><a href="#nacos-异常指标" class="headerlink" title="nacos 异常指标"></a>nacos 异常指标</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>nacos_exception_total{name=’db’}</td><td>数据库异常</td></tr><tr><td>nacos_exception_total{name=’configNotify’}</td><td>Nacos config水平通知失败</td></tr><tr><td>nacos_exception_total{name=’unhealth’}</td><td>Nacos config server之间健康检查异常</td></tr><tr><td>nacos_exception_total{name=’disk’}</td><td>Nacos naming写磁盘异常</td></tr><tr><td>nacos_exception_total{name=’leaderSendBeatFailed’}</td><td>Nacos naming leader发送心跳异常</td></tr><tr><td>nacos_exception_total{name=’illegalArgument’}</td><td>请求参数不合法</td></tr><tr><td>nacos_exception_total{name=’nacos’}</td><td>Nacos请求响应内部错误异常（读写失败，没权限，参数错误）</td></tr></tbody></table><h3 id="client-metrics"><a href="#client-metrics" class="headerlink" title="client metrics"></a>client metrics</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>nacos_monitor{name=’subServiceCount’}</td><td>订阅的服务数</td></tr><tr><td>nacos_monitor{name=’pubServiceCount’}</td><td>发布的服务数</td></tr><tr><td>nacos_monitor{name=’configListenSize’}</td><td>监听的配置数</td></tr><tr><td>nacos_client_request_seconds_count</td><td>请求的次数，包括多种(url,方法,code)</td></tr><tr><td>nacos_client_request_seconds_sum</td><td>请求的总耗时，包括多种(url,方法,code)</td></tr></tbody></table><h2 id="Nacos-Sync监控"><a href="#Nacos-Sync监控" class="headerlink" title="Nacos-Sync监控"></a>Nacos-Sync监控</h2><p>随着Nacos 0.9版本发布，Nacos-Sync 0.3版本支持了metrics监控，能通过metrics数据观察Nacos-Sync服务的运行状态，提升了Nacos-Sync的在生产环境的监控能力。 整体的监控体系的搭建参考<a href="https://nacos.io/zh-cn/docs/monitor-guide.html">Nacos监控手册</a></p><h2 id="grafana监控Nacos-Sync"><a href="#grafana监控Nacos-Sync" class="headerlink" title="grafana监控Nacos-Sync"></a>grafana监控Nacos-Sync</h2><p>和Nacos监控一样，Nacos-Sync也提供了监控模版，导入监控<a href="https://github.com/nacos-group/nacos-template/blob/master/nacos-sync-grafana">模版</a></p><p>Nacos-Sync监控同样也分为三个模块:</p><ul><li>nacos-sync monitor展示核心监控项 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1GeNWKmzqK1RjSZFHXXb3CpXa-2834-1588.png" alt="monitor"></li><li>nacos-sync detail和alert展示监控曲线和告警 <img src="/2021/01/15/nacos%E7%9B%91%E6%8E%A7/TB1kP8UKbvpK1RjSZPiXXbmwXXa-2834-1570.png" alt="detail"></li></ul><h2 id="Nacos-Sync-metrics含义"><a href="#Nacos-Sync-metrics含义" class="headerlink" title="Nacos-Sync metrics含义"></a>Nacos-Sync metrics含义</h2><p>Nacos-Sync的metrics分为jvm层和应用层</p><h3 id="jvm-metrics-1"><a href="#jvm-metrics-1" class="headerlink" title="jvm metrics"></a>jvm metrics</h3><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>system_cpu_usage</td><td>CPU使用率</td></tr><tr><td>system_load_average_1m</td><td>load</td></tr><tr><td>jvm_memory_used_bytes</td><td>内存使用字节，包含各种内存区</td></tr><tr><td>jvm_memory_max_bytes</td><td>内存最大字节，包含各种内存区</td></tr><tr><td>jvm_gc_pause_seconds_count</td><td>gc次数，包含各种gc</td></tr><tr><td>jvm_gc_pause_seconds_sum</td><td>gc耗时，包含各种gc</td></tr><tr><td>jvm_threads_daemon</td><td>线程数</td></tr></tbody></table><h2 id="应用层-metrics"><a href="#应用层-metrics" class="headerlink" title="应用层 metrics"></a>应用层 metrics</h2><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>nacosSync_task_size</td><td>同步任务数</td></tr><tr><td>nacosSync_cluster_size</td><td>集群数</td></tr><tr><td>nacosSync_add_task_rt</td><td>同步任务执行耗时</td></tr><tr><td>nacosSync_delete_task_rt</td><td>删除任务耗时</td></tr><tr><td>nacosSync_dispatcher_task</td><td>从数据库中分发任务</td></tr><tr><td>nacosSync_sync_task_error</td><td>所有同步执行时的异常</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo-admin简单使用</title>
      <link href="2021/01/15/dubbo-admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/01/15/dubbo-admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="dubbo-admin"><a href="#dubbo-admin" class="headerlink" title="dubbo-admin"></a>dubbo-admin</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>配置中心：用于配置dubbo元数据中心和注册中心的配置信息</li><li>元数据中心：用于存放接口调用相关的信息，如方法名</li><li>注册中心 ：Dubbo 2.6版本所有数据都存在注册中心上，Dubbo 2.7版本分成了注册中心，配置中心，和元数据中心。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>重点类ConfigCenter，配置中心自动配置类，创建GovernanceConfiguration对象，初始化nacos的configService</li><li>如果配置了配置中心，则加载配置中心的配置，读取注册中心和元数据中心的配置，生成url</li><li>dubbo-admin前后端分离，admin-ui前端使用vue,dubbo-admin-server后端使用spring-boot</li><li>订阅（dubbo-admin，nacos订阅）更改map缓存的数据（服务提供者、消费者）</li></ol><h3 id="GROUP默认值"><a href="#GROUP默认值" class="headerlink" title="GROUP默认值"></a>GROUP默认值</h3><p>dubbo-admin这边默认group都是dubbo</p><h3 id="application-properties配置项说明"><a href="#application-properties配置项说明" class="headerlink" title="application.properties配置项说明"></a>application.properties配置项说明</h3><ul><li><p>admin.config-center</p><ul><li><p>推荐使用，配置中心地址，比如<code>admin.config-center=&quot;zookeeper://127.0.0.1:2181&quot;</code></p></li><li><p>需要在配置中心中，配置注册中心和元数据中心地址配置格式如下：</p></li><li><p>zookeeper</p><ul><li><p>path: <code>/dubbo/config/dubbo/dubbo.properties</code></p></li><li><p>content:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="meta">dubbo.metadata-report.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>admin.registry.address</p><ul><li>不推荐使用，老版本的配置中心地址，比如：<code>admin.registry.address=&quot;zookeeper://127.0.0.1:2181&quot;</code></li><li>如使用该配置，Dubbo Admin会将其作为注册中心和配置中心使用，元数据中心将无法使用，会影响服务测试等功能。</li></ul></li></ul><h2 id="dubbo-monitor-simple"><a href="#dubbo-monitor-simple" class="headerlink" title="dubbo-monitor-simple"></a>dubbo-monitor-simple</h2><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li>启动<code>com.alibaba.dubbo.monitor.simple.MonitorStarter#main</code></li><li>需要进行监控的服务，在xml中配置<code>&lt;dubbo:monitor protocol=&quot;registry&quot;/&gt;</code></li><li>打开监控页面<code>http://localhost:8080</code>可以看到服务调用相关的统计</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="dubbo-monitor-simple-1"><a href="#dubbo-monitor-simple-1" class="headerlink" title="dubbo-monitor-simple"></a>dubbo-monitor-simple</h5><ul><li>dubbo-monitor-simple启动的时候，发布服务:<code>com.alibaba.dubbo.monitor.MonitorService</code>(实现类：<code>com.alibaba.dubbo.monitor.simple.SimpleMonitorService</code>)，只实现了<code>collect</code>方法，将RPC调用过来的URL存到<code>queue</code>里面</li><li><code>com.alibaba.dubbo.monitor.simple.SimpleMonitorService</code>启动了两个线程，分别执行<code>write</code>和<code>draw</code>方法，<code>write</code>从<code>queue</code>里面取出URL进行统计分析，结果写文件，<code>draw</code>方法把这些结果画成折线图，存本地图片文件</li><li><code>com.alibaba.dubbo.monitor.simple.pages.ChartsPageHandler</code>和<code>com.alibaba.dubbo.monitor.simple.pages.StatisticsPageHandler</code>负责在页面上渲染展示这些数据</li></ul><h5 id="Dubbo应用"><a href="#Dubbo应用" class="headerlink" title="Dubbo应用"></a>Dubbo应用</h5><ul><li>Dubbo服务在配置了<code>&lt;dubbo:monitor protocol=&quot;registry&quot;/&gt;</code>标签后，调用经过<code>com.alibaba.dubbo.monitor.support.MonitorFilter</code>时，会进行结果收集操作。</li><li>最终在调用到<code>com.alibaba.dubbo.monitor.dubbo.DubboMonitor#collect</code>，该方法将调用过程中的统计信息存放在<code>statisticsMap</code>中。并且，有另一个线程定期(默认为60秒)调用dubbo-monitor-simple暴露的com.alibaba.dubbo.monitor.MonitorService服务，将这些信息发送给monitor。</li></ul><p>Dubbo-montitor-simple实现的过程借助了dubbo服务调用：Monitor端暴露服务，Dubbo应用通过配置去消费这些服务，消费的过程就是自身服务数据上报的过程。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo简单使用</title>
      <link href="2021/01/15/dubbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/01/15/dubbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><ul><li>标签路由TagRouter：以Provider应用为粒度配置路由规则。</li><li>条件路由ConditionRouter：支持以服务或Consumer应用为粒度配置路由规则。</li><li>脚本路由ScriptRouter：</li></ul><h3 id="标签路由"><a href="#标签路由" class="headerlink" title="标签路由"></a>标签路由</h3><p>标签路由通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。</p><p>标签主要是指对Provider端应用实例的分组，目前有两种方式可以完成实例分组，分别是动态规则打标和静态规则打标，其中动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。</p><p>请求标签的作用域为每一次 invocation，使用 attachment 来传递请求标签，注意保存在 attachment 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，我们只需要在起始调用时，通过一行代码的设置，达到标签的持续传递。</p><h5 id="降级约定"><a href="#降级约定" class="headerlink" title="降级约定"></a>降级约定</h5><blockquote><p>consumer携带request.tag=tag1 时优先选择 标记了tag=tag1 的 provider。若集群中不存在与请求标记对应的服务，默认将降级请求 tag为空的provider；如果要改变这种默认行为，即找不到匹配tag1的provider返回异常，需设置request.tag.force=true。</p></blockquote><blockquote><p>comsumer侧request.tag未设置时，只会匹配tag为空的provider。即使集群中存在可用的服务，若tag不匹配也就无法调用，这与约定1不同，携带标签的请求可以降级访问到无标签的服务，但不携带标签/携带其他种类标签的请求永远无法访问到其他标签的服务。</p></blockquote><h5 id="标签路由的坑"><a href="#标签路由的坑" class="headerlink" title="标签路由的坑"></a>标签路由的坑</h5><p>dubbo的consumer侧的Filter对象ConsumerContextFilter每次请求后都会清空Attachments，导致再次发起请求就无法找到tag，所以需要在整个生命周期内保存tag。一般通过线程的ThreadLocal进行实现。</p><h5 id="标签路由的实现"><a href="#标签路由的实现" class="headerlink" title="标签路由的实现"></a>标签路由的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 实现逻辑为：</span></span><br><span class="line"><span class="comment"> * 1. 对于 Consumer 方，在调用 Provider 时，&#123;<span class="doctag">@link</span> DubboConsumerRouterTagClusterInterceptor&#125; 会将 &#123;<span class="doctag">@link</span> DubboRouterTagContextHolder&#125; 中的 Tag 通过 Dubbo 隐式传参。</span></span><br><span class="line"><span class="comment"> *      同时，Dubbo 自带 &#123;<span class="doctag">@link</span> TagRouter&#125;，会根据该参数，会选择符合该 Tag 的 Provider。</span></span><br><span class="line"><span class="comment"> * 2. 对于 Provider 方，在通过 Dubbo 隐式传参获得到 Tag 时，会设置到 &#123;<span class="doctag">@link</span> DubboRouterTagContextHolder&#125; 中。</span></span><br><span class="line"><span class="comment"> *      这样，在 Provider 作为 Consumer 角色时，调用其它 Provider 时，可以继续实现标签路由的功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Activate(group = &#123;CommonConstants.PROVIDER, CommonConstants.CONSUMER&#125;, order = -1000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProviderRouterTagFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="comment">// 从 Dubbo 隐式传参获得 Dubbo Tag</span></span><br><span class="line">        String dubboTag = invocation.getAttachment(CommonConstants.TAG_KEY);</span><br><span class="line">        <span class="keyword">boolean</span> hasDubboTag = StringUtils.hasText(dubboTag);</span><br><span class="line">        <span class="keyword">if</span> (hasDubboTag) &#123;</span><br><span class="line">            invocation.setAttachment(CommonConstants.TAG_KEY, dubboTag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理</span></span><br><span class="line">            <span class="keyword">if</span> (hasDubboTag) &#123;</span><br><span class="line">                DubboRouterTagContextHolder.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件路由"><a href="#条件路由" class="headerlink" title="条件路由"></a>条件路由</h3><p>[服务消费者匹配条件] =&gt; [服务提供者匹配条件]  如 host = 10.20.153.10 =&gt; host = 10.20.153.11</p><h5 id="向注册中心写入路由规则：-通常由监控中心或治理中心的页面完成"><a href="#向注册中心写入路由规则：-通常由监控中心或治理中心的页面完成" class="headerlink" title="向注册中心写入路由规则：(通常由监控中心或治理中心的页面完成)"></a>向注册中心写入路由规则：(通常由监控中心或治理中心的页面完成)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">&quot;condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=&quot;</span> + URL.encode(<span class="string">&quot;http://10.20.160.198/wiki/display/dubbo/host = 10.20.153.10 =&gt; host = 10.20.153.11&quot;</span>) + <span class="string">&quot;));</span></span><br></pre></td></tr></table></figure><ul><li>condition:// 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填。</li><li>0.0.0.0 表示对所有IP地址生效，如果只想对某个IP的生效，请填入具体IP，必填。</li><li>com.foo.BarService 表示只对指定服务生效，必填。</li><li>category=routers 表示该数据为动态配置类型，必填。</li><li>dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。</li><li>enabled=true 覆盖规则是否生效，可不填，缺省生效。</li><li>force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为flase。</li><li>runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。 如果用了参数路由，必须设为true，需要注意设置会影响调用的性能，可不填，缺省为flase。</li><li>priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为0。</li><li>rule=URL.encode(“host = 10.20.153.10 =&gt; host = 10.20.153.11”) 表示路由规则的内容，必填。</li></ul><h4 id="条件路由规则"><a href="#条件路由规则" class="headerlink" title="条件路由规则"></a>条件路由规则</h4><p>基于条件表达式的路由规则，如：<code>host = 10.20.153.10 =&gt; host = 10.20.153.11</code></p><p>规则：</p><ul><li>“=&gt;”之前的为消费者匹配条件，所有参数和消费者的URL进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。</li><li>“=&gt;”之后为提供者地址列表的过滤条件，所有参数和提供者的URL进行对比，消费者最终只拿到过滤后的地址列表。</li><li>如果匹配条件为空，表示对所有消费方应用，如：=&gt; host != 10.20.153.11</li><li>如果过滤条件为空，表示禁止访问，如：host = 10.20.153.10 =&gt;</li></ul><p>表达式：</p><ul><li>参数支持：<ul><li>服务调用信息，如：method, argument 等 (暂不支持参数路由)</li><li>URL本身的字段，如：protocol, host, port 等</li><li>以及URL上的所有参数，如：application, organization 等</li></ul></li><li>条件支持：<ul><li>等号 <code>=</code> 表示”匹配”，如：host = 10.20.153.10</li><li>不等号 <code>!=</code> 表示”不匹配”，如：host != 10.20.153.10</li></ul></li><li>值支持：<ul><li>以逗号 <code>,</code> 分隔多个值，如：host != 10.20.153.10,10.20.153.11</li><li>以星号 <code>*</code> 结尾，表示通配，如：host != 10.20.*</li><li>以美元符 <code>$</code> 开头，表示引用消费者参数，如：host = $host</li></ul></li></ul><p>示例：</p><ol><li><p>排除预发布机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; host !&#x3D; 172.22.3.91</span><br></pre></td></tr></table></figure></li><li><p>白名单： 注意：一个服务只能有一条白名单规则，否则两条规则交叉，就都被筛选掉了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host !&#x3D; 10.20.153.10,10.20.153.11 &#x3D;&gt;</span><br></pre></td></tr></table></figure></li><li><p>黑名单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host &#x3D; 10.20.153.10,10.20.153.11 &#x3D;&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务寄宿在应用上，只暴露一部分的机器，防止整个集群挂掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; host &#x3D; 172.22.3.1*,172.22.3.2*</span><br></pre></td></tr></table></figure></li><li><p>为重要应用提供额外的机器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application !&#x3D; kylin &#x3D;&gt; host !&#x3D; 172.22.3.95,172.22.3.96</span><br></pre></td></tr></table></figure></li><li><p>读写分离：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method &#x3D; find*,list*,get*,is* &#x3D;&gt; host &#x3D; 172.22.3.94,172.22.3.95,172.22.3.96</span><br><span class="line">method !&#x3D; find*,list*,get*,is* &#x3D;&gt; host &#x3D; 172.22.3.97,172.22.3.98</span><br></pre></td></tr></table></figure></li><li><p>前后台分离：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application &#x3D; bops &#x3D;&gt; host &#x3D; 172.22.3.91,172.22.3.92,172.22.3.93</span><br><span class="line">application !&#x3D; bops &#x3D;&gt; host &#x3D; 172.22.3.94,172.22.3.95,172.22.3.96</span><br></pre></td></tr></table></figure></li><li><p>隔离不同机房网段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host !&#x3D; 172.22.3.* &#x3D;&gt; host !&#x3D; 172.22.3.*</span><br></pre></td></tr></table></figure></li><li><p>提供者与消费者部署在同集群内，本机只访问本机的服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; host &#x3D; $host</span><br></pre></td></tr></table></figure></li></ol><h5 id="admin上配置条件路由"><a href="#admin上配置条件路由" class="headerlink" title="admin上配置条件路由"></a>admin上配置条件路由</h5><h3 id="脚本路由"><a href="#脚本路由" class="headerlink" title="脚本路由"></a>脚本路由</h3><p>支持JDK脚本引擎的所有脚本，比如：javascript, jruby, groovy 等，通过 type=javascript 参数设置脚本类型，缺省为javascript。</p><p>脚本没有沙箱约束，可执行任意代码，存在后门风险。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(&quot;script:&#x2F;&#x2F;0.0.0.0&#x2F;com.foo.BarService?category&#x3D;routers&amp;dynamic&#x3D;false&amp;rule&#x3D;&quot; + URL.encode(&quot;function route(invokers) &#123; ... &#125; (invokers)&quot;);</span><br><span class="line"></span><br><span class="line">function route(invokers) &#123;</span><br><span class="line">    var result &#x3D; new java.util.ArrayList(invokers.size());</span><br><span class="line">    for (i &#x3D; 0; i &lt; invokers.size(); i ++) &#123;</span><br><span class="line">        if (&quot;http:&#x2F;&#x2F;10.20.160.198&#x2F;wiki&#x2F;display&#x2F;dubbo&#x2F;10.20.153.10&quot;.equals(invokers.get(i).getUrl().getHost())) &#123;</span><br><span class="line">            result.add(invokers.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125; (invokers); &#x2F;&#x2F; 表示立即执行方法</span><br></pre></td></tr></table></figure><h2 id="Dubbo服务降级设置"><a href="#Dubbo服务降级设置" class="headerlink" title="Dubbo服务降级设置"></a>Dubbo服务降级设置</h2><p><em>1）多个服务之间可能由于服务没有启动或者网络不通，调用中会出现远程调用失败;</em></p><p><em>2) 服务请求过大，需要停止部分服务以保证核心业务的正常运行；</em></p><p>可以使用Dubbo的服务降级来实现，即在服务宕掉或者并发数太高导致的RpcException异常时，进行友好的处理或者提示，而不是内部报错导致系统不可用。</p><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a><strong>解决方法：</strong></h5><p>dubbo提供了mock配置，可以很好的实现dubbo服务降级。</p><h5 id="mock配置方式"><a href="#mock配置方式" class="headerlink" title="mock配置方式"></a>mock配置方式</h5><ul><li>服务返回固定值：配置了mock参数之后，假设在调用服务的时候，远程服务没有启动，或者各种网络异常了，那远程服务会把这个mock配置的值返回，也就是会返回123456…通过这种方式就可以避免了因为服务调用不了而出现异常错误而带来的程序不可用(起码是有值返回的，然后可以根据值进行业务逻辑处理判断等等)。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;xxxService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.x..service.xxxxService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;return 123456...&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>服务返回true：配置了mock参数之后，假设在调用服务的时候，远程服务没有启动，或者各种网络异常了，那远程服务会去寻找自定义的mock业务处理类进行业务处理。需要配置自定义的mock业务处理类进行业务处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;xxxService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.x..service.xxxxService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务类上增加Mock，实现服务，重写方法，返回降级之后的返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxxServiceMock</span> <span class="keyword">implements</span> <span class="title">xxxxService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getXXXX</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this is exception 自定义....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>管理界面手动配置：</p></li></ul><p><img src="/2021/01/15/dubbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/20180831152853913" alt="img"></p><p><strong>屏蔽：force.mock</strong> （即：屏蔽请求，直接返回某个值，如上面的字符串，*mock=”return 123456…”*）;</p><p><strong>容错：fail.mock</strong> （即：允许请求，在请求失败的时候，再返回某个值，如：*mock=”fail:return 123456…”*）;</p><h2 id="Dubbo服务限流设置"><a href="#Dubbo服务限流设置" class="headerlink" title="Dubbo服务限流设置"></a>Dubbo服务限流设置</h2><p>为了防止某个消费者的QPS或是所有消费者的QPS总和突然飙升而导致的重要服务的失效，系统可以对访问流量进行控制，这种对集群的保护措施称为服务限流。<br>Dubbo中能够实现服务限流的方式较多，可以划分为两类：<strong>直接限流</strong>与<strong>间接限流</strong></p><ul><li>直接限流：通过对连接数量直接进行限制来达到限流的目的。（官方方案汇总）</li><li>间接限流：通过一些非连接数量设置来达到限制流量的目的。</li></ul><h3 id="executes直接限流–-仅提供者端"><a href="#executes直接限流–-仅提供者端" class="headerlink" title="executes直接限流– 仅提供者端"></a>executes直接限流– 仅提供者端</h3><p>该属性仅能设置在提供者端。可以设置为接口级别，也可以设置为方法级别。限制的是服务（方法）并发执行数量。一旦超出指定的数目直接报错 其实是指在服务端的并行度【需要注意这些都是指的是在单台服务上而不是整个服务集群】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 类级别，服务器端并发执行（或占用线程池线程数）不能超过 10 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">executes</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方法级别，服务器端并发执行（或占用线程池线程数）不能超过 10 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">executes</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="accepts限流-–-仅提供者端"><a href="#accepts限流-–-仅提供者端" class="headerlink" title="accepts限流 – 仅提供者端"></a>accepts限流 – 仅提供者端</h3><p>该属性仅可设置在提供者端的<a href="dubbo:provider/">dubbo:provider/</a>与<a href="dubbo:protocol/">dubbo:protocol/</a>。用于对指定协议的连接数量进行限制。拦截器类为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--限制当前提供者在使用dubbo协议时最多可以接受10个消费者链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">accepts</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> <span class="attr">accepts</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="tps限流-仅服务端"><a href="#tps限流-仅服务端" class="headerlink" title="tps限流-仅服务端"></a>tps限流-仅服务端</h3><p>该属性仅可以配置在服务端，拦截器类为TpsLimitFilter。获取tps允许调用次数和tps.interval请求间隔。使用AtomicInteger表示允许调用的次数 每次调用减少1次当结果小于0之后返回不允许调用</p><h3 id="actives限流-–-两端"><a href="#actives限流-–-两端" class="headerlink" title="actives限流 – 两端"></a>actives限流 – 两端</h3><p>该限流方式与前两种不同的是，其可以设置在提供者端，也可以设置在消费者端。可以设置为接口级别，也可以设置为方法级别。拦截器类为ActiveLimitFilter。很明显当超过了指定的active值之后该请求将等待前面的请求完成【何时结束呢？依赖于该方法的timeout 如果没有设置timeout的话可能就是多个请求一直被阻塞然后等待随机唤醒吧……】。因此要搭配timeout一起使用噢！</p><h5 id="提供者端限流"><a href="#提供者端限流" class="headerlink" title="提供者端限流"></a><strong>提供者端限流</strong></h5><p>根据消费者与提供者间建立的连接类型的不同，其意义也不同</p><ul><li>长连接：表示当前长连接最多可以处理的请求个数。与长连接的数量没有关系</li><li>短连接：表示当前服务可以同时处理的短连接数量</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--类级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">actives</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方法级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">actives</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>消费者端限流</strong></p><p>根据消费者与提供者间建立的连接类型的不同，其意义也不同：</p><ul><li>长连接：表示当前消费者所发出的长连接中最多可以提交的请求个数。与长连接的数量没有关系。</li><li>短连接：表示当前消费者可以提交的短连接数量</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--类级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">actives</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方法级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">actives</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="connections限流"><a href="#connections限流" class="headerlink" title="connections限流"></a>connections限流</h3><p>可以设置在提供者端，也可以设置在消费者端。限定连接的个数。对于短连接，该属性效果与actives相同。但对于长连接，其限制的是长连接的个数。一般情况下，会使connectons与actives联用，让connections限制长连接个数，让actives限制一个长连接中可以处理的请求个数。联用前提：使用默认的Dubbo服务暴露协议</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="间接限流-延迟连接-–-仅消费者端"><a href="#间接限流-延迟连接-–-仅消费者端" class="headerlink" title="间接限流 延迟连接 – 仅消费者端"></a>间接限流 <strong>延迟连接 – 仅消费者端</strong></h3><p>仅可设置在消费者端，且不能设置为方法级别。仅作用于Dubbo服务暴露协议。将长连接的建立推迟到消费者真正调用提供者时。<br>可以减少长连接的数量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前消费者对接口中的每个方法发出链接采用延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span>  <span class="attr">lazy</span>=<span class="string">&quot;true&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.dubbo.service.UserService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">lazy</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:consumer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="间接限流-粘连连接-–-仅消费者"><a href="#间接限流-粘连连接-–-仅消费者" class="headerlink" title="间接限流 粘连连接 – 仅消费者"></a>间接限流 <strong>粘连连接 – 仅消费者</strong></h3><p>仅能设置在消费者端，其可以设置为接口级别，也可以设置为方法级别。仅作用于Dubbo服务暴露协议。其会使客户端尽量向同一个提供者发起调用，除非该提供者挂了，其会连接另一台。只要启用了粘连连接，其就会自动启用延迟连接其限制的是流向，而非流量</p><h2 id="Dubbo服务负载均衡"><a href="#Dubbo服务负载均衡" class="headerlink" title="Dubbo服务负载均衡"></a>Dubbo服务负载均衡</h2><p>可以设置在消费者端，亦可设置在提供者端；可以设置在接口级别，亦可设置在方法级别。其限制的是流向，而非流量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;leastactive&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于权重随机算法的 RandomLoadBalance  默认路由</li><li>基于最少活跃调用数算法的 LeastActiveLoadBalance</li><li>基于 hash一致性的 ConsistentHashLoadBalance</li><li>基于加权轮询算法的 RoundRobinLoadBalance</li><li>最少响应时间加权算法的ShortestResponseLoadBalance</li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul><li>dubbo协议，基于 hessian2作为序列化协议。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高。</li><li>rmi 协议，走Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。</li><li>hessian 协议，走hessian2序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。</li><li>http 协议，走 json 序列化。</li><li>webservice协议，走 SOAP 文本。</li><li>grpc协议</li><li>injvm协议</li><li>memcached</li><li>Thrift</li><li>redis</li><li>rest<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2></li></ul><p>Serialization: java、compactedjava、nativejava、fastjson、fst、hessian2、kryo、gson、avro 、protostuff、protobuf</p><p>其中默认hessian2。其中java、compactedjava、nativejava属于原生java的序列化。</p><h2 id="端口监控"><a href="#端口监控" class="headerlink" title="端口监控"></a>端口监控</h2><p>netstat -an |grep 18220 | wc -l</p><p>netstat -an |grep 18220</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>连接个数：单连接<br>连接方式：长连接</p><p>传输协议：TCP<br>传输方式：NIO 异步传输</p>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logstash简单使用</title>
      <link href="2021/01/06/Logstash%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2021/01/06/Logstash%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="使用mysql作为input"><a href="#使用mysql作为input" class="headerlink" title="使用mysql作为input"></a>使用mysql作为input</h2><blockquote><p>下载logstash</p></blockquote><p><a href="https://www.elastic.co/cn/downloads/logstash">logstash官网</a></p><blockquote><p>解压文件，并在其根目录下创建<code>mysqletc</code>文件夹（名称随意），在<code>mysqletc</code>文件夹下创建<code>mysql.conf</code>（名称随意）</p></blockquote><p>在<code>mysql.conf</code>配置文件中写入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  jdbc &#123;</span><br><span class="line">    # 数据库连接语句</span><br><span class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/springboot_es?characterEncoding=UTF8&quot;</span><br><span class="line">    jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">    jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">    # mysql-connection驱动的绝对路径</span><br><span class="line">    jdbc_driver_library =&gt; &quot;/develop/software/logstash-6.6.2/mysqletc/mysql-connector-java-5.1.47.jar&quot;</span><br><span class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">    jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">    # SQL查询语句，用于将查询到的数据导入到ElasticSearch</span><br><span class="line">    statement =&gt; &quot;select id,title,content from tb_article&quot;</span><br><span class="line">    # 定时任务，各自表示：分 时 天 月 年 。全部为 * 默认每分钟执行</span><br><span class="line">    schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">    # 索引名称</span><br><span class="line">    index =&gt; &quot;aritcleindex&quot;</span><br><span class="line">    # 自增ID编号</span><br><span class="line">    document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">    # 文档名称</span><br><span class="line">    document_type =&gt; &quot;article&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    # JSON格式输出</span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成，找一个<code>mysql-connection.jar</code>包拷贝到<code>/mysqletc/</code>根目录下，并修改配置文件中的<code>jdbc_driver_library</code>路径地址。</p><blockquote><p>创建数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> springboot_es <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> utf8;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`tb_article`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_article`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;文章标题&#x27;</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;文章内容&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tb_article`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;测试&#x27;</span>, <span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tb_article`</span> <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;测试啊&#x27;</span>, <span class="string">&#x27;测试啊&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>在终端中切换到<code>logstash</code>根目录下</p></blockquote><p>执行<code>logstash -f ../mysqletc/mysql.conf</code>：</p><p>并且查询语句会每分钟执行一次。</p>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Logstash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料汇总</title>
      <link href="2021/01/04/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
      <url>2021/01/04/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000021340649">https://segmentfault.com/a/1190000021340649</a></p><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p><a href="https://github.com/spring-projects/spring-boot">spring-boot</a>推荐指数：★Star44.1K</p><p>推荐语：从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。具有如下特性：创建独立的Spring应用程序、嵌入的Tomcat，无需部署WAR文件、简化Maven配置、自动配置Spring、提供生产就绪型功能，如指标，健康检查和外部配置、绝对没有代码生成和对XML没有要求配置。</p><p><a href="https://developer.aliyun.com/special/tech-java">Java 开发手册</a>    推荐指数：★★★★★</p><p>推荐语：这部手册始于阿里内部规约，在全球 Java 开发者共同努力下，已成为业界普遍遵循的开发规范，内容涵盖编程规约、异常日志、单元测试、安全规约、MySQL 数据库、工程规约、设计规约共七大维度。</p><p><a href="https://github.com/Snailclimb/JavaGuide">Java学习+面试指南-JavaGuide</a>  推荐指数：★Star64.7K</p><p>推荐语：【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。</p><p><a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a>     推荐指数：★Star53.6K</p><p>推荐语：史上最全的用Java实现的设计模式。</p><p><a href="https://github.com/xingshaocheng/architect-awesome">architect-awesome</a>     推荐指数：★Star40.2K</p><p>推荐语：史上最全的后端架构师技术图谱。</p><p><a href="https://github.com/doocs/advanced-java">后端同学进阶必看的advanced-java</a>     推荐指数：★Star35.3K</p><p>推荐语：本系列知识出自中华石杉，可以作为互联网 Java 工程师进阶知识完全扫盲。学习本系列知识之前，如果你完全没接触过 MQ、ES、Redis、Dubbo、Hystrix 等，那么我建议你可以先在网上搜一下每一块知识的快速入门，跟着入门 Demo 玩一下，然后再开始每一块知识的学习，这样效果更好。</p><p><a href="https://github.com/akullpp/awesome-java">akullpp发起维护的Java资源列表-awesome</a>   推荐指数：23.2K</p><p>推荐语：awesome项目是github的一个神奇项目，awesome-java 就是akullpp发起维护的Java资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等</p><p><a href="https://github.com/seata/seata">基于Java的开源分布式事务解决方案-Seata</a>    推荐指数：★Star13.1K</p><p>推荐语：Seata是一种易于使用，高性能，基于Java的开源分布式事务解决方案，旨在实现简单并快速的事务提交与回滚。</p><p><a href="https://github.com/macrozheng/mall">基于SpringBoot+MyBatis实现-mall电商系统</a>     推荐指数：★Star26.4K</p><p>推荐语：mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。</p><p><a href="https://github.com/qiurunze123/miaosha">基于MQ、SpringBoot、Redis、Dubbo的秒杀系统</a>   推荐指数：★Star11.6K</p><p>推荐语：该项目是对高并发大流量如何进行秒杀架构，而做的一个系统整理，如果你完全没接触过 MQ、SpringBoot、Redis、Dubbo、ZK 、Maven,lua等，那么我建议你可以先在网上搜一下每一块知识的快速入门</p><p><a href="https://github.com/apache/flink">数据分析开源系统-Apache Flink</a>   推荐指数：★Star11.4K</p><p>推荐语：Apache Flink 声明式的数据分析开源系统，结合了分布式 MapReduce 类平台的高效，灵活的编程和扩展性。同时在并行数据库发现查询优化方案。</p><p><a href="https://github.com/wuyouzhuguli/SpringAll">SpringAll</a>   推荐指数：★Star11.4K</p><p>推荐语：包括了Spring Boot，Spring Boot＆Shiro，Spring Cloud，Spring Boot＆Spring Security＆Spring Security OAuth2等系列教程。</p><p><a href="https://github.com/crossoverJie/cim">一款面向开发者的 IM(即时通讯)系统-CIM(CROSS-IM)</a>   推荐指数：★Star4.4K</p><p>推荐语：CIM(CROSS-IM) 一款面向开发者的 IM(即时通讯)系统；同时提供了一些组件帮助开发者构建一款属于自己可水平扩展的 IM 。借助 CIM 你可以实现以下需求：IM 即时通讯系统、适用于 APP 的消息推送中间件、IOT 海量连接场景中的消息透传中间件。</p><p><a href="https://github.com/alibaba/arthas">阿里巴巴Java诊断工具Arthas</a>    推荐指数：★Star18.5K</p><p>推荐语：Arthas旨在帮助开发人员解决Java应用程序的生产问题，无需修改代码或重新启动服务器。有了Arthas，你就可以在不重新启动JVM或需要额外的代码更改的情况下实时地对问题进行故障排除。</p><p><a href="https://github.com/eugenp/tutorials">基于Spring Framework（和Spring Security）的教程</a>    推荐指数：★Star18.5K</p><p>推荐语：该项目是一系列小而专注的教程，每个教程都涵盖一个明确的开发领域。大多数教程项目都专注于Spring Framework（和Spring Security）。以下技术是重点：core Java，Jackson，HttpClient，Guava。</p><p><a href="https://github.com/lenve/vhr">基于SpringBoot+Vue开发的人力资源管理系统-vhr</a>   推荐指数：★Star12.3K</p><p>推荐语：一个前后端分离的人力资源管理系统，采用SpringBoot+Vue开发。这个项目的权限管理模块已经开发完成，其他模块还在开发当中。可以管理角色和资源的关系，管理用户和角色的关系。</p><p><a href="https://github.com/hollischuang/toBeTopJavaer">To Be Top Javaer - Java工程师成神之路</a>   推荐指数：★Star9.9K</p><p>推荐语：Java工程师成神之路。总结的很好，直接理解学习就完了。</p><p><a href="https://github.com/kdn251/interviews">软件工程技术面试个人指南-interviews</a>     推荐指数：★Star40.8K</p><p>推荐语：软件工程技术面试个人指南。可以这里找到针对很多面试问题的视频解决方案以及详细说明。</p><p><a href="https://github.com/zhangdaiscott/jeecg-boot">基于代码生成器的JAVA快速开发平台-jeecg-boot</a>    推荐指数：★Star8.5K</p><p>推荐语：一款基于代码生成器的JAVA快速开发平台！全新架构前后端分离：SpringBoot 2.x，Ant Design&amp;Vue，Mybatis，Shiro，JWT。强大的代码生成器让前后端代码一键生成，无需写任何代码，绝对是全栈开发的福音！</p><p><a href="https://github.com/forezp/SpringCloudLearning">史上最简单的Spring Cloud教程源码</a>     推荐指数：★Star11.5K</p><p>推荐语：@方志朋“史上最简单的SpringCloud教程”系列，包括Spring Cloud阿里巴巴教程、格林威治版本、芬奇利版本、源码篇、进阶篇、d版本、番外篇等</p><p><a href="https://github.com/alibaba/fastjson">阿里巴巴 的开源项目-fastjson</a>     推荐指数：★Star20.2K</p><p>推荐语：@阿里巴巴 的开源项目，Fastjson是一个Java库，可用于将Java对象转换为其JSON表示，还可用于将JSON字符串转换为等效的Java对象。</p><p><a href="https://github.com/alibaba/nacos">阿里巴巴 的开源项目-nacos</a>    推荐指数：★Star9.7K</p><p>推荐语：@阿里巴巴 的开源项目，<a href="https://link.zhihu.com/?target=http://nacos.io/">Nacos</a>是一个易于使用的平台，专为动态服务发现，配置和服务管理而设计。它可以帮助使用者轻松构建云本机应用程序和微服务平台。</p><p><a href="https://github.com/spring-projects/spring-framework">spring-framework</a>    推荐指数：★Star34.1K</p><p>推荐语：与<a href="https://link.zhihu.com/?target=https://github.com/spring-projects/spring-boot">spring-boot</a>同样是非常值得学习的项目。</p><p><a href="https://github.com/alibaba/p3c">阿里巴巴 p3c项目</a>    推荐指数：★Star19.5K</p><p>推荐语：是@阿里巴巴 p3c项目组进行研发。根据《阿里巴巴Java开发规范》转化而成的自动化插件，并且实现了部分自动编程。</p><p><a href="https://github.com/apache/dubbo">基于Java的高性能开源RPC框架-dubbo</a>   推荐指数：★Star30.4K</p><p>推荐语：Apache Dubbo是一个基于Java的高性能开源RPC框架。</p><p><a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a>    推荐指数：★Star53.5K</p><p>推荐语：设计模式是程序员在设计应用程序或系统时可用于解决常见问题的最佳形式化实践。重用设计模式有助于防止导致重大问题的细微问题，并且还可以提高熟悉模式的编码人员和架构师的代码可读性。</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba">spring-cloud-alibaba</a>    推荐指数：★Star10.8K</p><p>推荐语：由@阿里巴巴 维护的项目，它为分布式应用程序开发提供一站式解决方案，包含开发分布式应用程序所需的所有组件，使用者可以轻松地使用Spring Cloud开发应用程序。</p><p><a href="https://github.com/eugenp/tutorials">Spring 教程-tutorials</a>   推荐指数：★Star18.5K</p><p>推荐语：每个教程都涵盖Java生态系统中单一且定义明确的开发领域。当然，它们的重点是Spring Framework - Spring，Spring Boot和Spring Security。</p><p><a href="https://github.com/dianping/cat">服务端项目基础组件-cat</a>    推荐指数：★Star12.3K</p><p>推荐语：作为服务端项目基础组件，cat提供了 Java, C/C++, Node.js, Python, Go 等多语言客户端，已经在美团点评的基础架构中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等，消息队列，配置系统等）深度集成，为美团点评各业务线提供系统丰富的性能指标、健康状况、实时告警等。</p><p><a href="https://github.com/TheAlgorithms/Java">算法-Java</a>    推荐指数：★Star20.4K</p><p>推荐语：适合用Java编程的算法学习者。</p><p><a href="https://github.com/google/guava">Google Java核心库</a>    推荐指数：★Star35.1K</p><p>推荐语：包括新的集合类型（例如多图和多集），不可变集合，图形库以及用于并发，I / O，哈希，基元，字符串等的实用程序！</p><p><a href="https://github.com/giantray/stackoverflow-java-top-qa">StackOverflow Java Top100问题（翻译）</a> 推荐指数：★Star4.9K</p><p>推荐语：对阅读本项目的人来说：1.巩固基础。top100问题都是比较重要、基础的问题；而且也都是so上很多人优化和投票的，很靠谱。2.快速学习知识。相对英文原文，本项目的翻译有两个优点：（1）是中文母语，能更好理解；（2）翻译时会对原文做精简，多个答案做整合，阅读起来更有效率。</p><p><a href="https://github.com/AobingJava/JavaFamily">JavaFamily </a>     推荐指数：★Star3.8K</p><p>推荐语：【互联网一线大厂面试+学习指南】进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识。</p><p><a href="https://github.com/brianway/java-learning">java-learning</a>     推荐指数：★Star3.3K</p><p>推荐语：作者的Java学习笔记。笔记内容主要是对一些基础特性和编程细节进行总结整理，适合了解Java基础语法，想进一步深入学习的人。含博客讲解和二进制实例，采用maven构建，分模块学习，涉及反射，代理，多线程，IO，集合类等核心知识。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql之分区及分库分表</title>
      <link href="2020/12/24/mysql%E4%B9%8B%E5%88%86%E5%8C%BA%E5%8F%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>2020/12/24/mysql%E4%B9%8B%E5%88%86%E5%8C%BA%E5%8F%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是表分区"><a href="#什么是表分区" class="headerlink" title="什么是表分区"></a><strong>什么是表分区</strong></h2><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p><h2 id="表分区与分表的区别"><a href="#表分区与分表的区别" class="headerlink" title="表分区与分表的区别"></a><strong>表分区与分表的区别</strong></h2><p><strong>分表</strong>：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。</p><p><strong>分表与分区的区别在于</strong>：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p><h2 id="表分区有什么好处"><a href="#表分区有什么好处" class="headerlink" title="表分区有什么好处"></a><strong>表分区有什么好处</strong></h2><p>1、<strong>存储更多数据</strong>。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据</p><p>2、<strong>优化查询</strong>。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</p><p>3、<strong>分区表更容易维护</strong>。例如：想批量删除大量数据可以清除整个分区。</p><p>4、<strong>避免某些特殊的瓶颈</strong>，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</p><h2 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a><strong>分区表的限制因素</strong></h2><ol><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ol><h2 id="如何判断当前MySQL是否支持分区"><a href="#如何判断当前MySQL是否支持分区" class="headerlink" title="如何判断当前MySQL是否支持分区"></a><strong>如何判断当前MySQL是否支持分区</strong></h2><p>命令：show variables like ‘%partition%’ 运行结果:  have_partintioning 的值为YES，表示支持分区。</p><h2 id="MySQL支持的分区类型有哪些"><a href="#MySQL支持的分区类型有哪些" class="headerlink" title="MySQL支持的分区类型有哪些"></a><strong>MySQL支持的分区类型有哪些</strong></h2><ol><li><strong>RANGE分区</strong>： 这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li><strong>LIST分区</strong>： 这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li><strong>HASH分区</strong> ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li><strong>KEY分区</strong> ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ol><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><ul><li>表字段拆分</li><li>业务拆分</li></ul><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>分表-》分库</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql之锁</title>
      <link href="2020/12/24/mysql%E4%B9%8B%E9%94%81/"/>
      <url>2020/12/24/mysql%E4%B9%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><p>有些情况下为了保证数据逻辑的一致性，需要对SELECT的操作加锁。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、  SELECT …… FOR UPDATE</span><br><span class="line"></span><br><span class="line">2、  SELECT …… LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure><p>其中，SELECT …… FOR UPDATE对读取的记录加一个锁，其他事务不能对已锁定的行加任何锁。而SELECT …… LOCK IN SHARE MODE也是对读取的记录加一个锁。 </p><p>但是如果有另一个一致性非锁定读的操作来读取该行那么数据是不会阻塞的，读取的是改行的快照版本(也就是指改行之前的数据版本,也就会出现脏读，所以也称为非锁定读，因为不需要等待被访问行的锁的释放。非锁定读的方式极大提高了数据库的并发性。在InnoDB存储引擎中，这是默认的读取方式)   </p><p>SELECT …… FOR UPDATE和SELECT …… LOCK IN SHARE MODE必须在一个事务中，当一个事务提交了，锁就释放了。因此在使用这两个SELECT锁定语句时，必须开启事务。</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>锁定整个表</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>Innodb支持行级锁，需要字段为索引，否则退化为行锁</p><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>字段为索引，某个范围加锁，如更新id大于10的数据，会对id为10之后的范围数据全部加锁，插入新数据也没有办法插入</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql之MVCC及快照读和当前读</title>
      <link href="2020/12/24/mysql%E4%B9%8BMVCC%E5%8F%8A%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB/"/>
      <url>2020/12/24/mysql%E4%B9%8BMVCC%E5%8F%8A%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>1、什么是锁？</p><p>一种保护机制，在多线程的情况下，保证操作数据的正确性与一致性</p><p>2、锁有哪些分类？</p><p>悲观锁、乐观锁、独占锁、共享锁、公平锁、非公平锁、分布式锁、自旋锁</p><p>3、谈谈悲观锁乐观锁：<br>指的是看待并发同步的角度，一般结合数据库将，以MySQL为例，悲观锁主要是表锁，行锁和间隙锁，叶锁，读锁，因为这些锁在被触发时会引起线程阻塞，所以叫悲观锁；而乐观锁其实在MySQL中本身不存在，但是MySQL提供了MVCC的机制，支持乐观锁机制</p><p>4、什么是MVCC？</p><p>只有在InnoDB引擎下存在，MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，所说的乐观锁只在事务级别未提交锁和已提交锁时才会生效</p><p>5、具体MVCC机制有什么？</p><p>多版本并发控制，保证数据操作在多线程过程中，保证事务隔离的机制，可以降低锁竞争的压力，保证较高的并发量。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题</p><p>6、在多个事务操作同一条数据的并发过程中，谁先成功?</p><p>mysql判断，先提交的先成功</p><p>7、谈谈事务。</p><p>事务常说一系列操作作为一个整体要么都成功要么都失败，主要特性acid，事务的的实现主要依赖两个log redo-log,undo-log,每次事务都会记录数据修改前的数据undo-log，修改后的数据放入redo-log,提出成功则使用redo-log 更新到磁盘，失败则使用undo-log将数据恢复到事务之前的数据</p><p>8、再谈谈独占锁、共享锁：</p><p>独占锁即是持有锁的线程只有一个，共享锁则可以有多个线程</p><p>9、共享的意义在于？</p><p>共享锁是为了提高程序的效率，举个例子：数据的操作有读写之分，对于写的操作加锁，保证数据正确性，而对于读的操作如果不加锁，在写读操作同时进行时，读的数据有可能不是最新数据，如果对读操作加独占锁，面对读多写少的程序肯定效率很低，所有就出现了共享锁，对于读的的操作就使用共享的概念，但是对于写的操作则是互斥的，保证了读写的数据操作都一致</p><h2 id="一丶什么是MVCC？"><a href="#一丶什么是MVCC？" class="headerlink" title="一丶什么是MVCC？"></a>一丶什么是MVCC？</h2><p>　　MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。当然，这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。具体见下面介绍。</p><h2 id="二丶MVCC的实现机制"><a href="#二丶MVCC的实现机制" class="headerlink" title="二丶MVCC的实现机制"></a>二丶MVCC的实现机制</h2><p>　　InnoDB在每行数据都增加两个隐藏字段，一个记录创建的版本号，一个记录删除的版本号。</p><p>　　在多版本并发控制中，为了保证数据操作在多线程过程中，保证事务隔离的机制，降低锁竞争的压力，保证较高的并发量。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。</p><h2 id="三丶MVCC下的CRUD"><a href="#三丶MVCC下的CRUD" class="headerlink" title="三丶MVCC下的CRUD"></a>三丶MVCC下的CRUD</h2><p><strong>SELECT：</strong><br>　　当隔离级别是REPEATABLE READ时select操作，InnoDB必须每行数据来保证它符合两个条件：<br>　　1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。<br>　　2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。<br>符合这两个条件的行可能会被当作查询结果而返回。</p><p><strong>INSERT：</strong></p><p>　　InnoDB为这个新行记录当前的系统版本号。<br><strong>DELETE：</strong></p><p>　　InnoDB将当前的系统版本号设置为这一行的删除ID。<br><strong>UPDATE：</strong></p><p>　　InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。</p><p>　　这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。<br>　　MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。</p><img src="/2020/12/24/mysql%E4%B9%8BMVCC%E5%8F%8A%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB/image-20201224171640438.png" alt="image-20201224171640438" style="zoom: 50%;"><h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a><strong>四种隔离级别</strong></h2><ol><li>**Serializable (串行化)**：可避免脏读、不可重复读、幻读的发生。</li><li>**Repeatable read (可重复读)**：可避免脏读、不可重复读的发生。</li><li>**Read committed (读已提交)**：可避免脏读的发生。</li><li>**Read uncommitted (读未提交)**：最低级别，任何情况都无法保证。</li></ol><h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a><strong>快照读</strong></h2><p><strong>快照读</strong>是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</p><p>　　<strong>读已提交：</strong>一个事务内操作一条数据，可以查询到另一个已提交事务操作同一条数据的最新值。（Oracle 默认隔离级别）</p><p>　　<strong>可重复读：</strong>每个事务只关注自己事务开始查询到的数据值，无论事务查询同一条数据多少次，该数据改了多少次，都只查询到事务开始之前的数据值。（MySQL 默认隔离级别）</p><p>　　而所谓 <strong>MVCC 并发版本控制</strong>，是靠 readView (事务视图) 来实现的。多个 readView 组成 undo log（回滚日志）。</p><p>　　每一个 sql 查询某条数据时，都是查询最新 readView 的该条数据的值。</p><p>　　<strong>ReadView：</strong>（查询同一条数据，因为 readView 也是针对同一条数据生成的视图）</p><p>　　<strong>读已提交：</strong>是事务中的每个 sql 语句生成一个 readView。那就是一个事务内多条 sql 语句，会生成多个 readView。而每条 sql 执行时，都是查询最新 readView 的值。</p><p>　　假如事务 A 有2个查询 sql 语句，在第一个查询 sql 生成一个 readView（事务视图 id = n），事务 B 对该数据做了操作，那么就会生成新的 readView（事务视图 id = n + 1），第二个查询 sql 语句获取该条数据时，就会去 readView（事务视图 id = n + 1）查询数据。</p><p>　　<strong>可重复读：</strong>是在事务开始的时候生成一个 readView。所以一个事务内的多条查询 sql ，查询同一条数据时，读取到的 readView 都是同一个，那么查询某条数据的值，也是同一个值。</p><p>　　例如事务A开始查询主键 id = 1 的行数据的列 age = 10，不管其他事务是否对该 age 做改变，当前事务的多条查询 sql 语句，查询 age 的值一直都是 age = 10。</p><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a><strong>当前读</strong></h2><p><strong>当前读</strong>是基于 临键锁（行锁 + 间歇锁）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。</p><p>　　<strong>当前读：</strong></p><p>　　更新数据时，都是先读后写，而这个读，就是当前读。读取数据时，读取该条数据的已经提交的最新的事务，生成的 readView。</p><p>　　例如事务 A 有2个 sql 语句，事务开始时生成 readView（id = n），第一个 sql 操作一条数据时读当前的 readView（id = n） 。此时开始事务B生成 readView（id = n + 1），并且对该条数据做了操作（非简单 select 操作）。事务A的第2个 sql 语句<strong>当前读</strong>该数据时，就会读取该数据的最新事务视图 readView (id =n + 1) 的值。</p><p>　　而假如事务A的第二个 sql 语句操作数据时，事务B还未提交（非简单 select 操作），那么该条数据此时被事务B的<strong>写锁</strong>锁住。事务A的第二个 sql 语句操作数据（非简单 select 操作），那么也要获取该条数据的锁。而此时锁被事务B持有，事务A就会阻塞，等待事务B释放锁。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之并发与并行</title>
      <link href="2020/12/23/java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"/>
      <url>2020/12/23/java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是并发、并行？"><a href="#什么是并发、并行？" class="headerlink" title="什么是并发、并行？"></a>什么是并发、并行？</h3><p>这里引用Java8实战中的一张图片来加以说明</p><p><img src="/2020/12/23/java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwrv49sw0j30fq07iwf8.jpg" alt="image.png"></p><p>可能从上图简单来看，并发是单处理器核心多任务的交替执行，并行是多任务多处理器核心的同时执行，由于这个问题并没有被盖棺定论规范化，导致可能不同的人有不同的理解，我也并不能给出一个严格意义上准确的定义，但是我综合他人的观点给出的自己的定义如下，<strong>并行是并发的一种表现形式</strong>，并发只强调两个任务的生命周期存在交集，即对用上面的任务1开始到结束的过程中，如果任务2也开始了，那么我们就认为任务1和任务2是并发的。但是今天想梳理的并不是严格意义上的区分这两个关联紧密的概念，而是讨论这两者能够给我们的程序带来什么？</p><p><strong>并发</strong>更加侧重于<strong>压榨单个CPU的性能，降低任务平均时延</strong>，对于一串任务（task1，task2，task3…）高并发并不能加快这些任务总体完成的时间，甚至由于线程切换还会延长任务总体完成的时间，所以它并不是以提高整体响应速率为目的的，而并行它使得多个任务（任务之间不相干，简化讨论，避免多核之间的一致性要求）可以在多个处理器核中得到真正的同时处理，而这个时候对于一系列的不相干任务来说，利用并行计算，就能大大缩短整体的响应时间</p><h3 id="单线程并发能够提高任务的总体处理速度嘛？"><a href="#单线程并发能够提高任务的总体处理速度嘛？" class="headerlink" title="单线程并发能够提高任务的总体处理速度嘛？"></a>单线程并发能够提高任务的总体处理速度嘛？</h3><p>答案是显然的，<strong>不能</strong>，而且由于线程切换带来的资源开销，单线程并发还会延长<strong>整个</strong>任务的处理时间？</p><h3 id="单线程并发还有必要嘛？"><a href="#单线程并发还有必要嘛？" class="headerlink" title="单线程并发还有必要嘛？"></a>单线程并发还有必要嘛？</h3><p>有必要，而且非常有必要，首先我们假定有四个任务1，2，3，4如下，每个任务的执行耗时1个单位时间，如果按照单线程串行的执行方式，它应该是这样的</p><p><img src="/2020/12/23/java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwuv5cv87j30f409wmxa.jpg" alt="image.png"></p><p>对于task1来说，它还能接收，毕竟执行1个单位时间它就拿到了它想要的结果，但是对于后面的task来说就不满意了，特别是task4来说，执行task4的耗时为1个单位时间，但是它需要等4个单位时间才能拿到结果，如果在多线程情况下，它是如何的呢？假设每个task都另起了一个线程，且不考虑操作系统任务调度耗时等等，现在的处理情况是这样的</p><p><img src="/2020/12/23/java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/006rmQBHly1glwv7rlnk4j30od0a7dg5.jpg" alt="image.png"></p><p>假如理想状况下，每个任务被切割得足够小，那么最终每个任务几乎是同时开始同时结束，那么每个task的用时就是总耗时的平均值也就是2.5，这下task4总算开心了，它不用等那么久了。</p><p>但是实际问题中，不可能把任务无限切分，操作系统的线程调度也是耗时操作，那么上面的结论就不一定那么可靠了，甚至可能每个时间都超过3了，那还不如串行呢，至少task1和task2爽了，那为什么还需要并发呢？</p><p>因为实际状况下，每个任务的执行速度也不可能完全相等，每个任务执行的速度有快有慢，我们现在假设task1执行用时需要1000个单位时间，如果在串行情况下，task1后面的所有任务都会被task1所拖累，需要等待的时间为1000加，而此时的并发执行策略中，虽然由于系统调度等等开销，task2，3，4仍然可以以一个与之前速度相差无几的时间响应，task1带来的恶劣影响也单单只影响到了自己。我们上面的策略也就类似于tomcat对于请求的处理策略，针对每个请求都另起一个线程（processor）来处理。</p><h3 id="tomcat都这么厉害了，自己的代码中还有必要多线程嘛？"><a href="#tomcat都这么厉害了，自己的代码中还有必要多线程嘛？" class="headerlink" title="tomcat都这么厉害了，自己的代码中还有必要多线程嘛？"></a>tomcat都这么厉害了，自己的代码中还有必要多线程嘛？</h3><p><strong>有必要</strong>，通常一个大任务是由多个小任务组合而成，如果按照<strong>CPU密集型和I/O密集型</strong>来划分任务类型的话，对于CPU密集型任务来说，无论我们再怎么多线程疯狂操作也好，在单核处理器中，最终都还是依靠单核来做运算，多线程的线程切换开销无疑延长了整个任务的处理时间，但是在I/O密集型任务情况下（包括磁盘IO，网络IO），假设你发起了10个不同的RPC调用，无疑多线程的方式能够让你同时发起多个请求，多个请求同时等待响应，否则你就只能按照串行的方式，每个请求都需要等一个时延，然后再处理下一个请求，这样的等待无疑延长了总体响应时间，降低CPU利用率。其实这样的并发就包含了并行，因为你发起的远程调用是远方的多个处理器去帮你处理的，我们所做的只不过是利用并发在一个请求傻等着的过程中又发起了另一个请求罢了</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行的好处是显而易见的，多个处理器干活肯定是快于一个人干活的，对于上面讨论的情况，如果在多核心的处理器下，并发之后可能整个处理过程就是并行的，小的任务可以在多个处理器核心中同时运行，在这里也不太过多讨论并发安全的问题，主要讨论如何高效并行</p><p>在tomcat中想要并行很简单，你并发就好，如果你有多个处理器核心它自然会并行执行，可能并不太需要我们对整个处理过程进行并行处理，关注更多的是不同请求之间的并行，但是在一些场景下，可能就需要我们关注整个任务本身的并行，这时候并行就不那么容易，假设你要计算1-1000000000的和，你当然可以选择并发执行，自己分割每个处理器计算多少到多少的和，然后自行汇总结果，就像下面的代码一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentVsParallel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//串行</span></span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> time1=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000000000L</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;串行计算结果为：&quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;串行耗时：&quot;</span>+(System.currentTimeMillis()-time1));</span><br><span class="line">        <span class="keyword">long</span> time2= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> res = concurrentCal(<span class="number">10000000000L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结果为：&quot;</span>+res);</span><br><span class="line">        System.out.println(<span class="string">&quot;并行耗时为：&quot;</span>+(System.currentTimeMillis()-time2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">concurrentCal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//4等分来处理</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">long</span> quarter=n/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> allSum=<span class="number">0</span>;</span><br><span class="line">        Future[] parts = <span class="keyword">new</span> Future[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4L</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp=i;</span><br><span class="line">            Future&lt;Long&gt; partSum = executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> j = temp * quarter + <span class="number">1</span>; j &lt;= (temp + <span class="number">1</span>) * quarter; j++) &#123;</span><br><span class="line">                    sum += j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;);</span><br><span class="line">            parts[i]=partSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.length; i++) &#123;</span><br><span class="line">            allSum+=(<span class="keyword">long</span>)parts[i].get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串行计算结果为：-5340232216128654848</span><br><span class="line">串行耗时：4617</span><br><span class="line">计算结果为：-5340232216128654848</span><br><span class="line">并行耗时为：1847</span><br></pre></td></tr></table></figure><p>上述的代码能够实现我们既定的目标，但是存在着<strong>可读性和可拓展性</strong>的问题，性能也存在着问题，如果需要对(2-n)求和呢，很简单，给我们的代码加入一个start即可，但是如果需要对（2-n）中所有的偶数求和呢？岂不是又需要改代码，更加严重的问题是任务规模的划分是定下来的，导致任务划分的粒度有的时候并不够，当然你也可以再添加一个参数设置任务规模的划分，但是上述这些操作都会导致代码的膨胀和难以维护，利用java8的Stream可以做如下简单实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time3=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> res = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">10000000000L</span>).parallel().sum();</span><br><span class="line">System.out.println(<span class="string">&quot;stream计算结果为：&quot;</span>+res);</span><br><span class="line">System.out.println(<span class="string">&quot;stream耗时为：&quot;</span>+(System.currentTimeMillis()-time3));</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串行计算结果为：-5340232216128654848</span><br><span class="line">串行耗时：4631</span><br><span class="line">stream计算结果为：-5340232216128654848</span><br><span class="line">stream耗时为：3605</span><br></pre></td></tr></table></figure><p>虽然这里的耗时可能比不过我们直接手动划分，并发的方式去进行计算，但是这里的代码可读性以及可拓展性是非常好的，如果你想过滤掉所有的奇数，加一个filter就好。诚然这个结果也受限于我仅仅只有四核的垃圾笔记本，无论如何，通过Stream的方式，Java的并行计算也变得简单！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Java8实战》</p><p><a href="https://www.zhihu.com/question/37396742">https://www.zhihu.com/question/37396742</a></p><p><a href="https://www.zhihu.com/question/33515481">https://www.zhihu.com/question/33515481</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 并发与并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis之缓存更新</title>
      <link href="2020/12/23/Redis%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/"/>
      <url>2020/12/23/Redis%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h2><p>更新缓存的时候涉及两个问题：</p><ul><li>删除（del）还是 修改（set）？</li><li>先操作数据库，还是 先操作缓存？</li></ul><p>组合起来就有四种情况：</p><p><font color="red">第一种情况：先删除缓存，后更新数据库</font></p><p>如果删除缓存失败，则后面的操作都不会执行，没问题；</p><p>如果删除缓存成功，更新数据库失败，则缓存与数据库不一致，但这种不一致会马上被修正，因而不影响，因为下一次请求缓存的时候发现缓存中没有，会从数据库重新加载；但是，又有一个问题出现了，在旧的缓存被删除后，新的缓存未写入之前，这段时间内如果有读操作，那么旧的值会被重新加载到缓存，这就相当于没更新缓存；</p><p><font color="red">第二种情况：先更新缓存，后更新数据库</font></p><p>同样，如果更新缓存成功，更新数据库是吧，则出现缓存与数据库不一致，<strong>数据不一致就是问题</strong></p><p><font color="red">第三种情况：先更新数据库，后删除缓存</font></p><p>如果更新数据库成功，删除缓存失败，则出现缓存与数据库不一致，<strong>数据不一致就是问题</strong></p><p><font color="red">第四种情况：先更新数据库，后更新缓存</font></p><p>跟第三种情况一样</p><h2 id="单主更新缓存"><a href="#单主更新缓存" class="headerlink" title="单主更新缓存"></a>单主更新缓存</h2><p>虽然，看上去好像都有问题，但是，<strong>任何脱离实际业务的设计都是耍流氓</strong></p><p>既然我们把Redis当缓存，那么所有数据都要以数据库为准，像上面第二种情况（缓存中有的数据在数据库中没有）是不能容忍的，而对于第一种情况，可以采取双删的策略（删除缓存 –&gt; 更新数据库 –&gt; 再删除缓存），后面两种情况，可以用定时任务进行补偿，有些场景下我们是可以接受不一致的情况的。</p><p>不过，话又说回来，直接删除缓存当然是最简单的，它相当于延迟加载（第一次使用的时候发现没有才会去从数据库加载），这样可能导致第一次请求会比较慢；而采用修改缓存的方式，相当于预先加载。</p><p>在实际使用的时候，可以采用这两种方式：</p><ol><li>先删除缓存，再更新数据库，最后再删一次</li><li>先更新数据库，然后向MQ发一条消息，由专门的缓存服务去更新数据</li></ol><p><strong>上面说的是只有一个数据库实例的情况</strong>，而实际生产过程中肯定是一主多从的</p><h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><p>延时双删的方案的思路是，为了避免更新数据库的时候，其他线程从缓存中读取不到数据，就在更新完数据库之后，再sleep一段时间，然后再次删除缓存。</p><p>sleep的时间要对业务读写缓存的时间做出评估，sleep时间大于读写缓存的时间即可。</p><p>流程如下：</p><ol><li>线程1删除缓存，然后去更新数据库</li><li>线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存</li><li>线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除</li><li>如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值</li></ol><p><img src="/2020/12/23/Redis%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E6%9B%B4%E6%96%B0redis.png" alt="图片"></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。</p><p><img src="/2020/12/23/Redis%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98.png"></p><p>这个解决方案其实问题更多。</p><ol><li>引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦</li><li>就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的</li></ol><h3 id="进阶版消息队列"><a href="#进阶版消息队列" class="headerlink" title="进阶版消息队列"></a>进阶版消息队列</h3><p>为了解决缓存一致性的问题单独引入一个消息队列，太复杂了。</p><p>其实，一般大公司本身都会有监听binlog消息的消息队列存在，主要是为了做一些核对的工作。</p><p>这样，我们可以借助监听binlog的消息队列来做删除缓存的操作。这样做的好处是，不用你自己引入，侵入到你的业务代码中，中间件帮你做了解耦，同时，中间件的这个东西本身就保证了高可用。</p><p>当然，这样消息延迟的问题依然存在，但是相比单纯引入消息队列的做法更好一点。</p><p>而且，如果并发不是特别高的话，这种做法的实时性和一致性都还算可以接受的。</p><p><img src="/2020/12/23/Redis%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/binlog%E7%9B%91%E5%90%AC%E6%9B%B4%E6%96%B0redis.png" alt="图片"></p><h3 id="设置缓存过期时间-不建议"><a href="#设置缓存过期时间-不建议" class="headerlink" title="设置缓存过期时间(不建议)"></a>设置缓存过期时间(不建议)</h3><p>每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。</p><p>如果对于一致性要求不是很高的情况，可以采用这种方案。</p><p>这个方案还会有另外一个问题，就是如果数据更新的特别频繁，不一致性的问题就很大了。</p><p>在实际生产中，我们有一些活动的缓存数据是使用这种方式处理的。</p><p>因为活动并不频繁发生改变，而且对于活动来说，短暂的不一致性并不会有什么大的问题。</p><h2 id="主从更新缓存"><a href="#主从更新缓存" class="headerlink" title="主从更新缓存"></a>主从更新缓存</h2><p>按照<strong>写主读从</strong>，缓存加载数据的时候应该从从库中读，而本来主从同步就有延迟，于是读从库很有可能读到的是旧数据</p><p>为了解决这种问题，可以考虑以下几种方案：</p><p><font color="red">第一种：强制缓存读主数据库</font></p><p>这样一来，就不必考虑主从同步的问题了，可行（PS：跟微信公众号开发的时候获取Token一样）</p><p><font color="red">第二种：选择性地读主数据库</font></p><p>之所以强制读主库，是因为再主从同步完成之前从库中的数据还是旧的，当主从同步完成后再读从库就没什么问题了，那么如果在主从同步的这段时间内如果没有请求读这个KEY就没有问题，如果这段时间内有请求读取这个KEY，那么在同步完成后要删除这个KEY</p><p>如何判断在主从同步这段时间内有没有请求读取这个KEY呢？</p><p>在更新数据库的时候，往缓存中设置一个KEY，格式是：缓存KEY+业务数据ID，其生存时间是主从延时时间</p><p>比如，假设主从同步延时是3秒，而有业务缓存KEY是hash类型的，更新的这条数据的ID是213，那么在更新数据库后要立即设置 set USER_213_KV 1 3</p><p>在读的时候，首先判断缓存中有没有这样一个KEY，如果有则从主库中重新加载数据到缓存，没有，则直接从从库中加载数据到缓存</p><p><font color="red">第三种：订阅从库的binlog</font></p><p>可以通过工具（比如，canal）订阅从库的binlog，这是比较准确的，从库数据有更新，则立即更新缓存<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p><h2 id="为什么是删除，而不是更新缓存？"><a href="#为什么是删除，而不是更新缓存？" class="headerlink" title="为什么是删除，而不是更新缓存？"></a>为什么是删除，而不是更新缓存？</h2><p>我们以<strong>先更新数据库，再删除缓存</strong>来举例。</p><p>如果是更新的话，那就是<strong>先更新数据库，再更新缓存</strong>。</p><p>举个例子：如果数据库1小时内更新了1000次，那么缓存也要更新1000次，但是这个缓存可能在1小时内只被读取了1次，那么这1000次的更新有必要吗？</p><p>反过来，如果是删除的话，就算数据库更新了1000次，那么也只是做了1次缓存删除，只有当缓存真正被读取的时候才去数据库加载。</p><h2 id="补充1：缓存穿透"><a href="#补充1：缓存穿透" class="headerlink" title="补充1：缓存穿透"></a>补充1：缓存穿透</h2><p><font color="red">缓存穿透</font></p><p>缓存穿透，指的是查询一个数据库中不存在的数据。这样的话，每次都会查询数据库，相当于缓存就没有用了。</p><ul><li>针对这种情况，可以缓存空值，并设置一个较短的生存时间，比如60秒。</li><li>使用布隆过滤器，存在的时候保存；有一个错误率，并且不能删除，可以使用带计数器的布隆过滤器。</li></ul><p><font color="red">缓存雪崩</font></p><p>缓存雪崩，指的是大量缓存在一段时间内集体失效。这样的话，短时间内大量请求会直接打到数据库。</p><p>针对这种情况，可以在缓存的生存时间后面再加上一个随机数，这样的话就不至于同一时刻集体过期。实际上，因为大量缓存失效意味着这些缓存在同一时刻被设置的，而这种情况不多见。</p><p><font color="red">缓存击穿</font></p><p>缓存击穿，指的是单个缓存在被高并发访问时失效了导致请求全部打到数据库。</p><p>针对这种情况，在加载缓存的时候要加分布式锁。</p><h2 id="补充2：Redis客户端工具Medis"><a href="#补充2：Redis客户端工具Medis" class="headerlink" title="补充2：Redis客户端工具Medis"></a>补充2：Redis客户端工具Medis</h2><p><a href="https://github.com/luin/medis">https://github.com/luin/medis</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;luin&#x2F;medis.git</span><br><span class="line">cd medis</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p><img src="/2020/12/23/Redis%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/874963-20190422192347253-2059999245.png" alt="img"></p><p><img src="/2020/12/23/Redis%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/874963-20190422192359546-1385109275.png" alt="img"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/cjsblog/p/10752245.html">https://www.cnblogs.com/cjsblog/p/10752245.html</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247488185&idx=1&sn=f07ee035bc8c276e4d72b4ffb9627e1e&chksm=c2b25a44f5c5d3523985e4161e42ae0d1b4c8273915760d3ec53afbbd5fe0066178d5ade1673&scene=132#wechat_redirect">缓存一致性问题怎么解决</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis之数据结构</title>
      <link href="2020/12/23/Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/23/Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis之基础</title>
      <link href="2020/12/23/Redis%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
      <url>2020/12/23/Redis%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT之简单使用</title>
      <link href="2020/12/22/MQTT%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/22/MQTT%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MQTT-Java-客户端库"><a href="#MQTT-Java-客户端库" class="headerlink" title="MQTT Java 客户端库"></a>MQTT Java 客户端库</h1><p><a href="https://www.eclipse.org/paho/clients/java/">Eclipse Paho Java Client (opens new window)</a>是用 Java 编写的 MQTT 客户端库（MQTT Java Client），可用于 JVM 或其他 Java 兼容平台（例如Android）。</p><p>Eclipse Paho Java Client 提供了MqttAsyncClient 和 MqttClient 异步和同步 API。</p><h2 id="通过-Maven-安装-Paho-Java"><a href="#通过-Maven-安装-Paho-Java" class="headerlink" title="通过 Maven 安装 Paho Java"></a>通过 Maven 安装 Paho Java</h2><p>通过包管理工具 Maven 可以方便地安装 Paho Java 客户端库，截止目前最新版本安装如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.paho<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.paho.client.mqttv3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Paho-Java-使用示例"><a href="#Paho-Java-使用示例" class="headerlink" title="Paho Java 使用示例"></a>Paho Java 使用示例</h2><p>Java 体系中 Paho Java 是比较稳定、广泛应用的 MQTT 客户端库，本示例包含 Java 语言的 Paho Java 连接 EMQ X Broker，并进行消息收发完整代码：</p><p><strong>App.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.emqx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttClient;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttConnectOptions;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttException;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String subTopic = <span class="string">&quot;testtopic/#&quot;</span>;</span><br><span class="line">        String pubTopic = <span class="string">&quot;testtopic/1&quot;</span>;</span><br><span class="line">        String content = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> qos = <span class="number">2</span>;</span><br><span class="line">        String broker = <span class="string">&quot;tcp://broker.emqx.io:1883&quot;</span>;</span><br><span class="line">        String clientId = <span class="string">&quot;emqx_test&quot;</span>;</span><br><span class="line">        MemoryPersistence persistence = <span class="keyword">new</span> MemoryPersistence();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MqttClient client = <span class="keyword">new</span> MqttClient(broker, clientId, persistence);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MQTT 连接选项</span></span><br><span class="line">            MqttConnectOptions connOpts = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">            connOpts.setUserName(<span class="string">&quot;emqx_test&quot;</span>);</span><br><span class="line">            connOpts.setPassword(<span class="string">&quot;emqx_test_password&quot;</span>.toCharArray());</span><br><span class="line">            <span class="comment">// 保留会话</span></span><br><span class="line">            connOpts.setCleanSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置回调</span></span><br><span class="line">            client.setCallback(<span class="keyword">new</span> PushCallback());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Connecting to broker: &quot;</span> + broker);</span><br><span class="line">            client.connect(connOpts);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Connected&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Publishing message: &quot;</span> + content);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 订阅</span></span><br><span class="line">            client.subscribe(subTopic);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息发布所需参数</span></span><br><span class="line">            MqttMessage message = <span class="keyword">new</span> MqttMessage(content.getBytes());</span><br><span class="line">            message.setQos(qos);</span><br><span class="line">            client.publish(pubTopic, message);</span><br><span class="line">            System.out.println(<span class="string">&quot;Message published&quot;</span>);</span><br><span class="line"></span><br><span class="line">            client.disconnect();</span><br><span class="line">            System.out.println(<span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">            client.close();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MqttException me) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;reason &quot;</span> + me.getReasonCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;msg &quot;</span> + me.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;loc &quot;</span> + me.getLocalizedMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;cause &quot;</span> + me.getCause());</span><br><span class="line">            System.out.println(<span class="string">&quot;excep &quot;</span> + me);</span><br><span class="line">            me.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回调消息处理类 OnMessageCallback.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.emqx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttCallback;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnMessageCallback</span> <span class="keyword">implements</span> <span class="title">MqttCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionLost</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 连接丢失后，一般在这里面进行重连</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开，可以做重连&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageArrived</span><span class="params">(String topic, MqttMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// subscribe后得到的消息会执行到这里面</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息主题:&quot;</span> + topic);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息Qos:&quot;</span> + message.getQos());</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息内容:&quot;</span> + <span class="keyword">new</span> String(message.getPayload()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliveryComplete</span><span class="params">(IMqttDeliveryToken token)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;deliveryComplete---------&quot;</span> + token.isComplete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Paho-Java-MQTT-5-0-支持"><a href="#Paho-Java-MQTT-5-0-支持" class="headerlink" title="Paho Java MQTT 5.0 支持"></a>Paho Java MQTT 5.0 支持</h2><p>目前 Paho Java 还在适配 MQTT 5.0，尚未全面支持。</p><h2 id="离线数据"><a href="#离线数据" class="headerlink" title="离线数据"></a>离线数据</h2><p>满足以下条件：</p><ul><li>发布和订阅客户端的clientId必须一样，必须自己设置。如果不设置，emqtt服务端会自动产生一个唯一的id。</li><li>发布和订阅客户端setCleanSession(false);不清除session</li><li>客户端的QoS &gt;= 1</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> EMQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT之Qos详解</title>
      <link href="2020/12/22/MQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/22/MQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://www.zhihu.com/people/zero-50-79">程序锅</a><br>出处：<a href="https://zhuanlan.zhihu.com/p/80203905">https://zhuanlan.zhihu.com/p/80203905</a></p><h2 id="1-MQTT中的QoS等级"><a href="#1-MQTT中的QoS等级" class="headerlink" title="1. MQTT中的QoS等级"></a>1. MQTT中的QoS等级</h2><p>MQTT设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次QoS（Quality of Service）：</p><ul><li>QoS0，At most once，至多一次；</li><li>QoS1，At least once，至少一次；</li><li>QoS2，Exactly once，确保只有一次。</li></ul><p>QoS 是消息的发送方（Sender）和接受方（Receiver）之间达成的一个协议：</p><ul><li>QoS0 代表，Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了；</li><li>QoS1 代表，Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息；</li><li>QoS2 代表，Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。</li></ul><blockquote><p>注意：<br>QoS是Sender和Receiver之间的协议，而不是Publisher和Subscriber之间的协议。换句话说，Publisher发布了一条QoS1的消息，只能保证Broker能至少收到一次这个消息；而对于Subscriber能否至少收到一次这个消息，还要取决于Subscriber在Subscibe的时候和Broker协商的QoS等级。</p></blockquote><h3 id="1-1-QoS0"><a href="#1-1-QoS0" class="headerlink" title="1.1. QoS0"></a>1.1. QoS0</h3><p>QoS0等级下，Sender和Receiver之间一次消息的传递流程如下：</p><p><img src="/2020/12/22/MQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-c707d4103db77637e352e20f445f728c_r.jpg" alt="preview"></p><p>Sender向Receiver发送一个包含消息数据的PUBLISH包，然后不管结果如何，丢掉已发送的PUBLISH包，一条消息的发送完成。</p><h3 id="1-2-QoS1"><a href="#1-2-QoS1" class="headerlink" title="1.2. QoS1"></a>1.2. QoS1</h3><p>QoS1要保证消息至少到达一次，所以有一个应答的机制。Sender和Receiver的一次消息的传递流程如下：</p><p><img src="/2020/12/22/MQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-600d6162bdb9e17430437ce58bfcda8f_720w.jpg" alt="img"></p><ol><li>Sender向Receiver发送一个带有数据的PUBLISH包，并在本地保存这个PUBLISH包；</li><li>Receiver收到PUBLISH包以后，向Sender发送一个PUBACK数据包，PUBACK数据包没有消息体（Payload），在可变头中有一个包标识（Packet Identifier），和它收到的PUBLISH包中的Packet Identifier一致。</li><li>Sender收到PUBACK之后，根据PUBACK包中的Packet Identifier找到本地保存的PUBLISH包，然后丢弃掉，一次消息的发送完成。</li></ol><p>但是消息传递流程中可能会出现问题：</p><ul><li>如果Sender在一段时间内没有收到PUBLISH包对应的PUBACK，它将该PUBLISH包的DUP标识设为1（代表是重新发送的PUBLISH包），然后重新发送该PUBLISH包。</li><li>Receiver可能会重复收到消息，需自行去重。</li></ul><h3 id="1-3-QoS2"><a href="#1-3-QoS2" class="headerlink" title="1.3. QoS2"></a>1.3. QoS2</h3><p>相比QoS0和QoS1,QoS2不仅要确保Receiver能收到Sender发送的消息，还需要确保消息不重复。它的重传和应答机制就要复杂一些，同时开销也是最大的。QoS2下，一次消息的传递流程如下所示：</p><p><img src="/2020/12/22/MQTT%E4%B9%8BQos%E8%AF%A6%E8%A7%A3/v2-f9be4b4af808507942cad20984b1d0d8_720w.jpg" alt="img"></p><ol><li>Sender发送QoS为2的PUBLISH数据包，数据包 Packet Identifier 为 P，并在本地保存该PUBLISH包；</li><li>Receiver收到PUBLISH数据包后，<strong>在本地保存PUBLISH包的Packet Identifier P</strong>，并回复Sender一个PUBREC数据包，PUBREC数据包可变头中的Packet Identifier为P，没有消息体（Payload）；</li><li>当Sender收到PUBREC，它就可以安全的丢弃掉初始Packet Identifier为P的PUBLISH数据包。同时保存该PUBREC数据包，并回复Receiver一个PUBREL数据包，PUBREL数据包可变头中的Packet Identifier为P，没有消息体；</li><li>当Receiver收到PUBREL数据包，它可以丢掉保存的PUBLISH包的Packet Identifier P，并回复Sender一个可变头中 Packet Identifier 为 P，没有消息体（Payload）的PUBCOMP数据包；</li><li>当Sender收到PUBCOMP包，那么认为传输已完成，则丢掉对应的PUBREC数据包；</li></ol><p>上面是一次完整无误的传输过程，然而传输过程中可能会出现以下情况：</p><ul><li>情况1：Sender发送PUBLISH数据包给Receiver的时候，发送失败；</li><li>情况2：Sender已经成功发送PUBLISH数据包给Receiver了，但是Receiver发送PUBREC数据包失败；</li><li>情况3：Sender已经成功收到了PUBREC数据包，但是PUBREL数据包发送失败；</li><li>情况4：Receiver已经收到了PUBREL数据包，但是发送PUBCOMP数据包时发送失败</li></ul><p>针对上述的问题，较为详细的处理方法如下：</p><ul><li>不管是情况1还是情况2，因为Sender在一定时间内没有收到PUBREC，那么它会把PUBLISH包的DUP标识设为1，重新发送该PUBLISH数据包；</li><li>不管是情况3还是情况4，因为Sender在一定时间内没有收到PUBCOMP包，那么它会重新发送PUBREL数据包；</li><li>针对情况2，Receiver可能会收到多个重复的PUBLISH包，更加完善的处理如下：<br>Receiver在收到PUBLISH数据包之后，马上回复一个PUBREC数据包。并会在本地保存PUBLISH包的Packet Identifier P，不管之后因为重传多少次这个Packet Identifier 为P的数据包，Receiver都认为是重复的，丢弃。同时Receiver接收到QoS为2的PUBLISH数据包后，<strong>并不马上投递给上层，</strong>而是在本地做持久化，将消息保存起来（这里需要是持久化而不是保存在内存）。</li><li>针对情况4，更加完善的处理如下：<br>Receiver收到PUBREL数据包后，正式将消息递交给上层应用层，投递之后销毁Packet Identifier P，并发送PUBCOMP数据包，销毁之前的持久化消息。之后不管接收到多少个PUBREL数据包，因为没有Packet Identifier P，直接回复PUBCOMP数据包即可。</li></ul><h2 id="2-QoS降级"><a href="#2-QoS降级" class="headerlink" title="2. QoS降级"></a>2. QoS降级</h2><p>在 MQTT 协议中，从 Broker 到 Subscriber 这段消息传递的实际 QoS 等于：Publisher 发布消息时指定的 QoS 等级和 Subscriber 在订阅时与 Broker 协商的 QoS 等级，这两个 QoS 等级中的最小那一个。</p><blockquote><p><strong>Actual Subscribe QoS = MIN(Publish QoS, Subscribe QoS)</strong></p></blockquote><p>如下面代码所示：</p><p>该subscriber订阅消息时指定的QoS为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当代理响应订阅请求时被调用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_subscribe</span>(<span class="params">client, userdata, mid, granted_qos</span>):</span></span><br><span class="line">    print(<span class="string">&quot;granted_qos:&quot;</span>, granted_qos)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当收到关于客户订阅的主题的消息时调用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">client, userdata, message</span>):</span></span><br><span class="line">    print(<span class="string">&quot;message qos&quot;</span>, message.qos)</span><br><span class="line">    print(<span class="string">&quot;message topic&quot;</span>, message.topic)</span><br><span class="line">    print(<span class="string">&quot;message payload&quot;</span>, message.payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span></span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span> :</span><br><span class="line">        print(<span class="string">&quot;subscribing&quot;</span>)</span><br><span class="line">        client.subscribe(<span class="string">&quot;test&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;connection failed &quot;</span>, rc)</span><br><span class="line"></span><br><span class="line">mqtt_client = mqtt.Client(client_id=<span class="string">&quot;demo_mqtt_sub&quot;</span>, clean_session=<span class="literal">False</span>)</span><br><span class="line">mqtt_client.on_connect = on_connect</span><br><span class="line">mqtt_client.on_subscribe = on_subscribe</span><br><span class="line">mqtt_client.on_message = on_message</span><br><span class="line"></span><br><span class="line">mqtt_client.connect(<span class="string">&quot;192.168.10.239&quot;</span>, <span class="number">1883</span>)</span><br><span class="line">mqtt_client.loop_forever()</span><br></pre></td></tr></table></figure><p>运行上述代码输出的结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscribing</span><br><span class="line">granted_qos: (1,)</span><br></pre></td></tr></table></figure><p>之后运行下面的publisher代码，指定发送的PUBLISH数据包的QoS等级为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span></span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span>:</span><br><span class="line">        client.publish(<span class="string">&quot;test&quot;</span>, payload=<span class="string">&quot;hello world&quot;</span>, qos=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;connection failed &quot;</span>, rc)</span><br><span class="line"></span><br><span class="line">mqtt_client = mqtt.Client(client_id=<span class="string">&quot;demo_mqtt_pub&quot;</span>, clean_session=<span class="literal">False</span>)</span><br><span class="line">mqtt_client.on_connect = on_connect</span><br><span class="line"></span><br><span class="line">mqtt_client.connect(<span class="string">&quot;192.168.10.239&quot;</span>, <span class="number">1883</span>)</span><br><span class="line">mqtt_client.loop_forever()</span><br></pre></td></tr></table></figure><p>结果上面运行subscriber代码的终端输出如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message qos 0</span><br><span class="line">message topic <span class="built_in">test</span></span><br><span class="line">message payload b<span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><p>上述的结果表示，订阅者收到的消息的qos等级为0。同样如果修改subscriber中的订阅主题的QoS等级为0，publisher中发布的PUBLISH包的QoS为1，那么输出结果同上。</p><h2 id="3-QoS和会话"><a href="#3-QoS和会话" class="headerlink" title="3. QoS和会话"></a>3. QoS和会话</h2><p>如果 Client 想接收离线消息，必须使用持久化的会话（Clean Session = 0）连接到 Broker，这样 Broker 才会存储 Client 在离线期间没有确认接收的 QoS 大于 等于1 的消息。</p><blockquote><p>在发送QoS为1或2的情况，Broker（此时为Sender）会将发送的PUBLISH数据包保存到本地，直到收到一系列回复的数据包，然而Client（此时为Receiver）在离线期间无法回复相应的数据包，所以会一直存储。</p></blockquote><h2 id="4-QoS等级使用建议"><a href="#4-QoS等级使用建议" class="headerlink" title="4. QoS等级使用建议"></a>4. QoS等级使用建议</h2><p><strong>在以下情况下你可以选择 QoS0</strong>：</p><ul><li>Client 和 Broker 之间的网络连接非常稳定，例如一个通过有线网络连接到 Broker 的测试用 Client；</li><li>可以接受丢失部分消息，比如你有一个传感器以非常短的间隔发布状态数据，所以丢一些也可以接受；</li><li>你不需要离线消息。</li></ul><p><strong>在以下情况下你应该选择 QoS1：</strong></p><ul><li>你需要接收所有的消息，而且你的应用可以接受并处理重复的消息；</li><li>你无法接受 QoS2 带来的额外开销，QoS1 发送消息的速度比 QoS2 快很多。</li></ul><p><strong>在以下情况下你应该选择 QoS2：</strong></p><ul><li>你的应用必须接收到所有的消息，而且你的应用在重复的消息下无法正常工作，同时你也能接受 QoS2 带来的额外开销。</li></ul><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a><strong>本文参考</strong></h2><ol><li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/zerooffdate/article/details/78950907">MQTT协议QoS2 准确一次送达的实现</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> EMQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql之索引</title>
      <link href="2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
      <url>2020/12/22/mysql%E4%B9%8B%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>MySQL索引方法</p><ul><li>Hash （对于指定值查询很快，能直接定位，但是范围查询无效）</li><li>B+树 （提升查询效率）</li></ul><p>MySQL索引类型</p><ul><li>聚簇索引（clustered index ）</li><li>非聚簇索引（secondary index）</li></ul><p>​    InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p><p>​    MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p><p>InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。并且和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql之存储引擎</title>
      <link href="2020/12/22/mysql%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>2020/12/22/mysql%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>MySQL 有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</span><br></pre></td></tr></table></figure><p>MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎：</p><ul><li><p><strong>MyISAM</strong>管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。</p></li><li><p><strong>MEMORY</strong>存储引擎提供”内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中。</p><p>注释：MEMORY存储引擎正式地被确定为HEAP引擎。</p></li><li><p><strong>InnoDB</strong>和BDB存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎。</p></li><li><p><strong>EXAMPLE</strong>存储引擎是一个”存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。</p></li><li><p><strong>NDB Cluster</strong>是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows。</p></li><li><p><strong>ARCHIVE</strong>存储引擎被用来无索引地，非常小地覆盖存储的大量数据。</p></li><li><p><strong>CSV</strong>存储引擎把数据以逗号分隔的格式存储在文本文件中。</p></li><li><p><strong>BLACKHOLE</strong>存储引擎接受但不存储数据，并且检索总是返回一个空集。</p></li><li><p><strong>FEDERATED</strong>存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动器或客户端连接方法连接到另外的数据源。</p></li></ul><h2 id="比较常用的是-MyISAM-和-InnoBD"><a href="#比较常用的是-MyISAM-和-InnoBD" class="headerlink" title="比较常用的是 MyISAM 和 InnoBD"></a>比较常用的是 MyISAM 和 InnoBD</h2><table><thead><tr><th></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td><strong>构成上的区别：</strong></td><td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。  <br>     .frm文件存储表定义。   <br>     数据文件的扩展名为.MYD (MYData)。    <br>     索引文件的扩展名是.MYI (MYIndex)。</td><td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td></tr><tr><td><strong>事务处理上方面:</strong></td><td>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持</td><td>InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能</td></tr><tr><td><strong>SELECT  UPDATE,INSERT，Delete操作</strong></td><td>如果执行大量的SELECT，MyISAM是更好的选择</td><td><strong>1.**如果你的数据执行大量的</strong>INSERT<strong>或</strong>UPDATE<strong>，出于性能方面的考虑，应该使用InnoDB表   **2.DELETE  FROM table</strong>时，InnoDB不会重新建立表，而是一行一行的删除。   <strong>3.LOAD  TABLE FROM MASTER</strong>操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用</td></tr><tr><td><strong>对AUTO_INCREMENT的操作</strong></td><td>每表一个AUTO_INCREMEN列的内部处理。   <strong>MyISAM为INSERT和UPDATE操作自动更新这一列</strong>。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。   AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置   对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引   更好和更快的auto_increment处理</td><td>如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。   自动增长计数器仅被存储在主内存中，而不是存在磁盘上   关于该计算器的算法实现，请参考   <strong>AUTO_INCREMENT列在InnoDB里如何工作</strong></td></tr><tr><td><strong>表的具体行数</strong></td><td>select count(<em>) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(</em>)语句包含  where条件时，两种表的操作是一样的</td><td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行</td></tr><tr><td><strong>锁</strong></td><td>表锁</td><td>提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in   SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%”</td></tr></tbody></table><h2 id="MySQL-存储引擎-MyISAM-与-InnoDB-如何选择？"><a href="#MySQL-存储引擎-MyISAM-与-InnoDB-如何选择？" class="headerlink" title="MySQL 存储引擎 MyISAM 与 InnoDB 如何选择？"></a>MySQL 存储引擎 MyISAM 与 InnoDB 如何选择？</h2><p>虽然 MySQL 里的存储引擎不只是 MyISAM 与 InnoDB 这两个，但常用的就是它俩了。可能有站长并未注意过 MySQL 的存储引擎，其实存储引擎也是数据库设计里的一大重要点，那么博客系统应该使用哪种存储引擎呢？</p><p>下面我们分别来看两种存储引擎的区别。</p><ul><li>一、InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</li><li>二、MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</li><li>三、InnoDB支持外键，MyISAM不支持</li><li>四、MyISAM是默认引擎，InnoDB需要指定</li><li>五、InnoDB不支持FULLTEXT类型的索引</li><li>六、InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表</li><li>七、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引</li><li>八、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表</li><li>九、InnoDB支持行锁（某些情况下还是锁整表，如 <strong>update table set a=1 where user like ‘%lee%’</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT之基础</title>
      <link href="2020/12/22/MQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
      <url>2020/12/22/MQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>出处：<a href="https://www.runoob.com/w3cnote/mqtt-intro.html">MQTT 入门介绍</a></p><h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p><p><img src="/2020/12/22/MQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/mqtt-fidge-2.svg" alt="img"></p><hr><h2 id="二、设计规范"><a href="#二、设计规范" class="headerlink" title="二、设计规范"></a>二、设计规范</h2><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p><ul><li>（1）精简，不添加可有可无的功能；</li><li>（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</li><li>（3）允许用户动态创建主题，零运维成本；</li><li>（4）把传输量降到最低以提高传输效率；</li><li>（5）把低带宽、高延迟、不稳定的网络等因素考虑在内；</li><li>（6）支持连续的会话控制；</li><li>（7）理解客户端计算能力可能很低；</li><li>（8）提供服务质量管理；</li><li>（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li></ul><hr><h2 id="三、主要特性"><a href="#三、主要特性" class="headerlink" title="三、主要特性"></a>三、主要特性</h2><p>MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p><ul><li><p>（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</p><p>这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</p></li><li><p>（2）对负载内容屏蔽的消息传输。</p></li><li><p>（3）使用TCP/IP提供网络连接。</p><p>主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</p></li><li><p>（4）有三种消息发布服务质量：</p><p>“至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p><p>“至少一次”，确保消息到达，但消息重复可能会发生。</p><p>“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</p></li><li><p>（5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。</p><p>这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</p></li><li><p>（6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。</p><p>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</p><p>Testament：遗嘱机制，功能类似于Last Will。</p></li></ul><hr><h2 id="四、MQTT协议原理"><a href="#四、MQTT协议原理" class="headerlink" title="四、MQTT协议原理"></a>四、MQTT协议原理</h2><h3 id="4-1-MQTT协议实现方式"><a href="#4-1-MQTT协议实现方式" class="headerlink" title="4.1 MQTT协议实现方式"></a>4.1 MQTT协议实现方式</h3><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p><p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p><ul><li>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li><li>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li></ul><h3 id="4-2-网络传输与应用消息"><a href="#4-2-网络传输与应用消息" class="headerlink" title="4.2 网络传输与应用消息"></a>4.2 网络传输与应用消息</h3><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p><p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p><h3 id="4-3-MQTT客户端"><a href="#4-3-MQTT客户端" class="headerlink" title="4.3 MQTT客户端"></a>4.3 MQTT客户端</h3><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p><ul><li>（1）发布其他客户端可能会订阅的信息；</li><li>（2）订阅其它客户端发布的消息；</li><li>（3）退订或删除应用程序的消息；</li><li>（4）断开与服务器连接。</li></ul><h3 id="4-4-MQTT服务器"><a href="#4-4-MQTT服务器" class="headerlink" title="4.4 MQTT服务器"></a>4.4 MQTT服务器</h3><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p><ul><li>（1）接受来自客户的网络连接；</li><li>（2）接受客户发布的应用信息；</li><li>（3）处理来自客户端的订阅和退订请求；</li><li>（4）向订阅的客户转发应用程序消息。</li></ul><h3 id="4-5-MQTT协议中的订阅、主题、会话"><a href="#4-5-MQTT协议中的订阅、主题、会话" class="headerlink" title="4.5 MQTT协议中的订阅、主题、会话"></a>4.5 MQTT协议中的订阅、主题、会话</h3><p><strong>一、订阅（Subscription）</strong></p><p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p><p><strong>二、会话（Session）</strong></p><p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p><p><strong>三、主题名（Topic Name）</strong></p><p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p><p><strong>四、主题筛选器（Topic Filter）</strong></p><p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p><p><strong>五、负载（Payload）</strong></p><p>消息订阅者所具体接收的内容。</p><h3 id="4-6-MQTT协议中的方法"><a href="#4-6-MQTT协议中的方法" class="headerlink" title="4.6 MQTT协议中的方法"></a>4.6 MQTT协议中的方法</h3><p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p><ul><li>（1）Connect。等待与服务器建立连接。</li><li>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li><li>（3）Subscribe。等待完成订阅。</li><li>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li><li>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li></ul><hr><h2 id="五、MQTT协议数据包结构"><a href="#五、MQTT协议数据包结构" class="headerlink" title="五、MQTT协议数据包结构"></a>五、MQTT协议数据包结构</h2><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p><ul><li>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</li><li>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</li><li>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</li></ul><h3 id="5-1-MQTT固定头"><a href="#5-1-MQTT固定头" class="headerlink" title="5.1 MQTT固定头"></a>5.1 MQTT固定头</h3><p>固定头存在于所有MQTT数据包中，其结构如下：</p><p><strong>5.1.1 MQTT数据包类型</strong></p><p>位置：Byte 1中bits 7-4。</p><p>相于一个4位的无符号值，类型、取值及描述如下：</p><p><strong>5.1.2 标识位</strong></p><p>位置：Byte 1中bits 3-0。</p><p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p><p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p><p>（2）QoS：发布消息的服务质量，即：保证消息传递的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ø00：最多一次，即：&lt;&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø01：至少一次，即：&gt;&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø10：一次，即：&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø11：预留</span><br></pre></td></tr></table></figure><p>（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。 5.1.3 剩余长度（Remaining Length）</p><p>地址：Byte 2。</p><p>固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0</p><h3 id="5-2-MQTT可变头"><a href="#5-2-MQTT可变头" class="headerlink" title="5.2 MQTT可变头"></a>5.2 MQTT可变头</h3><p>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p><p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p><h3 id="5-3-Payload消息体"><a href="#5-3-Payload消息体" class="headerlink" title="5.3 Payload消息体"></a>5.3 Payload消息体</h3><p>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：</p><ul><li>（1）CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</li><li>（2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</li><li>（3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</li><li>（4）UNSUBSCRIBE，消息体内容是要订阅的主题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> EMQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之Seata简单使用</title>
      <link href="2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>作者：程序员内点事<br>链接：<a href="https://juejin.cn/post/6899645923024355336">https://juejin.cn/post/6899645923024355336</a></p><h2 id="分布式事务由来"><a href="#分布式事务由来" class="headerlink" title="分布式事务由来"></a>分布式事务由来</h2><p>当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1ec31a8cda8745c9bf7793b7bd092616~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="分库分表、SOA"><a href="#分库分表、SOA" class="headerlink" title="分库分表、SOA"></a>分库分表、SOA</h3><p>可随着业务量的不断增长，单体架构渐渐扛不住巨大的流量，此时就需要对数据库、表做 <code>分库分表</code>处理，将应用 <code>SOA</code> 服务化拆分。也就产生了订单中心、用户中心、库存中心等，由此带来的问题就是业务间相互隔离，每个业务都维护着自己的数据库，数据的交换只能进行 <code>RPC</code> 调用。</p><p>当用户再次下单时，需同时对订单库 <code>order</code>、库存库 <code>storage</code>、用户库 <code>account</code> 进行操作，可此时我们只能保证自己本地的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7d920f9dedcf454faa0b9313bd17df43~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="Seata-优势"><a href="#Seata-优势" class="headerlink" title="Seata 优势"></a>Seata 优势</h2><p>实现分布式事务的方案比较多，常见的比如基于 <code>XA</code> 协议的 <code>2PC</code>、<code>3PC</code>，基于业务层的 <code>TCC</code>，还有应用消息队列 + 消息表实现的最终一致性方案，还有今天要说的 <code>Seata</code> 中间件，下边看看各个方案的优缺点。</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a><code>2PC</code></h3><p>基于 XA 协议实现的分布式事务，XA 协议中分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如 Oracle、MYSQL 这些数据库都实现了 XA 接口，而事务管理器则作为一个全局的调度者。</p><p>两阶段提交（<code>2PC</code>），对业务侵⼊很小，它最⼤的优势就是对使⽤⽅透明，用户可以像使⽤本地事务⼀样使⽤基于 XA 协议的分布式事务，能够严格保障事务 ACID 特性。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5d98e869a3d14c9da4ff308899222309~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可 <code>2PC</code>的缺点也是显而易见，它是一个强一致性的同步阻塞协议，事务执⾏过程中需要将所需资源全部锁定，也就是俗称的 <code>刚性事务</code>。所以它比较适⽤于执⾏时间确定的短事务，整体性能比较差。</p><p>一旦事务协调者宕机或者发生网络抖动，会让参与者一直处于锁定资源的状态或者只有一部分参与者提交成功，导致数据的不一致。因此，在⾼并发性能⾄上的场景中，基于 XA 协议的分布式事务并不是最佳选择。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/a34f0af5f47a4ea686dae570643a019e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a><code>3PC</code></h3><p>三段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一种改进版本 ，为解决两阶段提交协议的阻塞问题，上边提到两段提交，当协调者崩溃时，参与者不能做出最后的选择，就会一直保持阻塞锁定资源。</p><p><code>2PC</code> 中只有协调者有超时机制，<code>3PC</code> 在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。而且在第一阶段和第二阶段中又插入了一个准备阶段（如下图，看着有点啰嗦），保证了在最后提交阶段之前各参与节点的状态是一致的。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/08a0d09a1f684ac89d058ed599c5cb93~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>虽然 <code>3PC</code> 用超时机制，解决了协调者故障后参与者的阻塞问题，但与此同时却多了一次网络通信，性能上反而变得更差，也不太推荐。</p><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>所谓的 <code>TCC</code> 编程模式，也是两阶段提交的一个变种，不同的是 <code>TCC</code> 为在业务层编写代码实现的两阶段提交。<code>TCC</code> 分别指 <code>Try</code>、<code>Confirm</code>、<code>Cancel</code> ，一个业务操作要对应的写这三个方法。</p><p>以下单扣库存为例，<code>Try</code> 阶段去占库存，<code>Confirm</code> 阶段则实际扣库存，如果库存扣减失败 <code>Cancel</code> 阶段进行回滚，释放库存。</p><p>TCC 不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则 <code>Cancel</code> 来进行回滚补偿，这也就是常说的补偿性事务。</p><p>原本一个方法，现在却需要三个方法来支持，可以看到 TCC 对业务的侵入性很强，而且这种模式并不能很好地被复用，会导致开发量激增。还要考虑到网络波动等原因，为保证请求一定送达都会有重试机制，所以考虑到接口的幂等性。</p><h3 id="消息事务（最终一致性）"><a href="#消息事务（最终一致性）" class="headerlink" title="消息事务（最终一致性）"></a>消息事务（最终一致性）</h3><p>消息事务其实就是基于消息中间件的两阶段提交，将本地事务和发消息放在同一个事务里，保证本地操作和发送消息同时成功。 下单扣库存原理图：</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/55a8781c22844f1794a3edaadac37765~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>订单系统向 <code>MQ</code> 发送一条预备扣减库存消息，<code>MQ</code> 保存预备消息并返回成功 <code>ACK</code></li><li>接收到预备消息执行成功 <code>ACK</code>，订单系统执行本地下单操作，为防止消息发送成功而本地事务失败，订单系统会实现 <code>MQ</code> 的回调接口，其内不断的检查本地事务是否执行成功，如果失败则 <code>rollback</code> 回滚预备消息；成功则对消息进行最终 <code>commit</code> 提交。</li><li>库存系统消费扣减库存消息，执行本地事务，如果扣减失败，消息会重新投，一旦超出重试次数，则本地表持久化失败消息，并启动定时任务做补偿。</li></ul><p>基于消息中间件的两阶段提交方案，通常用在高并发场景下使用，牺牲数据的强一致性换取性能的大幅提升，不过实现这种方式的成本和复杂度是比较高的，还要看实际业务情况。</p><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p><code>Seata</code> 也是从两段提交演变而来的一种分布式事务解决方案，提供了 <code>AT</code>、<code>TCC</code>、<code>SAGA</code> 和 <code>XA</code> 等事务模式，这里重点介绍 <code>AT</code>模式。</p><p>既然 <code>Seata</code> 是两段提交，那我们看看它在每个阶段都做了点啥？下边我们还以下单扣库存、扣余额举例。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/f84a66ad84ea4db0bb3970d4a430a8df~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>先介绍 <code>Seata</code> 分布式事务的几种角色：</p><ul><li><code>Transaction Coordinator(TC)</code>:  全局事务协调者，用来协调全局事务和各个分支事务（不同服务）的状态， 驱动全局事务和各个分支事务的回滚或提交。</li><li><code>Transaction Manager™ </code>:  事务管理者，业务层中用来开启/提交/回滚一个整体事务（在调用服务的方法中用注解开启事务）。</li><li><code>Resource Manager(RM)</code>:  资源管理者，一般指业务数据库代表了一个分支事务（<code>Branch Transaction</code>），管理分支事务与 <code>TC</code> 进行协调注册分支事务并且汇报分支事务的状态，驱动分支事务的提交或回滚。</li></ul><blockquote><p>Seata 实现分布式事务，设计了一个关键角色 <code>UNDO_LOG</code> （回滚日志记录表），我们在每个应用分布式事务的业务库中创建这张表，这个表的核心作用就是，将业务数据在更新前后的数据镜像组织成回滚日志，备份在 <code>UNDO_LOG</code> 表中，以便业务异常能随时回滚。</p></blockquote><h3 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h3><p>比如：下边我们更新 <code>user</code> 表的 <code>name</code> 字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;小富最帅&#x27;</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;程序员内点事&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>首先 Seata 的 <code>JDBC</code> 数据源代理通过对业务 SQL 解析，提取 SQL 的元数据，也就是得到 SQL 的类型（<code>UPDATE</code>），表（<code>user</code>），条件（<code>where name = &#39;程序员内点事&#39;</code>）等相关的信息。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c78f6b5488ac4602acd18e3c9a978d5b~tplv-k3u1fbpfcp-zoom-1.image" alt="第一个阶段的流程图"></p><p>先查询数据前镜像，根据解析得到的条件信息，生成查询语句，定位一条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;程序员内点事&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c195e1ddd8fb4621a9b8ea35077f35ec~tplv-k3u1fbpfcp-zoom-1.image" alt="数据前镜像"></p><p>紧接着执行业务 SQL，根据前镜像数据主键查询出后镜像数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1b4c7bad77e9441a89e47f530ef505cb~tplv-k3u1fbpfcp-zoom-1.image" alt="数据后镜像"></p><p>把业务数据在更新前后的数据镜像组织成回滚日志，将业务数据的更新和回滚日志在同一个本地事务中提交，分别插入到业务表和 <code>UNDO_LOG</code> 表中。</p><p>回滚记录数据格式如下：包括 <code>afterImage</code> 前镜像、<code>beforeImage</code> 后镜像、 <code>branchId</code> 分支事务ID、<code>xid</code> 全局事务ID</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;branchId&quot;</span>:<span class="number">641789253</span>,</span><br><span class="line">    <span class="attr">&quot;xid&quot;</span>:<span class="string">&quot;xid:xxx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;undoItems&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;afterImage&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;rows&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;fields&quot;</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>:<span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>:<span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;tableName&quot;</span>:<span class="string">&quot;product&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;beforeImage&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;rows&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;fields&quot;</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>:<span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>:<span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;tableName&quot;</span>:<span class="string">&quot;product&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;sqlType&quot;</span>:<span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以保证，任何提交的业务数据的更新一定有相应的回滚日志。</p><blockquote><p>在本地事务提交前，各分支事务需向 <code>全局事务协调者</code> TC 注册分支 ( <code>Branch Id</code>) ，为要修改的记录申请 <strong>全局锁</strong> ，要为这条数据加锁，利用 <code>SELECT FOR UPDATE</code> 语句。而如果一直拿不到锁那就需要回滚本地事务。TM 开启事务后会生成全局唯一的 <code>XID</code>，会在各个调用的服务间进行传递。</p></blockquote><p>有了这样的机制，本地事务分支（<code>Branch Transaction</code>）便可以在全局事务的第一阶段提交，并马上释放本地事务锁定的资源。相比于传统的 <code>XA</code> 事务在第二阶段释放资源，<code>Seata</code> 降低了锁范围提高效率，即使第二阶段发生异常需要回滚，也可以快速 从<code>UNDO_LOG</code> 表中找到对应回滚数据并反解析成 SQL 来达到回滚补偿。</p><p>最后本地事务提交，业务数据的更新和前面生成的 UNDO LOG 数据一并提交，并将本地事务提交的结果上报给全局事务协调者 TC。</p><h3 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h3><p>第二阶段是根据各分支的决议做提交或回滚：</p><p>如果决议是全局提交，此时各分支事务已提交并成功，这时 <code>全局事务协调者（TC）</code> 会向分支发送第二阶段的请求。收到 TC 的分支提交请求，该请求会被放入一个异步任务队列中，并马上返回提交成功结果给 TC。异步队列中会异步和批量地根据 <code>Branch ID</code> 查找并删除相应 <code>UNDO LOG</code> 回滚记录。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/592fc4836e8a4f9a9c4c1de690ba166d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>如果决议是全局回滚，过程比全局提交麻烦一点，<code>RM</code> 服务方收到 <code>TC</code> 全局协调者发来的回滚请求，通过 <code>XID</code> 和 <code>Branch ID</code> 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。</p><blockquote><p>注意：这里删除回滚日志记录操作，一定是在本地业务事务执行之后</p></blockquote><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1c40b2c8a80b45acae157850f58cac79~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>上边说了几种分布式事务各自的优缺点，下边实践一下分布式事务中间 Seata 感受一下。</p><h2 id="Seata-实践"><a href="#Seata-实践" class="headerlink" title="Seata 实践"></a>Seata 实践</h2><p>Seata 是一个需独立部署的中间件，所以先搭 Seata Server，这里以最新的 <code>seata-server-1.4.0</code> 版本为例，下载地址：<code>https://seata.io/en-us/blog/download.html</code></p><p>解压后的文件我们只需要关心 <code>\seata\conf</code> 目录下的 <code>file.conf</code> 和  <code>registry.conf</code> 文件。</p><h3 id="Seata-Server"><a href="#Seata-Server" class="headerlink" title="Seata Server"></a>Seata Server</h3><h3 id="file-conf"><a href="#file-conf" class="headerlink" title="file.conf"></a>file.conf</h3><p><code>file.conf</code> 文件用于配置持久化事务日志的模式，目前提供 <code>file</code>、<code>db</code>、<code>redis</code> 三种方式。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/136f615cd12e4e21a0c8ac8c41f6f2a2~tplv-k3u1fbpfcp-zoom-1.image" alt="file.conf 文件配置"></p><p><strong>注意</strong>：在选择 <code>db</code> 方式后，需要在对应数据库创建 <code>globalTable</code>（持久化全局事务）、<code>branchTable</code>（持久化各提交分支的事务）、 <code>lockTable</code>（持久化各分支锁定资源事务）三张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="comment">-- 持久化全局事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`xid`</span>                       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>            <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`status`</span>                    <span class="built_in">TINYINT</span>      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`application_id`</span>            <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_name`</span>          <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    <span class="string">`timeout`</span>                   <span class="built_in">INT</span>,</span><br><span class="line">    <span class="string">`begin_time`</span>                <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`application_data`</span>          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>                DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>              DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="comment">-- 持久化各提交分支的事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`branch_id`</span>         <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>               <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>    <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`resource_id`</span>       <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`branch_type`</span>       <span class="built_in">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="string">`status`</span>            <span class="built_in">TINYINT</span>,</span><br><span class="line">    <span class="string">`client_id`</span>         <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    <span class="string">`application_data`</span>  <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>        DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="string">`gmt_modified`</span>      DATETIME(<span class="number">6</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="comment">-- 持久化每个分支锁表事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`row_key`</span>        <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>            <span class="built_in">VARCHAR</span>(<span class="number">96</span>),</span><br><span class="line">    <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>      <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`resource_id`</span>    <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`table_name`</span>     <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`pk`</span>             <span class="built_in">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>     DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>   DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_key`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_branch_id`</span> (<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br></pre></td></tr></table></figure><h3 id="registry-conf"><a href="#registry-conf" class="headerlink" title="registry.conf"></a>registry.conf</h3><p><code>registry.conf</code> 文件设置 注册中心 和 配置中心：</p><p>目前注册中心支持 <code>nacos</code> 、<code>eureka</code>、<code>redis</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code>、<code>sofa</code> 七种，这里我使用的 <code>eureka</code>作为注册中心 ； 配置中心支持 <code>nacos</code> 、<code>apollo</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code> 五种方式。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/2119d406e05e42268ac3536fa64866dc~tplv-k3u1fbpfcp-zoom-1.image" alt="registry.conf 文件配置"></p><p>配置完以后在 <code>\seata\bin</code> 目录下启动 <code>seata-server</code> 即可，到这 <code>Seata</code> 的服务端就搭建好了。</p><h3 id="Seata-Client"><a href="#Seata-Client" class="headerlink" title="Seata Client"></a>Seata Client</h3><p><code>Seata Server</code> 环境搭建完，接下来我们新建三个服务 <code>order-server</code>（下单服务）、<code>storage-server</code>（扣减库存服务）、<code>account-server</code>（账户金额服务），分别服务注册到 <code>eureka</code>。</p><p>每个服务的大体核心配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">storage-server</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">alibaba:</span></span><br><span class="line">            <span class="attr">seata:</span></span><br><span class="line">                <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://47.93.6.1:3306/seat-storage</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka 注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">serviceUrl:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="number">47.93</span><span class="number">.6</span><span class="number">.5</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>业务大致流程：用户发起下单请求，本地 order 订单服务创建订单记录，并通过 <code>RPC</code> 远程调用 <code>storage</code> 扣减库存服务和 <code>account</code> 扣账户余额服务，只有三个服务同时执行成功，才是一个完整的下单流程。如果某个服执行失败，则其他服务全部回滚。</p><p>Seata 对业务代码的侵入性非常小，代码中使用只需用 <code>@GlobalTransactional</code> 注解开启一个全局事务即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@GlobalTransactional(name = &quot;create-order&quot;, rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String xid = RootContext.getXID();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;交易开始&quot;</span>);</span><br><span class="line">    <span class="comment">//本地方法</span></span><br><span class="line">    orderDao.create(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程方法 扣减库存</span></span><br><span class="line">    storageApi.decrease(order.getProductId(), order.getCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程方法 扣减账户余额</span></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;扣减账户开始order中&quot;</span>);</span><br><span class="line">    accountApi.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;扣减账户结束order中&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;交易结束&quot;</span>);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;全局事务 xid： &#123;&#125;&quot;</span>, xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前边说过 Seata AT 模式实现分布式事务，必须在相关的业务库中创建 <code>undo_log</code> 表来存数据回滚日志，表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`undo_log`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span>            <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;increment id&#x27;</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>     <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`xid`</span>           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`context`</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    <span class="string">`rollback_info`</span> LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    <span class="string">`log_status`</span>    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    <span class="string">`log_created`</span>   DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    <span class="string">`log_modified`</span>  DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>, <span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> =<span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>到这环境搭建的工作就完事了，完整案例会在后边贴出 <code>GitHub</code> 地址，就不在这占用篇幅了。</p></blockquote><h2 id="测试-Seata"><a href="#测试-Seata" class="headerlink" title="测试 Seata"></a>测试 Seata</h2><p>项目中的服务调用过程如下图：</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/40a44673f4c84450b2a29154accf7b1c~tplv-k3u1fbpfcp-zoom-1.image" alt="服务调用过程"></p><p>启动各个服务后，我们直接请求下单接口看看效果，只要 <code>order</code> 订单表创建记录成功，<code>storage</code> 库存表 <code>used</code> 字段数量递增、<code>account</code> 余额表 <code>used</code> 字段数量递增则表示下单流程成功。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d091e25fac5346dc92d1875df942e6de~tplv-k3u1fbpfcp-zoom-1.image" alt="原始数据"></p><p>请求后正向流程是没问题的，数据和预想的一样</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/9048853aec764d86a116473450270347~tplv-k3u1fbpfcp-zoom-1.image" alt="下单数据"></p><p>而且发现 <code>TM</code> 事务管理者 <code>order-server</code> 服务的控制台也打印出了两阶段提交的日志</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d13de839fd2a4db2af5f5e535d13e41a~tplv-k3u1fbpfcp-zoom-1.image" alt="控制台两次提交"></p><p>那么再看看如果其中一个服务异常，会不会正常回滚呢？在 <code>account-server</code> 服务中模拟超时异常，看能否实现全局事务回滚。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d5d73832fae544828d2bc33d67cd160b~tplv-k3u1fbpfcp-zoom-1.image" alt="全局事务回滚"></p><p>发现数据全没执行成功，说明全局事务回滚也成功了</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7307262d393244f890211618ec315630~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>那看一下 <code>undo_log</code> 回滚记录表的变化情况，由于 <code>Seata</code> 删除回滚日志的速度很快，所以要想在表中看见回滚日志，必须要在某一个服务上打断点才看的更明显。</p><p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/6b06cf8edcfe4bd997e57206b578a3e0~tplv-k3u1fbpfcp-zoom-1.image" alt="回滚记录"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上边简单介绍了 <code>2PC</code>、<code>3PC</code>、<code>TCC</code>、<code>MQ</code>、<code>Seata</code> 这五种分布式事务解决方案，还详细的实践了 <code>Seata</code> 中间件。但不管我们选哪一种方案，在项目中应用都要谨慎再谨慎，除特定的数据强一致性场景外，能不用尽量就不要用，因为无论它们性能如何优越，一旦项目套上分布式事务，整体效率会几倍的下降，在高并发情况下弊端尤为明显。</p><blockquote><p>本案例 github 地址：<a href="https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-seata-transaction">https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-seata-transaction</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper之简单使用</title>
      <link href="2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、初识-zookeeper"><a href="#一、初识-zookeeper" class="headerlink" title="一、初识 zookeeper"></a>一、初识 zookeeper</h2><p><code>Zookeeper</code> 它作为<code>Hadoop</code>项目中的一个开源子项目，是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务。</p><h3 id="1、zookeeper数据模型"><a href="#1、zookeeper数据模型" class="headerlink" title="1、zookeeper数据模型"></a>1、zookeeper数据模型</h3><p><code>zookeeper</code> 维护了一个类似文件系统的数据结构，每个子目录（/微信、/微信/公众号）都被称作为 <code>znode</code> 即节点。和文件系统一样，我们可以很轻松的对 <code>znode</code> 节点进行增加、删除等操作，而且还可以在一个<code>znode</code>下增加、删除<code>子znode</code>，区别在于文件系统的是，<code>znode</code>可以存储数据（严格说是必须存放数据，默认是个空字符）。</p><p>由于<code>zookeeper</code>是目录节点结构，在获取和创建节点时，必须要以<code>“/”</code> 开头，否则在获取节点时会报错 <code>Path must start with / character</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">13</span>] get test</span><br><span class="line">Command failed: java.lang.IllegalArgumentException: Path must start <span class="keyword">with</span> / character</span><br></pre></td></tr></table></figure><p>根节点名必须为<code>“/XXX”</code>，创建子节点时必须要带上根节点目录<code>“/XXX/CCC”</code>、<code>“/XXX/AAA”</code>。</p><p>例如：想要获取下图 <code>程序员内点事</code> 节点必须拼接完整的路径 <code>get /微信/公众号/程序员内点事</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /微信/公众号/程序员内点事</span><br></pre></td></tr></table></figure><p><img src="/2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/ee94371033334df0adaa31ccc7933ef4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><code>znode</code>被用来存储 <code>byte级</code> 或 <code>kb级</code> 的数据，可存储的最大数据量是<code>1MB</code>（<strong>请注意</strong>：一个节点的数据量不仅包含它自身存储数据，它的所有子节点的名字也要折算成Byte数计入，因此<code>znode</code>的子节点数也不是无限的）虽然可以手动的修改节点存储量大小，但一般情况下并不推荐这样做。</p><h3 id="2、znode节点属性"><a href="#2、znode节点属性" class="headerlink" title="2、znode节点属性"></a>2、znode节点属性</h3><p>一个<code>znode</code>节点不仅可以存储数据，还有一些其他特别的属性。接下来我们创建一个<code>/test</code>节点分析一下它各个属性的含义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] get /<span class="built_in">test</span></span><br><span class="line">456</span><br><span class="line">cZxid = 0x59ac //</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59ad</span><br><span class="line">mtime = Mon Mar 30 15:22:25 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 0  </span><br></pre></td></tr></table></figure><table><thead><tr><th>节点属性</th><th>注解</th></tr></thead><tbody><tr><td>cZxid</td><td>该数据节点被创建时的事务Id</td></tr><tr><td>mZxid</td><td>该数据节点被修改时最新的事物Id</td></tr><tr><td>pZxid</td><td>当前节点的父级节点事务Id</td></tr><tr><td>ctime</td><td>该数据节点创建时间</td></tr><tr><td>mtime</td><td>该数据节点最后修改时间</td></tr><tr><td>dataVersion</td><td>当前节点版本号（每修改一次值+1递增）</td></tr><tr><td>cversion</td><td>子节点版本号（子节点修改次数，每修改一次值+1递增）</td></tr><tr><td>aclVersion</td><td>当前节点acl版本号（节点被修改acl权限，每修改一次值+1递增）</td></tr><tr><td>ephemeralOwner</td><td>临时节点标示，当前节点如果是临时节点，则存储的创建者的会话id（sessionId），如果不是，那么值=0</td></tr><tr><td>dataLength</td><td>当前节点所存储的数据长度</td></tr><tr><td>numChildren</td><td>当前节点下子节点的个数</td></tr></tbody></table><p>我们看到一个<code>znode</code>节点的属性比较多，但比较主要的属性还是<code>zxid</code>、<code>version</code>、<code>acl</code> 这三个。</p><hr><p><strong>Zxid：</strong></p><p><code>znode</code>节点状态改变会导致该节点收到一个<code>zxid</code>格式的时间戳，这个时间戳是全局有序的，znode节点的建立或者更新都会产生一个新的。如果<code>zxid1</code>的值 &lt; <code>zxid2</code>的值，那么说明<code>zxid2</code>发生的改变在<code>zxid1</code>之后。每个znode节点都有3个<code>zxid</code>属性，<code>cZxid</code>（节点创建时间）、<code>mZxid</code>（该节点修改时间，与子节点无关）、<code>pZxid</code>（该节点或者该节点的子节点的最后一次创建或者修改时间，孙子节点无关）。</p><p><code>zxid</code>属性主要应用于<code>zookeeper</code>的集群，这个后边介绍集群时详细说。</p><p><strong>Version：</strong></p><p><code>znode</code>属性中一共有三个版本号<code>dataversion</code>（数据版本号）、<code>cversion</code>（子节点版本号）、<code>aclversion</code>（节点所拥有的ACL权限版本号）。</p><p><code>znode</code>中的数据可以有多个版本，如果某一个节点下存有多个数据版本，那么查询这个节点数据就需要带上版本号。每当我们对<code>znode</code>节点数据修改后，该节点的<code>dataversion</code>版本号会递增。当客户端请求该<code>znode</code>节点时，会同时返回节点数据和版本号。另外当<code>dataversion</code>为 <code>-1</code>的时候可以忽略版本进行操作。对一个节点设置权限时<code>aclVersion</code>版本号会递增，下边会详细说ACL权限控制。</p><p>验证一下，我们修改<code>/test</code>节点的数据看看<code>dataVersion </code>有什么变化，发现<code>dataVersion </code>属性变成了 3，版本号递增了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] <span class="built_in">set</span> /<span class="built_in">test</span> 8888</span><br><span class="line">cZxid = 0x59ac</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59b6</span><br><span class="line">mtime = Mon Mar 30 16:58:08 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h3 id="3、znode的类型"><a href="#3、znode的类型" class="headerlink" title="3、znode的类型"></a>3、znode的类型</h3><p><code>zookeeper</code> 有四种类型的<code>znode</code>，在用客户端 <code>client</code> 创建节点的时候需要指定类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.create(<span class="string">&quot;/公众号/程序员内点事&quot;</span>, <span class="string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br></pre></td></tr></table></figure><ul><li><code>PERSISTENT</code>-持久化目录节点 ：client创建节点后，与zookeeper断开连接该节点将被持久化，当client再次连接后节点依旧存在。</li><li><code>PERSISTENT_SEQUENTIAL</code>-持久化顺序节点 ：client创建节点后，与zookeeper断开连接该节点将被持久化，再次连接节点还存在，zookeeper会给该节点名称进行顺序编号，例如：/lock/0000000001、/lock/0000000002、/lock/0000000003。</li><li><code>EPHEMERAL</code>-临时目录节点 ： client与zookeeper断开连接后，该节点即会被删除</li><li><code>EPHEMERAL_SEQUENTIAL</code>-临时顺序节点 ： client与zookeeper断开连接后，该节点被删除，会给该节点名称进行顺序编号，例如：/lock/0000000001、/lock/0000000002、/lock/0000000003。</li></ul><h2 id="二、节点的ACL权限控制"><a href="#二、节点的ACL权限控制" class="headerlink" title="二、节点的ACL权限控制"></a>二、节点的ACL权限控制</h2><p><code>ACL</code>：即 <code>Access Control List</code> (节点的权限控制)，通过<code>ACL</code>机制来解决<code>znode</code>节点的访问权限问题，要注意的是<code>zookeeper</code>对权限的控制是基于<code>znode</code>级别的，也就说节点之间的权限不具有继承性，即子节点不继承父节点的权限。</p><p><code>zookeeper</code>中设置ACL权限的格式由<code>&lt;schema&gt;:&lt;id&gt;:&lt;acl&gt;</code>三段组成。</p><p><strong>schema</strong> ：表示授权的方式</p><ul><li><code>world</code>：表示任何人都可以访问</li><li><code>auth</code>：只有认证的用户可以访问</li><li><code>digest</code>：使用username  ：password用户密码生成MD5哈希值作为认证ID</li><li><code>host/ip</code>：使用客户端主机IP地址来进行认证</li></ul><p><strong>id</strong>： 权限的作用域，用来标识身份，依赖于schema选择哪种方式。</p><p><strong>acl</strong>：给一个节点赋予哪些权限，节点的权限有create,、delete、write、read、admin 统称 <code>cdwra</code>。</p><h3 id="1、world：表示任何人都可以访问"><a href="#1、world：表示任何人都可以访问" class="headerlink" title="1、world：表示任何人都可以访问"></a>1、<code>world</code>：表示任何人都可以访问</h3><p>我们用 <code>getAcl</code> 命令来看一下，没有设置过权限的<code>znode</code>节点，默认情况下的权限情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] getAcl /<span class="built_in">test</span></span><br><span class="line"><span class="string">&#x27;world,&#x27;</span>anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure><p>看到没有设置ACL属性的节点，默认schema 使用的是<code>world</code>，作用域是<code>anyone</code>，节点权限是<code>cdwra</code>，也就是说任何人都可以访问。</p><p>那我们如果要给一个schema 为非<code>world</code>的节点设置<code>world</code>权限咋搞？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl /<span class="built_in">test</span> world:anyone:crdwa</span><br></pre></td></tr></table></figure><h3 id="2、auth：只有认证的用户可以访问"><a href="#2、auth：只有认证的用户可以访问" class="headerlink" title="2、auth：只有认证的用户可以访问"></a>2、<code>auth</code>：只有认证的用户可以访问</h3><p>schema 用<code>auth</code>授权表示只有认证后的用户才可以访问，那么首先就需要添加认证用户，添加完以后需要对认证的用户设置ACL权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addauth digest <span class="built_in">test</span>:password(明文)</span><br></pre></td></tr></table></figure><p>需要注意的是设置认证用户时的密码是明文的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] addauth digest user:user //用户名：密码</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] setAcl /<span class="built_in">test</span> auth:user:crdwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] getAcl /<span class="built_in">test</span></span><br><span class="line"><span class="string">&#x27;digest,&#x27;</span>user:ben+k/3JomjGj4mfd4fYsfM6p0A=</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure><p>实际上我们这样设置以后，就是将这个节点开放给所有认证的用户，<code>setAcl /test auth:user:crdwa</code> 相当于<code>setAcl /test auth::crdwa</code>。</p><h3 id="3、digest：用户名-密码的验证方式"><a href="#3、digest：用户名-密码的验证方式" class="headerlink" title="3、digest：用户名:密码的验证方式"></a>3、<code>digest</code>：用户名:密码的验证方式</h3><p>用户名:密码方式授权是针对单个特定用户，这种方式是不需要先添加认证用户的。</p><p>如果在代码中使用zookeeper客户端设置ACL，那么密码是明文的，但若是zk.cli等客户端操作就需要将密码进行<code>sha1</code>及<code>base64</code>处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setAcl &lt;path&gt; digest:&lt;user&gt;:&lt;password(密文)&gt;:&lt;acl&gt;</span><br><span class="line"></span><br><span class="line">setAcl /<span class="built_in">test</span> digest:user:jalRr+knv/6L2uXdenC93dEDNuE=:crdwa</span><br></pre></td></tr></table></figure><p>那么密码如何加密嘞？有以下几种方式：</p><p>通过<code>shell</code>命令加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure><p>使用<code>zookeeper</code>自带的类库<code>org.apache.zookeeper.server.auth.DigestAuthenticationProvider</code>生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -cp /zookeeper-3.4.13/zookeeper-3.4.13.jar:/zookeeper-3.4.13/lib/slf4j-api-1.7.25.jar \</span><br><span class="line">  org.apache.zookeeper.server.auth.DigestAuthenticationProvider \</span><br><span class="line">  root:root</span><br><span class="line">root:root-&gt;root:qiTlqPLK7XM2ht3HMn02qRpkKIE=</span><br></pre></td></tr></table></figure><h3 id="4、host-ip：使用客户端主机IP地址来进行认证"><a href="#4、host-ip：使用客户端主机IP地址来进行认证" class="headerlink" title="4、host/ip：使用客户端主机IP地址来进行认证"></a>4、<code>host/ip</code>：使用客户端主机IP地址来进行认证</h3><p>这种方式就比较好理解了，通过对特定的IP地址，也可以是一个IP段进行授权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] setAcl /test0000000014 ip:127.0.0.1:crdwa</span><br><span class="line">cZxid = 0x59ac</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59b6</span><br><span class="line">mtime = Mon Mar 30 16:58:08 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 3 // 这个版本一直在增加</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h2 id="三、zookeeper的灵魂-watcher"><a href="#三、zookeeper的灵魂-watcher" class="headerlink" title="三、zookeeper的灵魂 watcher"></a>三、zookeeper的灵魂 watcher</h2><p>我们在开头就说过：<code>zookeeper</code>可以为<code>dubbo</code>提供服务的注册与发现，作为注册中心，但你有想过<code>zookeeper</code>为啥能够实现服务的注册与发现吗？这就不得不说一下<code>zookeeper</code>的灵魂 <code>Watcher</code>（监听者）。</p><h3 id="1、watcher是个啥？"><a href="#1、watcher是个啥？" class="headerlink" title="1、watcher是个啥？"></a>1、watcher是个啥？</h3><p><code>watcher</code> 是<code>zooKeeper</code>中一个非常核心功能 ，客户端<code>watcher</code> 可以监控节点的数据变化以及它子节点的变化，一旦这些状态发生变化，zooKeeper服务端就会通知所有在这个节点上设置过<code>watcher</code>的客户端 ，从而每个客户端都很快感知，它所监听的节点状态发生变化，而做出对应的逻辑处理。</p><p>简单的介绍了一下<code>watcher</code> ，那么我们来分析一下，<code>zookeeper</code>是如何实现服务的注册与发现。 <code>zookeeper</code>的服务注册与发现，主要应用的是<code>zookeeper</code>的<code>znode</code>节点数据模型和<code>watcher</code>机制，大致的流程如下：</p><p><img src="/2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/2a10d2a2b39a4cedbcd430dc2a2394a4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><ul><li><strong>服务注册：</strong> 服务提供者（<code>Provider</code>）启动时，会向<code>zookeeper服务端</code>注册服务信息，也就是创建一个节点，例如：用户注册服务<code>com.xxx.user.register</code>，并在节点上存储服务的相关数据（如服务提供者的ip地址、端口等）。</li><li><strong>服务发现：</strong> 服务消费者（<code>Consumer</code>）启动时，根据自身配置的依赖服务信息，向<code>zookeeper服务端</code>获取注册的服务信息并设置<code>watch监听</code>，获取到注册的服务信息之后，将服务提供者的信息缓存在本地，并进行服务的调用。</li><li><strong>服务通知：</strong> 一旦服务提供者因某种原因宕机不再提供服务之后，客户端与<code>zookeeper</code>服务端断开连接，<code>zookeeper</code>服务端上服务提供者对应服务节点会被删除（例如：用户注册服务<code>com.xxx.user.register</code>），随后<code>zookeeper</code>服务端会异步向所有消费用户注册服务<code>com.xxx.user.register</code>，且设置了<code>watch监听</code>的服务消费者发出节点被删除的通知，消费者根据收到的通知拉取最新服务列表，更新本地缓存的服务列表。</li></ul><p>上边的过程就是<code>zookeeper</code>可以实现服务注册与发现的大致原理。</p><h3 id="2、watcher类型"><a href="#2、watcher类型" class="headerlink" title="2、watcher类型"></a>2、watcher类型</h3><p><code>znode</code>节点可以设置两类<code>watch</code>，一种是<code>DataWatches</code>，基于znode节点的数据变更从而触发 <code>watch</code> 事件，触发条件<code>getData()</code>、<code>exists()</code>、<code>setData()</code>、 <code>create()</code>。</p><p>另一种是<code>Child Watches</code>，基于znode的孩子节点发生变更触发的watch事件，触发条件 <code>getChildren()</code>、 <code>create()</code>。</p><p>而在调用 <code>delete()</code> 方法删除znode时，则会同时触发<code>Data Watches</code>和<code>Child Watches</code>，如果被删除的节点还有父节点，则父节点会触发一个<code>Child Watches</code>。</p><h3 id="3、watcher特性"><a href="#3、watcher特性" class="headerlink" title="3、watcher特性"></a>3、watcher特性</h3><p><code>watch</code>对节点的监听事件是一次性的！客户端在指定的节点设置了监听<code>watch</code>，一旦该节点数据发生变更通知一次客户端后，客户端对该节点的监听事件就失效了。</p><p>如果还要继续监听这个节点，就需要我们在客户端的监听回调中，再次对节点的监听<code>watch</code>事件设置为<code>True</code>。否则客户端只能接收到一次该节点的变更通知。</p><h2 id="四、zookeeper能实现哪些功能"><a href="#四、zookeeper能实现哪些功能" class="headerlink" title="四、zookeeper能实现哪些功能"></a>四、zookeeper能实现哪些功能</h2><p>服务的注册与发现功能只是zookeeper的冰山一角，它还能实现诸如分布式锁、队列、配置中心等一系列功能，接下来我们只分析一下原理，具体的实现大家上网查一下资料还是比较全的。</p><h3 id="1、分布式锁"><a href="#1、分布式锁" class="headerlink" title="1、分布式锁"></a>1、分布式锁</h3><p><code>zookeeper</code>基于<code>watcher</code>机制和<code>znode</code>的有序节点，天生就是一个分布式锁的坯子。首先创建一个<code>/test/lock</code>父节点作为一把锁，尽量是持久节点（PERSISTENT类型），每个尝试获取这把锁的客户端，在<code>/test/lock</code>父节点下创建临时顺序子节点。</p><p>由于序号的递增性，我们规定序号最小的节点即获得锁。例如：客户端来获取锁，在<code>/test/lock</code>节点下创建节点为<code>/test/lock/seq-00000001</code>，它是最小的所以它优先拿到了锁，其它节点等待通知再次获取锁。<code>/test/lock/seq-00000001</code>执行完自己的逻辑后删除节点释放锁。</p><p><strong>那么节点<code>/test/lock/seq-00000002</code>想要获取锁等谁的通知呢？</strong></p><p>这里我们让<code>/test/lock/seq-00000002</code>节点监听<code>/test/lock/seq-00000001</code>节点，一旦<code>/test/lock/seq-00000001</code>节点删除，则通知<code>/test/lock/seq-00000002</code>节点，让它再次判断自己是不是最小的节点，是则拿到锁，不是继续等通知。</p><p>以此类推<code>/test/lock/seq-00000003</code>节点监听<code>/test/lock/seq-00000002</code>节点，总是让后一个节点监听前一个节点，不用让所有节点都监听最小的节点，避免设置不必要的监听，以免造成大量无效的通知，形成“羊群效应”。</p><p><code>zookeeper</code>分布式锁和<code>redis</code>分布式锁相比，因为大量的创建、删除节点性能上比较差，并不是很推荐。 <img src="/2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7d20302015de4629acd6d633bf0f5253~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2、分布式队列"><a href="#2、分布式队列" class="headerlink" title="2、分布式队列"></a>2、分布式队列</h3><p>zookeeper实现分布式队列也很简单，应用znode的有序节点天然的“先进先出”，后创建的节点总是最大的，出队总是拿序号最小的节点即可。</p><h3 id="3、配置管理"><a href="#3、配置管理" class="headerlink" title="3、配置管理"></a>3、配置管理</h3><p>现在有很多开源项目都在使用Zookeeper来维护配置，像消息队列Kafka中，就使用Zookeeper来维护broker的信息；dubbo中管理服务的配置信息。原理也是基于<code>watcher</code>机制，例如：创建一个<code>/config</code>节点存放一些配置，客户端监听这个节点，一点修改<code>/config</code>节点的配置信息，通知各个客户端数据变更重新拉取配置信息。</p><h3 id="4、命名服务"><a href="#4、命名服务" class="headerlink" title="4、命名服务"></a>4、命名服务</h3><p><code>zookeeper</code>的命名服务：也就是我们常说的服务注册与发现，主要是根据指定名字来获取资源或服务的地址，服务提供者等信息，利用其<code>znode</code>节点的特点和<code>watcher</code>机制，将其作为动态注册和获取服务信息的配置中心，统一管理服务名称和其对应的服务器列表信息，我们能够近乎实时地感知到后端服务器的状态(上线、下线、宕机)。</p><h2 id="五、基本操作"><a href="#五、基本操作" class="headerlink" title="五、基本操作"></a>五、基本操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ul><li>create /blog “blog” 创建普通节点</li><li>create -e /blog-temp “temp” 创建临时节点</li><li>create -s /blog-sequence “sequence” 创建序列节点</li><li>create -s  -e /blog-ts “ts” 创建带序号的临时节点</li></ul><h3 id="节点监听"><a href="#节点监听" class="headerlink" title="节点监听"></a>节点监听</h3><ul><li>get /servers watch   节点的值变化监听</li><li>ls /servers watch 节点的子节点变化监听（增、删）</li><li>stat -w /path 监听节点属性的变化</li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul><li>delete /blog  删除节点（不能删除带有子节点的节点）</li><li>rmr /sanguo  递归删除节点（可以删除带有子节点的节点）</li></ul><h3 id="显示配额"><a href="#显示配额" class="headerlink" title="显示配额"></a>显示配额</h3><ul><li>listquota /zookeeper  返回值count=2,bytes=-1 节点个数限额为2，长度无限额</li></ul><h3 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h3><ul><li>stat /blog-temp</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid &#x3D; 0x70000012e  引起这个znode创建的zxid，创建节点的事务的zxid（ZooKeeper Transaction Id），每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生</span><br><span class="line">ctime &#x3D; Mon Oct 12 06:08:52 UTC 2020 znode被创建的时间戳(从1970年开始)</span><br><span class="line">mZxid &#x3D; 0x70000012e znode最后更新的zxid</span><br><span class="line">mtime &#x3D; Mon Oct 12 06:08:52 UTC 2020 znode最后修改的时间戳(从1970年开始)</span><br><span class="line">pZxid &#x3D; 0x70000012e  znode最后更新的子节点zxid</span><br><span class="line">cversion &#x3D; 0 znode子节点变化号，znode子节点修改次数</span><br><span class="line">dataVersion &#x3D; 0 znode数据变化号</span><br><span class="line">aclVersion &#x3D; 0 znode访问控制列表的变化号</span><br><span class="line">ephemeralOwner &#x3D; 0x0 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0</span><br><span class="line">dataLength &#x3D; 4 znode的数据长度</span><br><span class="line">numChildren &#x3D; 0 znode子节点数量</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>  分布式消息同步和协调机制</li><li>  服务器节点动态上下线</li><li>  统一配置管理</li><li>  负载均衡</li><li>  集群管理</li><li>  。。。。。。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>  zookeeper的数据模型的结构和unix文件系统很相似，整体上看是一颗目录树，每一个节点称为ZNode（每个节点不但有目录名称，还必须要有值，类似于键值对）。<br>  zookeeper集群自身维护了一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为”znode”，每一个znode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。</p><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><ul><li>  短暂（ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除。</li><li>  持久（persistent）：客户端和服务器端断开连接后，创建的节点不删除。</li><li>  持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号，顺序编号有小到大。</li><li>  临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号，顺序编号有小到大。</li></ul><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><h2 id="zab原子广播协议"><a href="#zab原子广播协议" class="headerlink" title="zab原子广播协议"></a>zab原子广播协议</h2><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><h2 id="失败恢复"><a href="#失败恢复" class="headerlink" title="失败恢复"></a>失败恢复</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://juejin.cn/post/6906694879380766727">zookeeper 基础</a></p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之Type</title>
      <link href="2020/12/22/java%E4%B9%8BType/"/>
      <url>2020/12/22/java%E4%B9%8BType/</url>
      
        <content type="html"><![CDATA[<h2 id="Class（原始类型、基本数据类型-）"><a href="#Class（原始类型、基本数据类型-）" class="headerlink" title="Class（原始类型、基本数据类型 ）"></a>Class（原始类型、基本数据类型 ）</h2><p>Type的直接实现子类</p><h2 id="ParameterizedType（泛型参数化类型）"><a href="#ParameterizedType（泛型参数化类型）" class="headerlink" title="ParameterizedType（泛型参数化类型）"></a>ParameterizedType（泛型参数化类型）</h2><p>参数化的类型，比如Collection&lt;?&gt;,实现类是<strong>ParameterizedTypeImpl</strong></p><p>public Type[] getActualTypeArguments() ;   返回实际的Type()。</p><h2 id="GenericArrayType（泛型数组类型）"><a href="#GenericArrayType（泛型数组类型）" class="headerlink" title="GenericArrayType（泛型数组类型）"></a>GenericArrayType（泛型数组类型）</h2><p>元素类型是参数化类型或者类型变量的数组类型,实现类<strong>GenericArrayTypeImpl</strong></p><p>public Type getGenericComponentType()；获取泛型数组类型</p><h2 id="TypeVariable（泛型类型变量）"><a href="#TypeVariable（泛型类型变量）" class="headerlink" title="TypeVariable（泛型类型变量）"></a>TypeVariable（泛型类型变量）</h2><p>各种类型变量的公共父接口，实现类是<strong>TypeVariableImpl</strong></p><p>public D getGenericDeclaration()；</p><h2 id="WildcardType（泛型通配符类型）"><a href="#WildcardType（泛型通配符类型）" class="headerlink" title="WildcardType（泛型通配符类型）"></a>WildcardType（泛型通配符类型）</h2><p>一种通配符类型表达式，比如?, ? extends Number, ? super Integer，实现类：<strong>WildcardTypeImpl</strong></p><p>Type[] getUpperBounds();  获取通配符表达式对象的泛型限定的上边界的类型</p><p>Type[] getLowerBounds(); 下边界类型</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> E <span class="title">methodIV</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;ArrayList&gt; al1,  //al1的类型是ArrayList，返回类型是ParameterizedType</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;E&gt; al2,          //al2的类型是E，返回类型是TypeVariable</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;String&gt; al3,     //al3的类型是String，返回类型是Class</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;? extends Number&gt; al4,   //al4的类型是? extends Number，返回类型是WildcardType</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;E[]&gt; al5)</span></span>&#123;&#125;)     <span class="comment">//al5的类型是E[]，返回类型是GenericArrayType</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型出现之前的类型"><a href="#泛型出现之前的类型" class="headerlink" title="泛型出现之前的类型"></a>泛型出现之前的类型</h3><p>没有泛型的时候，只有所谓的原始类型。此时，所有的原始类型都通过字节码文件类Class类进行抽象。Class类的一个具体对象就代表一个指定的原始类型。</p><h3 id="泛型出现之后的类型"><a href="#泛型出现之后的类型" class="headerlink" title="泛型出现之后的类型"></a>泛型出现之后的类型</h3><p>泛型出现之后，扩充了数据类型。从只有原始类型扩充了参数化类型、类型变量类型、泛型限定的的参数化类型 (含通配符+通配符限定表达式)、泛型数组类型。</p><h3 id="与泛型有关的类型不能和原始类型统一到Class的原因"><a href="#与泛型有关的类型不能和原始类型统一到Class的原因" class="headerlink" title="与泛型有关的类型不能和原始类型统一到Class的原因"></a>与泛型有关的类型不能和原始类型统一到Class的原因</h3><p>[1]. 【产生泛型擦除的原因】<br>本来新产生的类型+原始类型都应该统一成各自的字节码文件类型对象。但是由于泛型不是最初Java中的成分。如果真的加入了泛型，涉及到JVM指令集的修改，这是非常致命的。<br>[2]. 【Java中如何引入泛型】<br>为了使用泛型的优势又不真正引入泛型，Java采用泛型擦除的机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部擦除。<br>[3]. 【Class不能表达与泛型有关的类型】<br>因此，与泛型有关的参数化类型、类型变量类型、泛型限定的的参数化类型 (含通配符+通配符限定表达式)、泛型数组类型这些类型全部被打回原形，在字节码文件中全部都是泛型被擦除后的原始类型，并不存在和自身类型一致的字节码文件。所以和泛型相关的新扩充进来的类型不能被统一到Class类中。<br>(4). 与泛型有关的类型在Java中的表示<br>为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了ParameterizedType，GenericArrayType，TypeVariable 和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。<br>(5). Type的引入：统一与泛型有关的类型和原始类型Class</p><h3 id="引入Type的原因"><a href="#引入Type的原因" class="headerlink" title="引入Type的原因"></a>引入Type的原因</h3><p>为了程序的扩展性，最终引入了Type接口作为Class，ParameterizedType，GenericArrayType，TypeVariable和WildcardType这几种类型的总的父接口。这样实现了Type类型参数接受以上五种子类的实参或者返回值类型就是Type类型的参数。</p><h3 id="Type接口中没有方法的原因"><a href="#Type接口中没有方法的原因" class="headerlink" title="Type接口中没有方法的原因"></a>Type接口中没有方法的原因</h3><p>从上面看到，Type的出现仅仅起到了通过多态来达到程序扩展性提高的作用，没有其他的作用。因此Type接口的源码中没有任何方法。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规则引擎介绍</title>
      <link href="2020/12/21/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/12/21/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Drools"><a href="#Drools" class="headerlink" title="Drools"></a>Drools</h2><p>Drools 是用 Java 语言编写的开放源码规则引擎，使用 Rete 算法对所编写的规则求值。Drools 允许使用声明方式表达业务逻辑。可以使用非 XML 的本地语言编写规则，从而便于学习和理解。并且，还可以将 Java 代码直接嵌入到规则文件中，这令 Drools 的学习更加吸引人。</p><p>Drools 还具有其他优点：</p><ul><li>非常活跃的社区支持</li><li>易用</li><li>快速的执行速度</li><li>在 Java 开发人员中流行</li><li>与 Java Rule Engine API（JSR 94）兼容</li></ul><h2 id="QLExpress"><a href="#QLExpress" class="headerlink" title="QLExpress"></a>QLExpress</h2><p>由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。</p><p>QLExpress脚本引擎被广泛应用在阿里的电商业务场景，具有以下的一些特性:</p><ul><li>1、线程安全，引擎运算过程中的产生的临时变量都是threadlocal类型。</li><li>2、高效执行，比较耗时的脚本编译过程可以缓存在本地机器，运行时的临时变量创建采用了缓冲池的技术，和groovy性能相当。</li><li>3、弱类型脚本语言，和groovy，javascript语法类似，虽然比强类型脚本语言要慢一些，但是使业务的灵活度大大增强。</li><li>4、安全控制,可以通过设置相关运行参数，预防死循环、高危系统api调用等情况。</li><li>5、代码精简，依赖最小，250k的jar包适合所有java的运行环境，在android系统的低端pos机也得到广泛运用。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://gitee.com/cuibo119/QLExpress">QLExpress基本语法</a></p><p><a href="https://developer.aliyun.com/article/621206">QLExpress功能清单</a></p><h2 id="Drools中文网"><a href="#Drools中文网" class="headerlink" title="Drools中文网"></a><a href="http://www.drools.org.cn/">Drools中文网</a></h2>]]></content>
      
      
      <categories>
          
          <category> 规则引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p6spy之简单使用</title>
      <link href="2020/12/21/p6spy%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/21/p6spy%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="p6spy作用"><a href="#p6spy作用" class="headerlink" title="p6spy作用"></a>p6spy作用</h2><p>将所有执行的sql打出日志，放在一个文件下。</p><p>p6spy将应用的数据源给劫持了，应用操作数据库其实在调用p6spy的数据源，p6spy劫持到需要执行的sql或者hql之类的语句之后，他自己去调用一个realDatasource，再去操作数据库</p><p>p6spy 可以输出日志到文件中、控制台、或者传递给 Log4j，而且还能配搭 SQL Profiler 或 IronTrackSQL 图形化监控 SQL 语句，监测到哪些语句的执行是耗时的，逐个优化。</p><h2 id="p6spy的配置"><a href="#p6spy的配置" class="headerlink" title="p6spy的配置"></a>p6spy的配置</h2><ul><li><p>p6spy.jar放入应用的classpath下</p></li><li><p>修改连接池或者连接配置的jdbc的驱动为p6spy所提供的驱动，com.p6spy.engine.spy.P6SpyDriver</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在单独的Hibernate的应用中，数据库驱动配置在hibernate.cfg.xml里面,所以我需要配置文件中的connection.driver_class属性从oracle.jdbc.driver.OracleDriver改为com.p6spy.engine.spy.P6SpyDriver其他的用户名密码等等配置信息全部不用修改.在web程序中，配置的连接池部分，也只需要修改jdbc-driver的配置即可。</span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>&gt;</span>com.p6spy.engine.spy.P6SpyDriver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>&gt;</span>jdbc:oracle:thin:@localhost:1521:orcl<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.username&quot;</span>&gt;</span>scott<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.password&quot;</span>&gt;</span>tiger<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.pool_size&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span>&gt;</span>org.hibernate.dialect.Oracle9Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;current_session_context_class&quot;</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.provider_class&quot;</span>&gt;</span>org.hibernate.cache.NoCacheProvider<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hbm2ddl.auto&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.jdbc.batch_size&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 spy.properties 并将其放到classpath下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment"># MODULES                                                       #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Modules provide the P6Spy functionality.  If a module, such   #</span></span><br><span class="line"><span class="comment"># as module_log is commented out, that functionality will not   #</span></span><br><span class="line"><span class="comment"># be available.  If it is not commented out (if it is active),  #</span></span><br><span class="line"><span class="comment"># the functionality will be active.                             #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Values set in Modules cannot be reloaded using the            #</span></span><br><span class="line"><span class="comment"># reloadproperties variable.  Once they are loaded, they remain #</span></span><br><span class="line"><span class="comment"># in memory until the application is restarted.                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment">#第一：module.log的属性必须配置，如果不配置，P6SPY将不起任何作用，典型配置：</span></span><br><span class="line"><span class="meta">module.log</span>=<span class="string">com.p6spy.engine.logging.P6LogFactory</span></span><br><span class="line"><span class="comment">#module.outage=com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment"># REALDRIVER(s)                                                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># In your application server configuration file you replace the #</span></span><br><span class="line"><span class="comment"># &quot;real driver&quot; name with com.p6spy.engine.P6SpyDriver. This is #</span></span><br><span class="line"><span class="comment"># where you put the name of your real driver P6Spy can find and #</span></span><br><span class="line"><span class="comment"># register your real driver to do the database work.            #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># If your application uses several drivers specify them in      #</span></span><br><span class="line"><span class="comment"># realdriver2, realdriver3\.  See the documentation for more     #</span></span><br><span class="line"><span class="comment"># details.                                                      #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Values set in REALDRIVER(s) cannot be reloaded using the      #</span></span><br><span class="line"><span class="comment"># reloadproperties variable.  Once they are loaded, they remain #</span></span><br><span class="line"><span class="comment"># in memory until the application is restarted.                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二：数据库驱动配置，你懂的，不多说了</span></span><br><span class="line"><span class="comment"># oracle driver</span></span><br><span class="line"><span class="comment"># realdriver=oracle.jdbc.driver.OracleDriver</span></span><br><span class="line"><span class="comment"># mysql Connector/J driver</span></span><br><span class="line"><span class="comment"># realdriver=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># informix driver</span></span><br><span class="line"><span class="comment"># realdriver=com.informix.jdbc.IfxDriver</span></span><br><span class="line"><span class="comment"># ibm db2 driver</span></span><br><span class="line"><span class="comment"># realdriver=COM.ibm.db2.jdbc.net.DB2Driver</span></span><br><span class="line"><span class="comment"># the mysql open source driver</span></span><br><span class="line"><span class="attr">realdriver</span>=<span class="string">org.gjt.mm.mysql.Driver</span></span><br><span class="line"><span class="comment">#specifies another driver to use</span></span><br><span class="line"><span class="attr">realdriver2</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#specifies a third driver to use</span></span><br><span class="line"><span class="attr">realdriver3</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第三：appender配置，一般分为三种</span></span><br><span class="line"><span class="comment">#specifies the appender to use for logging</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.logging.appender.Log4jLogger</span></span><br><span class="line"><span class="comment">#控制台</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.logging.appender.StdoutLogger</span></span><br><span class="line"><span class="attr">appender</span>=<span class="string">com.p6spy.engine.logging.appender.FileLogger</span></span><br><span class="line"><span class="comment"># name of logfile to use, note Windows users should make sure to use forward slashes in their pathname (e:/test/spy.log) (used for file logger only)</span></span><br><span class="line"><span class="comment">#日志文件存放路径及文件名</span></span><br><span class="line"><span class="attr">logfile</span>     = <span class="string">spy.log</span></span><br><span class="line"><span class="comment"># append to  the p6spy log file.  if this is set to false the</span></span><br><span class="line"><span class="comment"># log file is truncated every time.  (file logger only)</span></span><br><span class="line"><span class="attr">append</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#The following are for log4j logging only</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT.layout.ConversionPattern</span>=<span class="string">p6spy - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.p6spy</span>=<span class="string">INFO,STDOUT</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> p6spy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p6spy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之异常处理</title>
      <link href="2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><ul><li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><h2 id="异常类图"><a href="#异常类图" class="headerlink" title="异常类图"></a>异常类图</h2><p><img src="/2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201221175446673.png" alt="image-20201221175446673"></p><h2 id="Java-的非检查性异常"><a href="#Java-的非检查性异常" class="headerlink" title="Java 的非检查性异常"></a>Java 的非检查性异常</h2><table><thead><tr><th align="left"><strong>异常</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">ArithmeticException</td><td align="left">当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td align="left">ArrayIndexOutOfBoundsException</td><td align="left">用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td align="left">ArrayStoreException</td><td align="left">试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td align="left">ClassCastException</td><td align="left">当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td align="left">IllegalArgumentException</td><td align="left">抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td align="left">IllegalMonitorStateException</td><td align="left">抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td align="left">IllegalStateException</td><td align="left">在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td align="left">IllegalThreadStateException</td><td align="left">线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td align="left">IndexOutOfBoundsException</td><td align="left">指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td align="left">NegativeArraySizeException</td><td align="left">如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td align="left">NullPointerException</td><td align="left">当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</td></tr><tr><td align="left">NumberFormatException</td><td align="left">当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td align="left">SecurityException</td><td align="left">由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td align="left">StringIndexOutOfBoundsException</td><td align="left">此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td align="left">UnsupportedOperationException</td><td align="left">当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><h2 id="检查性异常类"><a href="#检查性异常类" class="headerlink" title="检查性异常类"></a>检查性异常类</h2><table><thead><tr><th align="left"><strong>异常</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">ClassNotFoundException</td><td align="left">应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td align="left">CloneNotSupportedException</td><td align="left">当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</td></tr><tr><td align="left">IllegalAccessException</td><td align="left">拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td align="left">InstantiationException</td><td align="left">当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td align="left">InterruptedException</td><td align="left">一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td align="left">NoSuchFieldException</td><td align="left">请求的变量不存在</td></tr><tr><td align="left">NoSuchMethodException</td><td align="left">请求的方法不存在</td></tr></tbody></table><h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><strong>public String getMessage()</strong></td><td align="left">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td></tr><tr><td align="left"><strong>public Throwable getCause()</strong></td><td align="left">返回一个Throwable 对象代表异常原因。</td></tr><tr><td align="left"><strong>public String toString()</strong></td><td align="left">使用getMessage()的结果返回类的串级名字。</td></tr><tr><td align="left"><strong>public void printStackTrace()</strong></td><td align="left">打印toString()结果和栈层次到System.err，即错误输出流。</td></tr><tr><td align="left"><strong>public StackTraceElement [] getStackTrace()</strong></td><td align="left">返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td></tr><tr><td align="left"><strong>public Throwable fillInStackTrace()</strong></td><td align="left">用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td></tr></tbody></table><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos之gRPC调用</title>
      <link href="2020/12/21/nacos%E4%B9%8BgRPC%E8%B0%83%E7%94%A8/"/>
      <url>2020/12/21/nacos%E4%B9%8BgRPC%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>acos 规划准备基于 gRPC 来替换现有的通信场景(Http + UDP)，以下是重点需要和社区讨论的项。请大家积极踊跃发表自己的看法。</p><h2 id="Nacos-能够替换成长连接的两大前提"><a href="#Nacos-能够替换成长连接的两大前提" class="headerlink" title="Nacos 能够替换成长连接的两大前提"></a>Nacos 能够替换成长连接的两大前提</h2><ul><li><p>通信模型的匹配</p><table><thead><tr><th align="center">现有的通信场景</th><th align="center">新的通讯场景</th></tr></thead><tbody><tr><td align="center">Http 服务接口 服务接口 Request/Response</td><td align="center">gRPC Request/Response</td></tr><tr><td align="center">配置推送 Http Long Polling</td><td align="center">gRPC Request/Stream</td></tr><tr><td align="center">UDP 服务推送 Request/Response</td><td align="center">gRPC Request/Stream</td></tr><tr><td align="center">支持ssl 通讯</td><td align="center">支持ssl 通讯</td></tr></tbody></table></li><li><p>通信的数据格式能够匹配</p><p>基于 gRPC 的业务层俩进程之间是需要协调好一致的通信数据格式 ，然后在 proto 文件里面来描述。为了能够服务好多场景下的通信模型数据格式的一致性，就像 Http 的通信数据格式一样，不 care 上层业务通信的数据具体表现形式，只 care 通信时数据格式的表现能力。以下关注两方面来阐述基于 gRPC 之后的数据格式长啥样。</p><ol><li><p>Request 数据格式</p><table><thead><tr><th align="center">通信数据格式字段</th><th align="center">数据类型</th><th align="center">必要性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">RequestId</td><td align="center">string</td><td align="center">必要</td><td align="center">标识当前的一次请求，方便于后续问题的排查</td></tr><tr><td align="center">Action</td><td align="center">string</td><td align="center">必要</td><td align="center">标识当前请求的具体行为，<strong>对标 Http 中的 URI 。</strong></td></tr><tr><td align="center">Headers</td><td align="center">map&lt;string,string&gt;</td><td align="center">必要</td><td align="center">动态可伸缩的消息头，<strong>对标 http 请求中的 header 。</strong></td></tr><tr><td align="center">Source</td><td align="center">string</td><td align="center">可选</td><td align="center">标明消息的发送源，是哪一个节点发送的消息。</td></tr><tr><td align="center">Params</td><td align="center">map&lt;string,string&gt; l 可选</td><td align="center">动态可伸缩的参数传递，<strong>对标 http 请求中的 参数传递。</strong></td><td align="center"></td></tr><tr><td align="center">Method</td><td align="center">string</td><td align="center">可选</td><td align="center">请求的 Method，<strong>对标 http 请求中的 method。</strong></td></tr><tr><td align="center">Payload</td><td align="center">byte[]</td><td align="center">必要</td><td align="center">请求的消息内容体，<strong>对标 http 请求中的 请求内容体。</strong></td></tr></tbody></table></li><li><p>Response 数据格式</p><table><thead><tr><th align="center">通信数据格式字段</th><th align="center">数据类型</th><th align="center">必要性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ReponseId</td><td align="center">string</td><td align="center">必要</td><td align="center">标识当前的一次 response，方便于后续问题的排查 。通常他的值是来源于 request id，标识当前这个 response 是针对那次 请求进行响应的。</td></tr><tr><td align="center">Source</td><td align="center">string</td><td align="center">可选</td><td align="center">标明消息的Response源，是哪一个节点响应的消息。</td></tr><tr><td align="center">Action</td><td align="center">string</td><td align="center">必要</td><td align="center">标识当前 Response 是对哪个 Action 进行响应的。</td></tr><tr><td align="center">Headers</td><td align="center">map&lt;string,string&gt;</td><td align="center">必要</td><td align="center">动态可伸缩的消息头，<strong>对标 http 请求中的 header 。</strong></td></tr><tr><td align="center">Response Code</td><td align="center">int l 必要</td><td align="center">响应状态码，对标 http 响应中的响应码 。</td><td align="center"></td></tr><tr><td align="center">Response Payload</td><td align="center">byte[]</td><td align="center">必要</td><td align="center">响应的消息内容体，<strong>对标 http 响应中的内容体。</strong></td></tr></tbody></table></li></ol></li></ul><h2 id="协议协商-通信的基础"><a href="#协议协商-通信的基础" class="headerlink" title="协议协商-通信的基础"></a>协议协商-通信的基础</h2><p>长连接支持的过程中必然会出现客户端/服务端，服务端/服务端 版本支持的通信协议不一致的情况。比如说，此时客户端支持 Http，但是服务端升级到新版本，既支持 Http,有支持 gRPC。这个时候客户端服务端通信要协商好一致的通信协议。面对客户端/服务端通信协议不一致的场景，主要采取<strong>通信协议降级</strong>的处理方式。通信协议降级处理主要分为两种：<strong>服务端通信协议降级处理</strong> 和 <strong>客户端通信协议降级处理</strong>。</p><ul><li><p>场景一：服务端版本高(既支持 Http+ UDP,有支持 gRPC),客户端版本低(支持 Http + UDP)。那这个时候经过客户端和服务端协议协商后，达成一致的通信协议是 Http + UDP。那么此时服务端对此客户端支持的通信协议就采用 Http +UDP，相对于新的通信协议，就降级了，这就是<strong>服务端通信协议降级处理。</strong></p><p><strong>注意:</strong> 服务端的通信协议降级处理是针对多个客户端而言的。因为有的客户端连接过来的是新版本，这个时候就没有服务端的通信协议降级处理，直接采用新的通信协议 gRPC 来处理；但是有的客户端连接过来的是低版本，那么这个时候就需要单独对这个客户端进行服务端通信协议降级处理了。</p></li><li><p>场景二：客户端版本高了(既支持 Http+ UDP,有支持 gRPC),服务端版本低(支持 Http + UDP)。那这个时候经过客户端和服务端协议协商后，达成一致的通信协议是 Http + UDP。那么此时客户端通信协议就采用 Http +UDP，相对于新的通信协议，就降级了，这就是<strong>客户端通信协议降级处理。</strong></p></li></ul><h2 id="服务端推送-Naming-Config-的支持"><a href="#服务端推送-Naming-Config-的支持" class="headerlink" title="服务端推送(Naming+Config)的支持"></a>服务端推送(Naming+Config)的支持</h2><ul><li>服务端推送-Naming(注册中心)</li><li>服务端推送-Config(配置中心)</li></ul><h2 id="Http-接口的改造"><a href="#Http-接口的改造" class="headerlink" title="Http 接口的改造"></a>Http 接口的改造</h2><p>Http 接口的改造，主要内容含两部分，分别是请求接口的数据和响应内容的处理。</p><ul><li><p>Http/gRPC 请求 通信数据格式的映射</p><table><thead><tr><th align="center">Http 请求</th><th align="center">gRPC 请求</th></tr></thead><tbody><tr><td align="center">URL</td><td align="center">Action</td></tr><tr><td align="center">Headers</td><td align="center">Headers</td></tr><tr><td align="center">Params</td><td align="center">Params</td></tr><tr><td align="center">Body</td><td align="center">Payload</td></tr><tr><td align="center">/</td><td align="center">其他字段按需指定</td></tr></tbody></table></li><li><p>Http/gRPC 响应 通信数据格式的映射</p><table><thead><tr><th align="center">Http 响应</th><th align="center">gRPC 响应</th></tr></thead><tbody><tr><td align="center">Response Code</td><td align="center">Response Code</td></tr><tr><td align="center">Response Body</td><td align="center">Response Payload</td></tr><tr><td align="center">Response Headers</td><td align="center">Response Headers</td></tr><tr><td align="center">/</td><td align="center">其他字段按需指定</td></tr></tbody></table><p>也就是说改为 gRPC 长连接之后，原先设置 Http 请求/响应所携带的相关数据都有具体的协议格式来于此对应，与此同时，在此基础上还丰富了原有的通信协议(例如 RequestId，Source 等)。在不失扩展性的同时，还降低了切换时数据通信改造和学习的成本。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> nacos </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos之注册中心原理解析</title>
      <link href="2020/12/21/nacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/21/nacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>注册和撤销服务，使用NamingProxy进行Http调用，使用jdk自带的Http协议API</li><li>查询服务，使用HostReactor类借助NamingProxy进行服务查询，重点是使用PushReceiver类创建UDP长连接，更新服务</li><li>subscribe/unsubscribe,使用EventDispatcher类addListener方法添加监听，重点是使用PushReceiver类创建UDP长连接，更新服务</li><li>都是使用定时任务线程池ScheduledExecutorService进行多线程处理</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="string">&quot;serverAddr&quot;</span>, System.getProperty(<span class="string">&quot;serverAddr&quot;</span>));</span><br><span class="line">properties.setProperty(<span class="string">&quot;namespace&quot;</span>, System.getProperty(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line"></span><br><span class="line">NamingService naming = NamingFactory.createNamingService(properties);</span><br><span class="line"></span><br><span class="line">naming.registerInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;11.11.11.11&quot;</span>, <span class="number">8888</span>, <span class="string">&quot;TEST1&quot;</span>);</span><br><span class="line">naming.registerInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;2.2.2.2&quot;</span>, <span class="number">9999</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">System.out.println(naming.getAllInstances(<span class="string">&quot;nacos.test.3&quot;</span>));</span><br><span class="line">naming.deregisterInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;2.2.2.2&quot;</span>, <span class="number">9999</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">System.out.println(naming.getAllInstances(<span class="string">&quot;nacos.test.3&quot;</span>));</span><br><span class="line"></span><br><span class="line">naming.subscribe(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        System.out.println(((NamingEvent)event).getServiceName());</span><br><span class="line">        System.out.println(((NamingEvent)event).getInstances());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="NamingService"><a href="#NamingService" class="headerlink" title="NamingService"></a>NamingService</h2><p>NamingService是Nacos对外提供给使用者的接口，其实现类为com.alibaba.nacos.client.naming.NacosNamingService，归纳起来，NamingService提供了以下方法：</p><ul><li>registerInstance：注册实例。</li><li>deregisterInstance：注销实例。</li><li>getAllInstances：获取某一服务的所有实例。</li><li>selectInstances：获取某一服务健康或不健康的实例。</li><li>selectOneHealthyInstance：根据权重选择一个健康的实例。</li><li>getServerStatus：检测服务端健康状态。</li><li>subscribe：注册对某个服务的监听。</li><li>unsubscribe：注销对某个服务的监听。</li><li>getSubscribeServices：获取被监听的服务。</li><li>getServicesOfServer：获取命名空间（namespace)下的所有服务名。</li></ul><h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><img src="/2020/12/21/nacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/baa968b2dce6422703ca528e5550ca19" alt="core-class" style="zoom: 50%;"><h2 id="NacosNamingService"><a href="#NacosNamingService" class="headerlink" title="NacosNamingService"></a>NacosNamingService</h2><p>NacosNamingService是NamingService接口的实现类。实现了上面提到的那些方法。此外，NacosNamingService还起到了初始化其他核心类的作用，因为对外提供的方法都是委托给其他核心类处理的。按顺序将依次初始化EventDispatcher、NamingProxy、BeatReactor、HostReactor。从NacosNamingService的构造函数我们也可以了解到，可以进行一些参数的自定义，可参考<a href="https://nacos.io/zh-cn/docs/concepts.html">官方文档</a></p><h2 id="EventDispatcher"><a href="#EventDispatcher" class="headerlink" title="EventDispatcher"></a>EventDispatcher</h2><p>EventDispatcher与其他事件分发的组件没什么不同，用于处理subscribe、unsubscribe等等与服务监听相关的方法，并分发NamingEvent到各Listener。成员变量ConcurrentMap&lt;String, List<EventListener>&gt; observerMap保存了注册的Listener，key为{服务名}@@{集群名}，value为各个EventListener的列表。EventDispatcher会启动<strong>1</strong>个名为com.alibaba.nacos.naming.client.listener的线程用于处理事件的分发。</EventListener></p><blockquote><p>注意点：</p><ul><li>分发NamingEvent时，按照subscribe(…)方法的调用顺序串行依次调用EventListener的onEvent(…)方法。</li><li>调用subscribe(…)方法会引起对应Service的事件分发。</li></ul></blockquote><h2 id="NamingProxy"><a href="#NamingProxy" class="headerlink" title="NamingProxy"></a>NamingProxy</h2><p>NamingProxy用于<strong>与Nacos服务端通信</strong>，注册服务、注销服务、发送心跳等都经由NamingProxy来请求服务端。NamingProxy会启动<strong>1</strong>个名为com.alibaba.nacos.client.naming.serverlist.updater的线程，用于定期调用refreshSrvIfNeed()方法更新Nacos服务端地址，默认间隔为<strong>30秒</strong>，对服务端API的调用将在后文总结。</p><blockquote><p>注意点：refreshSrvIfNeed()方法对Nacos服务端地址的更新仅在使用endpoint的时候才会进行实际更新，如果是通过serverAddr配置的Nacos服务端地址，refreshSrvIfNeed()方法将不会进行任何操作。</p></blockquote><h2 id="BeatReactor"><a href="#BeatReactor" class="headerlink" title="BeatReactor"></a>BeatReactor</h2><p>BeatReactor用于<strong>向Nacos服务端发送已注册服务的心跳</strong>。成员变量Map&lt;String, BeatInfo&gt; dom2Beat中保存了需要发送的BeatInfo，key为{serviceName}#{ip}#{port}，value为对应的BeatInfo。BeatReactor会启动名为com.alibaba.nacos.naming.beat.sender的线程来发送心跳，默认线程数为1~CPU核心数的一半，可由namingClientBeatThreadCount参数指定。<br>默认情况下每<strong>5秒</strong>发送一次心跳，可根据Nacos服务端返回的clientBeatInterval的值调整心跳间隔。</p><h2 id="HostReactor"><a href="#HostReactor" class="headerlink" title="HostReactor"></a>HostReactor</h2><p>HostReactor<strong>用于获取、保存、更新各Service实例信息。</strong>成员变量Map&lt;String, ServiceInfo&gt; serviceInfoMap中保存了已获取到的服务的信息，key为{服务名}@@{集群名}。HostReactor会启动名为com.alibaba.nacos.client.naming.updater的线程来更新服务信息，默认线程数为1~CPU核心数的一半，可由namingPollingThreadCount参数指定。定时任务UpdateTask会根据服务的cacheMillis值定时更新服务信息，默认值为<strong>10秒</strong>。该定时任务会在获取某一服务信息时创建，保存在成员变量Map&lt;String, ScheduledFuture&lt;?&gt;&gt; futureMap中。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="PushReceiver"><a href="#PushReceiver" class="headerlink" title="PushReceiver"></a>PushReceiver</h3><p>PushReceiver<strong>用于接收Nacos服务端的推送</strong>，初始化时会创建DatagramSocket使用UDP的方式接收推送。会启动<strong>1</strong>个名为com.alibaba.nacos.naming.push.receiver的线程。</p><h3 id="FailoverReactor"><a href="#FailoverReactor" class="headerlink" title="FailoverReactor"></a>FailoverReactor</h3><p>用于故障转移，会启动<strong>1</strong>个名为com.alibaba.nacos.naming.failover的线程并定时读取名为00-00—000-VIPSRV_FAILOVER_SWITCH-000—00-00的文件，内容为1时表示开启，此时获取服务信息时会返回FailoverReactor缓存的服务信息。</p><h3 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h3><p>根据服务实例的权重挑选一个实例，实现简单的负载均衡。</p><h3 id="DiskCache"><a href="#DiskCache" class="headerlink" title="DiskCache"></a>DiskCache</h3><p>用于服务信息的持久化。</p><h2 id="Naming-API"><a href="#Naming-API" class="headerlink" title="Naming API"></a>Naming API</h2><p>API汇总如下：</p><table><thead><tr><th>Method</th><th>URI</th><th>含义</th></tr></thead><tbody><tr><td>POST</td><td>/nacos/v1/ns/instance</td><td>注册实例</td></tr><tr><td>DELETE</td><td>/nacos/v1/ns/instance</td><td>注销实例</td></tr><tr><td>GET</td><td>/nacos/v1/ns/instance/list</td><td>获取实例列表</td></tr><tr><td>PUT</td><td>/nacos/v1/ns/instance/beat</td><td>发送心跳</td></tr><tr><td>GET</td><td>/nacos/v1/ns/api/hello</td><td>Nacos服务端状态</td></tr><tr><td>GET</td><td>/nacos/v1/ns/service/list</td><td>获取所有服务名</td></tr></tbody></table><h2 id="参数列表及示例"><a href="#参数列表及示例" class="headerlink" title="参数列表及示例"></a>参数列表及示例</h2><h3 id="注册实例"><a href="#注册实例" class="headerlink" title="注册实例"></a>注册实例</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>ip</td><td>实例IP地址</td><td></td></tr><tr><td>port</td><td>实例端口</td><td></td></tr><tr><td>weight</td><td>权重</td><td>默认为1.0</td></tr><tr><td>enable</td><td>是否开启</td><td>默认为true</td></tr><tr><td>healthy</td><td>健康状态</td><td>默认为true</td></tr><tr><td>metadata</td><td>其他信息</td><td></td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>clusterName</td><td>集群名</td><td>默认为DEFAULT</td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/instance?metadata=%7B%7D&namespaceId=public&port=8888&enable=true&healthy=true&ip=11.11.11.11&clusterName=TEST1&weight=1.0&serviceName=nacos.test.3&encoding=UTF-8&">http://localhost:8848/nacos/v1/ns/instance?metadata=%7B%7D&amp;namespaceId=public&amp;port=8888&amp;enable=true&amp;healthy=true&amp;ip=11.11.11.11&amp;clusterName=TEST1&amp;weight=1.0&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;</a></p><p>返回示例：ok</p><h3 id="注销实例"><a href="#注销实例" class="headerlink" title="注销实例"></a>注销实例</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>ip</td><td>实例IP地址</td><td></td></tr><tr><td>port</td><td>实例端口</td><td></td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>clusterName</td><td>集群名</td><td>默认为DEFAULT</td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/instance?cluster=DEFAULT&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;port=9999&amp;ip=2.2.2.2&amp;">http://localhost:8848/nacos/v1/ns/instance?cluster=DEFAULT&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;port=9999&amp;ip=2.2.2.2&amp;</a></p><p>返回示例：ok</p><h3 id="获取实例列表"><a href="#获取实例列表" class="headerlink" title="获取实例列表"></a>获取实例列表</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>clusters</td><td>集群名</td><td>默认为DEFAULT</td></tr><tr><td>udpPort</td><td>监听的UPD端口号</td><td>由PushReceiver创建</td></tr><tr><td>clientIP</td><td>客户端IP</td><td></td></tr><tr><td>healthyOnly</td><td>是否只返回健康的实例</td><td></td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/instance/list?healthyOnly=false&amp;namespaceId=public&amp;clientIP=172.16.20.114&amp;serviceName=nacos.test.3&amp;udpPort=53957&amp;encoding=UTF-8&amp;">http://localhost:8848/nacos/v1/ns/instance/list?healthyOnly=false&amp;namespaceId=public&amp;clientIP=172.16.20.114&amp;serviceName=nacos.test.3&amp;udpPort=53957&amp;encoding=UTF-8&amp;</a></p><p>返回示例：{“metadata”:{},”dom”:”nacos.test.3”,”cacheMillis”:10000,”useSpecifiedURL”:false,”hosts”:[{“valid”:true,”marked”:false,”metadata”:{},”instanceId”:”2.2.2.2#9999#DEFAULT#nacos.test.3”,”port”:9999,”ip”:”2.2.2.2”,”clusterName”:”DEFAULT”,”weight”:1.0,”serviceName”:”nacos.test.3”,”enabled”:true},{“valid”:true,”marked”:false,”metadata”:{},”instanceId”:”11.11.11.11#8888#TEST1#nacos.test.3”,”port”:8888,”ip”:”11.11.11.11”,”clusterName”:”TEST1”,”weight”:1.0,”serviceName”:”nacos.test.3”,”enabled”:true}],”checksum”:”bd1054e6afb8d10730d945d74c4ce4421550584589236”,”lastRefTime”:1550584589236,”env”:””,”clusters”:””}</p><h3 id="发送心跳"><a href="#发送心跳" class="headerlink" title="发送心跳"></a>发送心跳</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>beat</td><td>BeatInfo的JSON字符串</td><td></td></tr></tbody></table><p>BeatInfo对象结构如下，与Instance对象类似：</p><table><thead><tr><th>field</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>port</td><td>端口</td><td></td></tr><tr><td>ip</td><td>IP地址</td><td></td></tr><tr><td>weight</td><td>权重</td><td></td></tr><tr><td>metadata</td><td>其他信息</td><td></td></tr><tr><td>serviceName</td><td>服务名</td><td></td></tr><tr><td>clusterName</td><td>集群名</td><td></td></tr><tr><td>scheduled</td><td>是否心跳中</td><td>这个是BeatReactor用来标识状态的</td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/instance/beat?beat=%7B%22cluster%22:%22DEFAULT%22,%22ip%22:%222.2.2.2%22,%22metadata%22:%7B%7D,%22port%22:9999,%22scheduled%22:true,%22serviceName%22:%22nacos.test.3%22,%22weight%22:1.0%7D&serviceName=nacos.test.3&encoding=UTF-8&namespaceId=public&">http://localhost:8848/nacos/v1/ns/instance/beat?beat=%7B%22cluster%22%3A%22DEFAULT%22%2C%22ip%22%3A%222.2.2.2%22%2C%22metadata%22%3A%7B%7D%2C%22port%22%3A9999%2C%22scheduled%22%3Atrue%2C%22serviceName%22%3A%22nacos.test.3%22%2C%22weight%22%3A1.0%7D&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;</a></p><p>返回示例：{“clientBeatInterval”:5000}</p><h3 id="Nacos服务端状态"><a href="#Nacos服务端状态" class="headerlink" title="Nacos服务端状态"></a>Nacos服务端状态</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/api/hello?encoding=UTF-8&amp;namespaceId=public&amp;">http://localhost:8848/nacos/v1/ns/api/hello?encoding=UTF-8&amp;namespaceId=public&amp;</a></p><p>返回示例：{“msg”:”Hello! I am Nacos-Naming and healthy! total services: raft 2, local port:8848”}</p><h3 id="获取所有服务名"><a href="#获取所有服务名" class="headerlink" title="获取所有服务名"></a>获取所有服务名</h3><table><thead><tr><th>key</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>namespaceId</td><td>命名空间</td><td>默认为public</td></tr><tr><td>pageNo</td><td>页码</td><td>注意从1开始</td></tr><tr><td>pageSize</td><td>返回数量</td><td></td></tr><tr><td>selector</td><td>过滤器</td><td></td></tr></tbody></table><p>请求示例：<a href="http://localhost:8848/nacos/v1/ns/service/list?pageSize=100&amp;encoding=UTF-8&amp;namespaceId=public&amp;pageNo=0&amp;">http://localhost:8848/nacos/v1/ns/service/list?pageSize=100&amp;encoding=UTF-8&amp;namespaceId=public&amp;pageNo=0&amp;</a></p><p>返回示例：{“count”:1,”doms”:[“nacos.test.3”]}</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos之配置中心原理解析</title>
      <link href="2020/12/21/nacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/21/nacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>作者：逅弈<br>链接：<a href="https://www.jianshu.com/p/38b5452c9fec">https://www.jianshu.com/p/38b5452c9fec</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用长轮询机制：长轮询是在轮询基础上做的，也是不断的访问服务器，但是服务器不会即刻返回，而是等有新消息到来时再返回，或者等到超时时间到了再返回。</p><ol><li>Server端采用队列，为每一个请求创建一个专属队列</li><li>Server端有新消息进来，放入每一个请求的队列中进行返回，或者等待超时时间结束捕获异常后再返回</li></ol><p><strong>聊天室长轮询实例</strong>：</p><p>为每一个进入聊天室的用户（与<code>Server</code>端建立连接的用户）创建一个队列，每个用户轮询时都去询问自己的队列，如果没有新消息就等待，如果后端一旦接收到新消息就将消息放入对应的等待队列中返回本次请求；或者超时也返回请求    </p><h2 id="推还是拉"><a href="#推还是拉" class="headerlink" title="推还是拉"></a>推还是拉</h2><p>客户端和服务端之间的数据交互，无外乎两种情况：</p><ul><li>服务端推数据给客户端</li><li>客户端从服务端拉数据</li></ul><p>那到底是推还是拉呢，从 Nacos 客户端通过 Listener 来接收最新数据的这个做法来看，感觉像是服务端推的数据，但是不能想当然，要想知道答案，最快最准确的方法就是从源码中去寻找。</p><h3 id="创建-ConfigService"><a href="#创建-ConfigService" class="headerlink" title="创建 ConfigService"></a>创建 ConfigService</h3><p>从我们的 demo 中可以知道，首先是创建了一个 ConfigService。而 ConfigService 是通过 ConfigFactory 类创建的，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-ba05ced35148cde1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到实际是通过反射调用了 NacosConfigService 的构造方法来创建 ConfigService 的，而且是有一个 Properties 参数的构造方法。</p><p>需要注意的是，这里并没有通过单例或者缓存技术，也就是说每次调用都会重新创建一个 ConfigService的实例。</p><h3 id="实例化-ConfigService"><a href="#实例化-ConfigService" class="headerlink" title="实例化 ConfigService"></a>实例化 ConfigService</h3><p>现在我们来看下 NacosConfigService 的构造方法，看看 ConfigService 是怎么实例化的，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-f6c665c4e2de941f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>实例化时主要是初始化了两个对象，他们分别是：</p><ul><li>HttpAgent</li><li>ClientWorker</li></ul><h4 id="HttpAgent"><a href="#HttpAgent" class="headerlink" title="HttpAgent"></a>HttpAgent</h4><p>其中 agent 是通过装饰着模式实现的，ServerHttpAgent 是实际工作的类，MetricsHttpAgent 在内部也是调用了 ServerHttpAgent 的方法，另外加上了一些统计操作，所以我们只需要关心 ServerHttpAgent 的功能就可以了。</p><p>agent 实际是在 ClientWorker 中发挥能力的，下面我们来看下 ClientWorker 类。</p><h4 id="ClientWorker"><a href="#ClientWorker" class="headerlink" title="ClientWorker"></a>ClientWorker</h4><p>以下是 ClientWorker 的构造方法，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-5104c6d72e2aaa8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到 ClientWorker 除了将 HttpAgent 维持在自己内部，还创建了两个线程池：</p><p>第一个线程池是只拥有一个线程用来执行定时任务的 executor，executor 每隔 10ms 就会执行一次 checkConfigInfo() 方法，从方法名上可以知道是每 10 ms 检查一次配置信息。</p><p>第二个线程池是一个普通的线程池，从 ThreadFactory 的名称可以看到这个线程池是做长轮询的。</p><p>现在让我们来看下 executor 每 10ms 执行的方法到底是干什么的，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-9e84ab368c709db7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到，checkConfigInfo 方法是取出了一批任务，然后提交给 executorService 线程池去执行，执行的任务就是 LongPollingRunnable，每个任务都有一个 taskId。</p><p>现在我们来看看 LongPollingRunnable 做了什么，主要分为两部分，第一部分是检查本地的配置信息，第二部分是获取服务端的配置信息然后更新到本地。</p><p><strong>1.本地检查</strong></p><p>首先取出与该 taskId 相关的 CacheData，然后对 CacheData 进行检查，包括本地配置检查和监听器的 md5 检查，本地检查主要是做一个故障容错，当服务端挂掉后，Nacos 客户端可以从本地的文件系统中获取相关的配置信息，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-d973ee3fed6496df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>通过跟踪 checkLocalConfig 方法，可以看到 Nacos 将配置信息保存在了</p><p>~/nacos/config/fixed-{address}_8848_nacos/snapshot/DEFAULT_GROUP/{dataId}</p><p>这个文件中，我们看下这个文件中保存的内容，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-ba0df548e35c29fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><strong>2.服务端检查</strong></p><p>然后通过 checkUpdateDataIds() 方法从服务端获取那些值发生了变化的 dataId 列表，</p><p>通过 getServerConfig 方法，根据 dataId 到服务端获取最新的配置信息，接着将最新的配置信息保存到 CacheData 中。</p><p>最后调用 CacheData 的 checkListenerMd5 方法，可以看到该方法在第一部分也被调用过，我们需要重点关注一下。</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-4de0d8c1acc24260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到，在该任务的最后，也就是在 finally 中又重新通过 executorService 提交了本任务。</p><h3 id="添加-Listener"><a href="#添加-Listener" class="headerlink" title="添加 Listener"></a>添加 Listener</h3><p>好了现在我们可以为 ConfigService 来添加一个 Listener 了，最终是调用了 ClientWorker 的 addTenantListeners 方法，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-35b632cd90154086.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>该方法分为两个部分，首先根据 dataId，group 和当前的场景获取一个 CacheData 对象，然后将当前要添加的 listener 对象添加到 CacheData 中去。</p><p>也就是说 listener 最终是被这里的 CacheData 所持有了，那 listener 的回调方法 receiveConfigInfo 就应该是在 CacheData 中触发的。</p><p>我们发现 CacheData 是出现频率非常高的一个类，在 LongPollingRunnable 的任务中，几乎所有的方法都围绕着 CacheData 类，现在添加 Listener 的时候，实际上该 Listener 也被委托给了 CacheData，那我们要重点关注下 CacheData 类了。</p><h3 id="CacheData"><a href="#CacheData" class="headerlink" title="CacheData"></a>CacheData</h3><p>首先让我们来看一下 CacheData 中的成员变量，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-d3e711176c9987b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1036/format/webp" alt="img"></p><p>可以看到除了 dataId，group，content，taskId 这些跟配置相关的属性，还有两个比较重要的属性：listeners、md5。</p><p>listeners 是该 CacheData 所关联的所有 listener，不过不是保存的原始的 Listener 对象，而是包装后的 ManagerListenerWrap 对象，该对象除了持有 Listener 对象，还持有了一个 lastCallMd5 属性。</p><p>另外一个属性 md5 就是根据当前对象的 content 计算出来的 md5 值。</p><h3 id="触发回调"><a href="#触发回调" class="headerlink" title="触发回调"></a>触发回调</h3><p>现在我们对 ConfigService 有了大致的了解了，现在剩下最后一个重要的问题还没有答案，那就是 ConfigService 的 Listener 是在什么时候触发回调方法 receiveConfigInfo 的。</p><p>现在让我们回过头来想一下，在 ClientWorker 中的定时任务中，启动了一个长轮询的任务：LongPollingRunnable，该任务多次执行了 cacheData.checkListenerMd5() 方法，那现在就让我们来看下这个方法到底做了些什么，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-252a0c5c6da61070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1088/format/webp" alt="img"></p><p>到这里应该就比较清晰了，该方法会检查 CacheData 当前的 md5 与 CacheData 持有的所有 Listener 中保存的 md5 的值是否一致，如果不一致，就执行一个安全的监听器的通知方法：safeNotifyListener，通知什么呢？我们可以大胆的猜一下，应该是通知 Listener 的使用者，该 Listener 所关注的配置信息已经发生改变了。现在让我们来看一下 safeNotifyListener 方法，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-991eeb4ef41b05fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>可以看到在 safeNotifyListener 方法中，重点关注下红框中的三行代码：获取最新的配置信息，调用 Listener 的回调方法，将最新的配置信息作为参数传入，这样 Listener 的使用者就能接收到变更后的配置信息了，最后更新 ListenerWrap 的 md5 值。和我们猜测的一样， Listener 的回调方法就是在该方法中触发的。</p><h3 id="Md5何时变更"><a href="#Md5何时变更" class="headerlink" title="Md5何时变更"></a>Md5何时变更</h3><p>那 CacheData 的 md5 值是何时发生改变的呢？我们可以回想一下，在上面的 LongPollingRunnable 所执行的任务中，在获取服务端发生变更的配置信息时，将最新的 content 数据写入了 CacheData 中，我们可以看下该方法如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5417792-1a99dccdefa936cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/826/format/webp" alt="img"></p><p>可以看到是在长轮询的任务中，当服务端配置信息发生变更时，客户端将最新的数据获取下来之后，保存在了 CacheData 中，同时更新了该 CacheData 的 md5 值，所以当下次执行 checkListenerMd5 方法时，就会发现当前 listener 所持有的 md5 值已经和 CacheData 的 md5 值不一样了，也就意味着服务端的配置信息发生改变了，这时就需要将最新的数据通知给 Listener 的持有者。</p><p>至此配置中心的完整流程已经分析完毕了，可以发现，Nacos 并不是通过推的方式将服务端最新的配置信息发送给客户端的，而是客户端维护了一个长轮询的任务，定时去拉取发生变更的配置信息，然后将最新的数据推送给 Listener 的持有者。</p><h3 id="拉的优势"><a href="#拉的优势" class="headerlink" title="拉的优势"></a>拉的优势</h3><p>客户端拉取服务端的数据与服务端推送数据给客户端相比，优势在哪呢，为什么 Nacos 不设计成主动推送数据，而是要客户端去拉取呢？如果用推的方式，服务端需要维持与客户端的长连接，这样的话需要耗费大量的资源，并且还需要考虑连接的有效性，例如需要通过心跳来维持两者之间的连接。而用拉的方式，客户端只需要通过一个无状态的 http 请求即可获取到服务端的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Nacos 服务端创建了相关的配置项后，客户端就可以进行监听了。</p><p>客户端是通过一个定时任务来检查自己监听的配置项的数据的，一旦服务端的数据发生变化时，客户端将会获取到最新的数据，并将最新的数据保存在一个 CacheData 对象中，然后会重新计算 CacheData 的 md5 属性的值，此时就会对该 CacheData 所绑定的 Listener 触发 receiveConfigInfo 回调。</p><p>考虑到服务端故障的问题，客户端将最新数据获取后会保存在本地的 snapshot 文件中，以后会优先从文件中获取配置信息的值。</p><p>长轮询请求设置的超时时间为30s。服务端拿到客户端提交的超时时间后，又减去了 500ms 也就是说服务端在这里使用了一个比客户端提交的时间少 500ms 的超时时间，也就是 29.5s。</p><p>ClientLongPolling 被提交给 scheduler 执行之后，实际执行的内容可以拆分成以下四个步骤：</p><ul><li>1.创建一个调度的任务，调度的延时时间为 29.5s</li><li>2.将该 ClientLongPolling 自身的实例添加到一个 allSubs 中去</li><li>3.延时时间到了之后，首先将该 ClientLongPolling 自身的实例从 allSubs 中移除</li><li>4.获取服务端中保存的对应客户端请求的 groupKeys 是否发生变更，将结果写入 response 返回给客户端</li></ul><p><img src="/2020/12/21/nacos%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20210113114155184.png" alt="image-20210113114155184"></p><p><a href="https://www.jianshu.com/p/acb9b1093a54">Nacos 配置实时更新原理分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos之简单使用</title>
      <link href="2020/12/21/nacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/21/nacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="nacos作用"><a href="#nacos作用" class="headerlink" title="nacos作用"></a>nacos作用</h2><ul><li>配置中心</li><li>注册中心</li></ul><h2 id="nacos组成"><a href="#nacos组成" class="headerlink" title="nacos组成"></a>nacos组成</h2><ul><li>服务端（记录配置信息及注册服务）</li><li>客户端（通过客户端获取配置和注册的服务信息）</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h3><p><img src="/2020/12/21/nacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5417792-3f740507702e5345.png" alt="img"></p><p>执行后将打印如下信息：<br><img src="/2020/12/21/nacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5417792-bbb7c19dd26d12e7.png" alt="img"></p><h3 id="修改配置信息"><a href="#修改配置信息" class="headerlink" title="修改配置信息"></a>修改配置信息</h3><img src="/2020/12/21/nacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5417792-817fcfe4227320fa.png" alt="img" style="zoom: 33%;"><p>修改完配置，点击 “发布” 按钮后，客户端将会收到最新的数据，如下图所示：<br><img src="/2020/12/21/nacos%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5417792-f64c8649f23cde67.png" alt="img" style="zoom:50%;"></p><h2 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring-cloud"></a>spring-cloud</h2><h3 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">10.16</span><span class="number">.35</span><span class="number">.74</span><span class="string">:8848,10.16.32.168:8848,10.16.35.243:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">quixmart2</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">dbf20920b03e6ee725a681a47e4eecec</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">&#x27;yml&#x27;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">&#x27;646e3782-3a6f-46db-9b8c-6cae7f620be1&#x27;</span></span><br><span class="line">        <span class="comment"># 读取公共中间件配置</span></span><br><span class="line">        <span class="string">ext-config[0]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">mysql.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[1]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">redis.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[2]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">rabbitmq.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[3]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">mongodb.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[4]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">elasticjob.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">        <span class="string">ext-config[5]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">mqtt.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">PUBLIC</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">10.16</span><span class="number">.35</span><span class="number">.74</span><span class="string">:8848,10.16.32.168:8848,10.16.35.243:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">quixmart2</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">dbf20920b03e6ee725a681a47e4eecec</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">&#x27;646e3782-3a6f-46db-9b8c-6cae7f620be1&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> nacos </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之字节及字符等详解</title>
      <link href="2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>1.bit:位 （小写b) 也称比特</strong></p><p>是英文 binary digit的缩写 二进制数系统中，每个0或1就是一个位(bit)<br>位是数据存储（计算机中信息）的最小单位<br>计算机中的CPU位数指的是CPU一次能处理的最大位数。例如32位计算机的CPU一次最多能处理32位数据</p><p><strong>2.Byte:字节(大写B)</strong></p><p>8bit就称为一个字节（Byte）, 1Byte=8bit<br>记为Byte或B,是计算机中信息的基本单位</p><p><strong>3.区别</strong><br><img src="/2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/180125-20191106131450465-1166740117.png" alt="img"></p><p> <strong>实例</strong></p><p>bps 是 bits per second 的简称。一般数据机及网络通讯的传输速率都是以「bps」比特/位为单位。如 56Kbps、100.0Mbps 等。<br>Bps 是 Byte per second 的简称。而电脑一般都以「Bps」字节/速度为单位，如 1Mb/s(Mbps) 大约等同 128 KB/s(KBps)。<br>举例：USB 2.0 接口传输速率为 “480Mbps”，很多人误解为 480 兆/秒，实际 “480Mbps” 是指 “480 兆比特/秒” 或 “480 兆位/秒”，等于 “60 兆字节/秒”。</p><p><strong>4.相关换算</strong><br>1个字母=1个字节=8bit(8位)</p><p>1个数字=1个字节=8bit(8位)</p><p>1个汉字=2个字节=16bit(16位)</p><p>1 Byte = 8 Bits</p><p>1 KB = 1024 Bytes</p><p>1 MB = 1024 KB</p><p>1 GB = 1024 MB</p><p><strong>char与byte的区别</strong></p><p> <strong><em>\</em>byte 是字节数据类型 ，是有符号型的，占1 个字节；大小范围为-128—127 。char 是字符数据类型 ，是无符号型的，占2字节(Unicode\</strong>*<em>码*</em> *<em>）；大小*</em>*<em>范围*</em> *<em>是*</em>*<em>0*</em>*<em>—*</em>*<em>65535*</em> *<em>；*</em>*<em>char是一个16位二进制的Unicode字符，JAVA用char来表示一个字符*</em> *<em>。***</em></p><p>通过代码示例来比较二者区别：</p><p>1、Char是无符号型的，可以表示一个整数，不能表示负数；而byte是有符号型的，可以表示-128—127 的数；如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>) -<span class="number">90</span>; <span class="comment">// char不能识别负数，必须强制转换否则报错，即使强制转换之后，也无法识别 </span></span><br><span class="line">System.out.println(c); </span><br><span class="line"><span class="keyword">byte</span> d1 = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">byte</span> d2 = -<span class="number">1</span>; </span><br><span class="line"><span class="keyword">byte</span> d3 = <span class="number">127</span>; <span class="comment">// 如果是byte d3 = 128;会报错 </span></span><br><span class="line"><span class="keyword">byte</span> d4 = -<span class="number">128</span>; <span class="comment">// 如果是byte d4 = -129;会报错 </span></span><br><span class="line">System.out.println(d1); </span><br><span class="line">System.out.println(d2); </span><br><span class="line">System.out.println(d3); </span><br><span class="line">System.out.println(d4); </span><br></pre></td></tr></table></figure><img src="/2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/20180622151733747" alt="img" style="zoom:80%;"><p>2、char可以表中文字符，byte不可以，如：<br>​    char e1 = ‘我’, e2 = ‘你’;<br>​    byte f= (byte) ‘他’; //必须强制转换否则报错<br>​    System.out.println(e1);<br>​    System.out.println(e2);<br>​    System.out.println(f);<br><img src="/2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/20180622152135220" alt="img"></p><p>3、char、byte、int对于英文字符，可以相互转化，如：<br>​    byte g = ‘a’;  //b对应ASCII是98<br>​    char h = (char) g;<br>​    char i = 85;  //U对应ASCII是85<br>​    int j = ‘h’;  //h对应ASCII是104<br>​    System.out.println(g);<br>​    System.out.println(h);<br>​    System.out.println(i);<br>​    System.out.println(j);<br><img src="/2020/12/18/java%E4%B9%8B%E5%AD%97%E8%8A%82%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%AD%89%E8%AF%A6%E8%A7%A3/20180622152512662" alt="img"></p><p><strong>参考</strong></p><p><a href="https://www.cnblogs.com/tmtony/p/11804575.html">bit(比特)与Byte(字节)的区别与关系</a></p><p><a href="https://blog.csdn.net/m0_37846887/article/details/80774131">char与byte的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名词解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之IO流详解</title>
      <link href="2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/yichunguo/">宜春</a></p><p>出处：<a href="https://www.cnblogs.com/yichunguo/p/11775270.html">https://www.cnblogs.com/yichunguo/p/11775270.html</a></p><p>io流用到的地方很多，就比如上传下载，传输，设计模式等….基础打扎实了，才能玩更高端的。</p><p>真正懂IO流的优秀程序员每次在使用IO流之前都会明确分析如下四点：</p><blockquote><p>（1）明确要操作的数据是数据源还是数据目的(也就是要读还是要写)<br>（2）明确要操作的设备上的数据是字节还是文本<br>（3）明确数据所在的具体设备<br>（4）明确是否需要额外功能（比如是否需要转换流、高效流等）</p></blockquote><h1 id="1、IO流的四点明确"><a href="#1、IO流的四点明确" class="headerlink" title="1、IO流的四点明确"></a>1、IO流的四点明确</h1><p>（1）明确要操作的数据是数据源还是数据目的(要读还是要写)</p><blockquote><p>　源：<strong>InputStream　　Reader</strong><br>目的：<strong>OutputStream　　Writer</strong><br>（2）明确要操作的设备上的数据是字节还是文本<br>　源：字节： <strong>InputStream</strong>    文本： <strong>Reader</strong><br>目的：字节： <strong>OutputStream</strong>  文本： <strong>Writer</strong><br>（3）明确数据所在的具体设备<br>　　　源设备：<br>　　　　　　　　硬盘：文件 <code>File</code>开头<br>　　　　　　　　内存：数组，字符串<br>　　　　　　　　键盘：<code>System.in</code><br>　　　　　　　　网络：<code>Socket</code><br>　　对应目的设备：<br>　　　　　　　　硬盘：文件 <code>File</code>开头<br>　　　　　　　　内存：数组，字符串<br>　　　　　　　　屏幕：<code>System.out</code><br>　　　　　　　　网络：<code>Socket</code><br>（4）明确是否需要额外功能<br>　　需要转换—— 转换流 <strong>InputStreamReader 、OutputStreamWriter</strong><br>　　需要高效—— 缓冲流<strong>Bufferedxxx</strong><br>　　多个源—— 序列流 <strong>SequenceInputStream</strong><br>　　对象序列化—— <strong>ObjectInputStream、ObjectOutputStream</strong><br>　　保证数据的输出形式—— 打印流<strong>PrintStream 、Printwriter</strong><br>　　操作基本数据，保证字节原样性——<strong>DataOutputStream、DataInputStream</strong><br>到这里，我们再来看看IO流的分类吧<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014111930276.png" alt="在这里插入图片描述"></p></blockquote><h1 id="2、File类"><a href="#2、File类" class="headerlink" title="2、File类"></a>2、File类</h1><p>至于IO流，也就是输入输出流，从文件出发到文件结束，至始至终都离不开文件，所以IO流还得从文件File类讲起。</p><h2 id="1-1-File概述"><a href="#1-1-File概述" class="headerlink" title="1.1 File概述"></a>1.1 File概述</h2><p><code>java.io.File</code> 类是专门对文件进行操作的类，只能对文件本身进行操作，不能对文件内容进行操作。<br><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><p>怎么理解上面两句话？其实很简单！</p><p>第一句就是说File跟流无关，File类不能对文件进行读和写也就是输入和输出！<br>第二句就是说File主要表示类似<code>D:\\文件目录1</code>与<code>D:\\文件目录1\\文件.txt</code>,前者是文件夹（Directory）后者则是文件(file)，而File类就是操作这两者的类。</p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><p>在java中，一切皆是对象，File类也不例外，不论是哪个对象都应该从该对象的构造说起，所以博主来分析分析<code>File</code>类的构造方法。首先从API开始着手<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013095030887.png" alt="在这里插入图片描述"><br>我们主要来学习一下比较常用的三个：</p><p>1、 <code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。<br>2、 <code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。<br>3、 <code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。</p><p>看字描述不够生动不够形象不得劲？没得事，下面进行构造举例，马上就生动形象了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 一个File对象代表硬盘中实际存在的一个文件或者目录。</span><br><span class="line"><span class="number">2.</span>  File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。</span><br><span class="line"><span class="comment">// 文件路径名 </span></span><br><span class="line">String path = <span class="string">&quot;D:\\123.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(path); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String path2 = <span class="string">&quot;D:\\1\\2.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path2);     -------------相当于D:\\<span class="number">1</span>\\<span class="number">2.</span>txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;F:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);  --------相当于F:\\aaa\\bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;F:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child); --------相当于F:\\aaa\\bbb.txt</span><br></pre></td></tr></table></figure><blockquote><p>File类的注意点：</p><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><p>File的常用方法主要分为获取功能、获取绝对路径和相对路径、判断功能、创建删除功能的方法</p><h3 id="1-3-1-获取功能的方法"><a href="#1-3-1-获取功能的方法" class="headerlink" title="1.3.1 获取功能的方法"></a>1.3.1 获取功能的方法</h3><p>1、<code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。<br>2、<code>public String getPath()</code> ：将此File转换为路径名字符串。<br>3、<code>public String getName()</code> ：返回由此File表示的文件或目录的名称。<br>4、<code>public long length()</code> ：返回由此File表示的文件的长度。<br>以上方法测试，代码如下【注意测试以自己的电脑文件夹为准】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">2116</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">3236</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>length()</code>，表示文件的长度。但是<code>File</code>对象表示目录，则返回值未指定。</p></blockquote><h3 id="1-3-2-绝对路径和相对路径"><a href="#1-3-2-绝对路径和相对路径" class="headerlink" title="1.3.2 绝对路径和相对路径"></a>1.3.2 绝对路径和相对路径</h3><p><strong>绝对路径</strong>：一个完整的路径，以盘符开头，例如<code>F://aaa.txt</code>。<br><strong>相对路径</strong>：一个简化的路径，不以盘符开头,例如<code>//aaa.txt//b.txt</code>。</p><blockquote><p>1、<strong>路径是不区分大小写</strong><br>2、路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\java\bbb.java</span><br></pre></td></tr></table></figure><h3 id="1-3-3判断功能的方法"><a href="#1-3-3判断功能的方法" class="headerlink" title="1.3.3判断功能的方法"></a>1.3.3判断功能的方法</h3><p>1、 <code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。<br>2、 <code>public boolean isDirectory()</code> ：此File表示的是否为目录。<br>3、<code>public boolean isFile()</code> ：此File表示的是否为文件。</p><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-创建删除功能的方法"><a href="#1-3-4-创建删除功能的方法" class="headerlink" title="1.3.4 创建删除功能的方法"></a>1.3.4 创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：文件不存在，创建一个新的空文件并返回<code>true</code>，文件存在，不创建文件并返回<code>false</code>。</li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。</li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>其中，<code>mkdirs()</code>和<code>mkdir()</code>方法类似，但<code>mkdir()</code>，只能创建一级目录，<code>mkdirs()</code>可以创建多级目录比如<code>//a//b//c</code>，所以<strong>开发中一般用</strong><code>mkdirs()</code>;</p><blockquote><p>这些方法中值得注意的是<strong>createNewFile</strong>方法以及<strong>mkdir</strong>与<strong>mkdirs</strong>的区别</p></blockquote><p>方法测试，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// 以及创建过了所以再使用createNewFile返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 目录的创建</span></span><br><span class="line">      File f2= <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">      File f3= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 文件的删除</span></span><br><span class="line">       System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>delete</code>方法，如果此<code>File</code>表示目录，则目录必须为空才能删除。</p></blockquote><h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;G:\光标&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013114927925.png" alt="在这里插入图片描述"><br><strong>listFiles</strong>在获取指定目录下的文件或者文件夹时必须满足下面两个条件</p><p>1，<strong>指定的目录必须存在</strong></p><p>2，<strong>指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException异常</strong></p><h2 id="1-5-递归遍历文件夹下所有文件以及子文件"><a href="#1-5-递归遍历文件夹下所有文件以及子文件" class="headerlink" title="1.5 递归遍历文件夹下所有文件以及子文件"></a>1.5 递归遍历文件夹下所有文件以及子文件</h2><p>不说啥了，直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归遍历文件夹下所有的文件</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RecursionDirectory</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">      File file=<span class="keyword">new</span> File(<span class="string">&quot;D:\\java专属IO测试&quot;</span>);</span><br><span class="line">        Recursion(file);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">Recursion</span>(<span class="params">File file</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1、判断传入的是否是目录</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">!file.isDirectory()</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//不是目录直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经确保了传入的file是目录</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">//遍历files</span></span><br><span class="line">        <span class="keyword">for</span> (File f: files) &#123;</span><br><span class="line">            <span class="comment">//如果该目录下文件还是个文件夹就再进行递归遍历其子目录</span></span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">f.isDirectory()</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                Recursion(f);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果该目录下文件是个文件，则打印对应的名字</span></span><br><span class="line">                System.out.println(f.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对上面的代码有疑问，可以随时联系我，博主一直都在！</p><h1 id="3、初探IO流"><a href="#3、初探IO流" class="headerlink" title="3、初探IO流"></a>3、初探IO流</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>我想在座各位肯定经历都过这样的场景。当你编辑一个文本文件也好用eclipse打代码也罢，忘记了<code>ctrl+s</code> ，在你关闭文件的哪一瞬间手残点了个不该点的按钮，但你反应过来，心早已拔凉拔凉的了。</p><p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入也叫做读取数据，输出也叫做作写出数据</strong>。</p><h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong> 和 <strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。</li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>根据数据的类型分为：<strong>字节流</strong> 和 <strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><p><strong>分类之后对应的超类</strong>（V8提示：超类也就是父类的意思）</p><table><thead><tr><th></th><th>输入流</th><th>输出流</th></tr></thead><tbody><tr><td>字节流</td><td>字节输入流 <strong>InputStream</strong></td><td>字节输出流 <strong>OutputStream</strong></td></tr><tr><td>字符流</td><td>字符输入流 <strong>Reader</strong></td><td>字符输出流 <strong>Writer</strong></td></tr></tbody></table><p><strong>注</strong>：<br><strong>由这四个类的子类名称基本都是以其父类名作为子类名的后缀</strong>。<br>如：InputStream的子类FileInputStream。<br>如：Reader的子类FileReader。<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/image-20201217200816367.png" alt="image-20201217200816367" style="zoom:80%;"></p><h2 id="1-3-关于IO的分流向说明"><a href="#1-3-关于IO的分流向说明" class="headerlink" title="1.3 关于IO的分流向说明"></a>1.3 关于IO的分流向说明</h2><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013151622369.png" alt="在这里插入图片描述" style="zoom:80%;"><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015144401127.png" alt="在这里插入图片描述" style="zoom:80%;"><h2 id="字节流OutputStream与InputStream的故事"><a href="#字节流OutputStream与InputStream的故事" class="headerlink" title="字节流OutputStream与InputStream的故事"></a>字节流OutputStream与InputStream的故事</h2><p>OutputStream与InputStream的继承关系<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015145625281.png" alt="在这里插入图片描述" style="zoom:80%;"></p><h2 id="2-1-文件的世界里一切皆为字节"><a href="#2-1-文件的世界里一切皆为字节" class="headerlink" title="2.1 文件的世界里一切皆为字节"></a>2.1 文件的世界里一切皆为字节</h2><p>我们必须明确一点的是，一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h2 id="2-2-字节输出流（OutputStream）"><a href="#2-2-字节输出流（OutputStream）" class="headerlink" title="2.2 字节输出流（OutputStream）"></a>2.2 字节输出流（OutputStream）</h2><p><code>java.io.OutputStream</code>抽象类是表示<strong>字节输出流</strong>的所有类的<strong>超类</strong>（父类），将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法，不要问我<code>OutputStream</code>为啥可以定义字节输出流的基本共性功能方法，熊dei啊，上一句说过了<strong>OutputStream是字节输出流的所有类的超类</strong>，<a href="https://blog.csdn.net/qq_44543508/article/details/102375196">继承</a>知识，懂？(如果是真的不理解的小白同学，可以点击蓝色字体<a href="https://blog.csdn.net/qq_44543508/article/details/102375196">继承</a>进入补习)</p><p><strong>字节输出流的基本共性功能方法</strong>:</p><blockquote><p>1、 <code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。<br>2、 <code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。<br>3、 <code>public void write(byte[] b)</code>：将 b.length个字节从指定的字节数组写入此输出流。<br>4、 <code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 <strong>也就是说从off个字节数开始读取一直到len个字节结束</strong><br>5、 <code>public abstract void write(int b)</code> ：将指定的字节输出流。</p></blockquote><blockquote><p><strong>以上五个方法则是字节输出流都具有的方法，由父类OutputStream定义提供，子类都会共享以上方法</strong></p></blockquote><h4 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h4><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类FileOutputStream开始。看名字就知道是文件输出流，用于将数据写出到文件。</p><h4 id="FileOutputStream构造方法"><a href="#FileOutputStream构造方法" class="headerlink" title="FileOutputStream构造方法"></a>FileOutputStream构造方法</h4><p>不管学啥子，只有是对象，就从构造方法开始！</p><blockquote><p>1、 <code>public FileOutputStream(File file)</code>：根据File对象为参数创建对象。<br>2、 <code>public FileOutputStream(String name)</code>： 根据名称字符串为参数创建对象。</p></blockquote><p><strong>推荐第二种构造方法</strong>【开发常用】：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;abc.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>就以上面这句代码来讲，类似这样创建字节输出流对象都做了<strong>三件事情</strong>：<br>1、调用系统功能去创建文件【输出流对象才会自动创建】<br>2、创建outputStream对象<br>3、把foutputStream对象指向这个文件</p><blockquote><p>注意：<br>创建输出流对象的时候，系统会自动去对应位置创建对应文件，而创建输出流对象的时候，文件不存在则会报FileNotFoundException异常，也就是系统找不到指定的文件异常。</p></blockquote><p>当你创建一个流对象时，必须直接或者间接传入一个文件路径。比如现在我们创建一个<code>FileOutputStream</code>流对象，在该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。有兴趣的童鞋可以测试一下，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\自动创建的文件夹\\a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FileOutputStream写出字节数据"><a href="#FileOutputStream写出字节数据" class="headerlink" title="FileOutputStream写出字节数据"></a>FileOutputStream写出字节数据</h4><p>使用FileOutputStream写出字节数据主要通过<code>Write</code>方法，而<code>write</code>方法分如下三种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> write(int b)</span><br><span class="line">public <span class="keyword">void</span> write(byte[] b)</span><br><span class="line">public <span class="keyword">void</span> write(byte[] b,int off,int len)  <span class="comment">//从`off`索引开始，`len`个字节</span></span><br></pre></td></tr></table></figure><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">      fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><blockquote><ol><li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">&quot;麻麻我想吃烤山药&quot;</span>.getBytes();</span><br><span class="line">      <span class="comment">// 写出字节数组数据</span></span><br><span class="line">      fos.write(b);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">麻麻我想吃烤山药</span><br></pre></td></tr></table></figure><ol><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从<code>off</code>索引开始，<code>len</code>个字节，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure><h4 id="FileOutputStream实现数据追加续写、换行"><a href="#FileOutputStream实现数据追加续写、换行" class="headerlink" title="FileOutputStream实现数据追加续写、换行"></a>FileOutputStream实现数据追加续写、换行</h4><p>经过以上的代码测试，每次程序运行，每次创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续<strong>追加新数据</strong>呢？并且实现<strong>换行</strong>呢？其实很简单，这个时候我们又要再学习<code>FileOutputStream</code>的另外两个构造方法了，如下：</p><p>1、<code>public FileOutputStream(File file, boolean append)</code></p><p>2、<code>public FileOutputStream(String name, boolean append)</code></p><p>这两个构造方法，第二个参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示不追加也就是清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，至于Windows换行则是 <code>\n\r</code> ，下面将会详细讲到。</p><p>实现数据追加续写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure><p>Windows系统里，换行符号是<code>\r\n</code> ,具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      <span class="comment">// 定义字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          <span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>回车符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\r</span><br></pre></td></tr></table></figure><p>和换行符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n</span><br></pre></td></tr></table></figure></li></ul><p>  ：</p><ul><li><p>回车符：回到一行的开头（return）。</p></li><li><p>换行符：下一行（newline）。</p></li><li><p>系统中的换行：</p><ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h2 id="2-3-字节输入流（InputStream）"><a href="#2-3-字节输入流（InputStream）" class="headerlink" title="2.3 字节输入流（InputStream）"></a>2.3 字节输入流（InputStream）</h2><p><code>java.io.InputStream</code>抽象类是表示<strong>字节输入流</strong>的所有类的<strong>超类</strong>（父类），可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><p><strong>字节输入流的基本共性功能方法</strong>:</p><blockquote><p>1、 <code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。<br>2、<code>public abstract int read()</code>： 从输入流读取数据的下一个字节。</p><p>3、 <code>public int read(byte[] b)</code>： 该方法返回的int值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1</p></blockquote><h4 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h4><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p><h4 id="FileInputStream的构造方法"><a href="#FileInputStream的构造方法" class="headerlink" title="FileInputStream的构造方法"></a>FileInputStream的构造方法</h4><blockquote><p>1、 <code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。<br>2、 <code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。</p></blockquote><p>同样的，推荐使用第二种构造方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FileInputStream读取字节数据"><a href="#FileInputStream读取字节数据" class="headerlink" title="FileInputStream读取字节数据"></a>FileInputStream读取字节数据</h4><ol><li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码测试如下【read.txt文件中内容为abcde】：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);<span class="comment">//read.txt文件中内容为abcde</span></span><br><span class="line">      <span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">      <span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>循环改进读取方式，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ol><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// read.txt文件中内容为abcde</span></span><br><span class="line">      <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure><p>由于<code>read.txt</code>文件中内容为<code>abcde</code>，而错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全<strong>替换</strong>【注意是替换，看下图】，所以要通过<code>len</code> ，获取有效的字节<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015160242904.png" alt="在这里插入图片描述" style="zoom:80%;"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure><p>在开发中一般强烈推荐使用数组读取文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">input2</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>)</span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">            int len = <span class="number">0</span> ;</span><br><span class="line">            byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="built_in">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字节流FileInputstream复制图片"><a href="#字节流FileInputstream复制图片" class="headerlink" title="字节流FileInputstream复制图片"></a>字节流FileInputstream复制图片</h4><p><strong>复制图片原理</strong><br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191013204020152.png" alt="在这里插入图片描述" style="zoom:80%;"></p><p><strong>代码实现</strong></p><p>复制图片文件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：<strong>复制文本、图片、mp3、视频等的方式一样</strong>。</p><p>到这里，已经从File类讲到了字节流OutputStream与InputStream，而现在将主要从字符流Reader和Writer的故事开展。</p><h1 id="字符流Reader和Writer的故事"><a href="#字符流Reader和Writer的故事" class="headerlink" title="字符流Reader和Writer的故事"></a>字符流Reader和Writer的故事</h1><p>字符流Reader和Writer的故事从它们的继承图开始，啥都不说了，直接看图<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191015171311217.png" alt="在这里插入图片描述" style="zoom:80%;"></p><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p>字符流的由来：因为数据编码的不同，因而有了对字符进行高效操作的流对象，字符流本质其实就是基于字节流读取时，去查了指定的码表，而字节流直接读取数据会有乱码的问题（读中文会乱码），这个时候小白同学就看不懂了，没事，咋们先来看个程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//FileInputStream为操作文件的字符输入流</span></span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//内容为哥敢摸屎</span></span><br><span class="line"></span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print((char)len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：   ??￥??￠????±</span><br></pre></td></tr></table></figure><p>具体现状分析<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014113505625.png" alt="在这里插入图片描述" style="zoom:80%;"><br>话说，就是你哥我敢摸si,那你哥我肯定也不认识这玩意啊： <code>??￥??￠????±</code></p><blockquote><p>字节流读取中文字符时，可能不会显示完整的字符，那是因为一个中文字符占用多个字节存储。</p></blockquote><p>那字节流就没办法了吗？不，字节流依旧有办法，只是麻烦了点，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        byte[] bytes = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print(<span class="keyword">new</span> <span class="built_in">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果： 哥敢摸屎</span><br></pre></td></tr></table></figure><p>这是为啥呢？没错解码的正是<code>String</code>，查看<code>new String()</code>的源码，<code>String</code>构造方法有解码功能，并且默认编码是<code>utf-8</code>，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line"> </span><br><span class="line"> 再点进decode，循序渐进发现，默认编码是UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>尽管字节流也能有办法决绝乱码问题，但是还是比较麻烦，于是java就有了字符流，<code>字符为单位</code>读写数据，字符流<code>专门用于处理文本</code>文件。如果处理纯文本的数据优先考虑字符流，其他情况就只能用字节流了（图片、视频、等等<code>只文本</code>例外）。</p><blockquote><p>从另一角度来说：<strong>字符流 = 字节流 + 编码表</strong></p></blockquote><h1 id="1、-字符输入流（Reader）"><a href="#1、-字符输入流（Reader）" class="headerlink" title="1、 字符输入流（Reader）"></a>1、 字符输入流（Reader）</h1><p><code>java.io.Reader</code>抽象类是<strong>字符输入流</strong>的所有类的<strong>超类</strong>（父类），可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><p><strong>字符输入流的共性方法</strong>：</p><blockquote><p>1、<code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。<br>2、 <code>public int read()</code>： 从输入流读取一个字符。<br>3、 <code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</p></blockquote><h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote><p>1、<code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的<strong>File对象</strong>。<br>2、 <code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的<strong>字符串名称</strong>。</p></blockquote><p>构造方法的使用就算不写应该都很熟悉了吧，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileReader读取字符数据"><a href="#FileReader读取字符数据" class="headerlink" title="FileReader读取字符数据"></a>FileReader读取字符数据</h3><ol><li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于读取的写法类似字节流的写法，只是读取单位不同罢了。</p><h1 id="2、字符输出流（Writer）"><a href="#2、字符输出流（Writer）" class="headerlink" title="2、字符输出流（Writer）"></a>2、字符输出流（Writer）</h1><p><code>java.io.Writer</code>抽象类是<strong>字符输出流</strong>的所有类的<strong>超类</strong>（父类），将指定的字符信息写出到目的地。它同样定义了字符输出流的基本共性功能方法。</p><p><strong>字符输出流的基本共性功能方法</strong>：</p><blockquote><p>1、<code>void write(int c)</code> 写入单个字符。<br>2、<code>void write(char[] cbuf)</code>写入字符数组。<br>3、 <code>abstract void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>4、 <code>void write(String str)</code>写入字符串。<br>5、<code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>6、<code>void flush()</code>刷新该流的缓冲。<br>7、<code>void close()</code> 关闭此流，但要先刷新它。</p></blockquote><h2 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h2><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、 <code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。<br>2、<code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</p><p>依旧是熟悉的构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种：使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 第二种：使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileWriter写出数据"><a href="#FileWriter写出数据" class="headerlink" title="FileWriter写出数据"></a>FileWriter写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">      fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC</span><br></pre></td></tr></table></figure><blockquote><p>【注意】<strong>关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</strong></p></blockquote><h3 id="关闭close和刷新flush"><a href="#关闭close和刷新flush" class="headerlink" title="关闭close和刷新flush"></a>关闭close和刷新flush</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><p><code>flush</code> ：刷新缓冲区，流对象可以继续使用。<br><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p><p>flush还是比较有趣的，童鞋们不自己运行一下还真不好体会，现在博主就写个程序让你体会体会：<br>字符流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlushDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//源   也就是输入流【读取流】 读取a.txt文件</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);  <span class="comment">//必须要存在a.txt文件，否则报FileNotFoundException异常</span></span><br><span class="line">        <span class="comment">//目的地  也就是输出流</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);  <span class="comment">//系统会自动创建b.txt，因为它是输出流！</span></span><br><span class="line">        int len;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(len=fr.read())!=-<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">           fw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">   注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014222100212.png" alt="在这里插入图片描述" style="zoom:80%;">运行效果是怎么样的呢？答案是b.txt文件中依旧是空的，是的并没有任何东西，为啥呢？熊dei啊，我在上面就用红色字体特别标注过了，就是这句话： 【注意】**关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。**这个时候反应过来了吧，可见实践例子的重要性，**编程就是这样，不去敲，永远学不会**！！！所以一定要去敲，博主没敲过10万行代码真的没有脸出去说自己是学java的。所以，大家一定要多思考，多敲啊！！！<p>所以，我们在以上的代码中再添加下面三句代码，就完美了，b.txt文件就能复制到源文件的数据了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fr.close();</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure><blockquote><p><code>flush()</code>这个函数是清空的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再用数据写到文件中，那么当你数据读完时，我们如果这时调用<code>close()</code>方法关闭读写流，这时就可能造成数据丢失，为什么呢？因为，读入数据完成时不代表写入数据完成，一部分数据可能会留在缓存区中，这个时候<code>flush()</code>方法就格外重要了。</p></blockquote><p>好了，接下来close使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p></blockquote><h3 id="FileWriter的续写和换行"><a href="#FileWriter的续写和换行" class="headerlink" title="FileWriter的续写和换行"></a>FileWriter的续写和换行</h3><p><strong>续写和换行</strong>：操作类似于FileOutputStream操作（上一篇博客讲到过），直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      <span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;哥敢&quot;</span>);</span><br><span class="line">      <span class="comment">// 写出换行</span></span><br><span class="line">      fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      <span class="comment">// 写出字符串</span></span><br><span class="line">  fw.write(<span class="string">&quot;摸屎&quot;</span>);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">哥敢</span><br><span class="line">摸屎</span><br></pre></td></tr></table></figure><h3 id="FileReader和FileWriter类完成文本文件复制"><a href="#FileReader和FileWriter类完成文本文件复制" class="headerlink" title="FileReader和FileWriter类完成文本文件复制"></a>FileReader和FileWriter类完成文本文件复制</h3><p>直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\新建文件夹\\aa.txt&quot;</span>);<span class="comment">//文件不存在会抛出java.io.FileNotFoundException</span></span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\copyaa.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*创建输出流做的工作：</span></span><br><span class="line"><span class="comment">         *      1、调用系统资源创建了一个文件</span></span><br><span class="line"><span class="comment">         *      2、创建输出流对象</span></span><br><span class="line"><span class="comment">         *      3、把输出流对象指向文件        </span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//文本文件复制，一次读一个字符</span></span><br><span class="line">        copyMethod1(fr, fw);</span><br><span class="line">        <span class="comment">//文本文件复制，一次读一个字符数组</span></span><br><span class="line">        copyMethod2(fr, fw);</span><br><span class="line">        </span><br><span class="line">        fr.close();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> copyMethod1(FileReader fr, FileWriter fw) throws IOException &#123;</span><br><span class="line">        int ch;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(ch=fr.read())!=-<span class="number">1</span></span>)</span> &#123;<span class="comment">//读数据</span></span><br><span class="line">            fw.write(ch);<span class="comment">//写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> copyMethod2(FileReader fr, FileWriter fw) throws IOException &#123;</span><br><span class="line">        char chs[]=<span class="keyword">new</span> char[<span class="number">1024</span>];</span><br><span class="line">        int len=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(len=fr.read(chs))!=-<span class="number">1</span></span>)</span> &#123;<span class="comment">//读数据</span></span><br><span class="line">            fw.write(chs,<span class="number">0</span>,len);<span class="comment">//写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyFile</span><br></pre></td></tr></table></figure><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191014213256773.png" alt="在这里插入图片描述" style="zoom:80%;"><blockquote><p><strong>最后再次强调：<br>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流</strong></p></blockquote><h3 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h3><p>我们在学习的过程中可能习惯把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，格式代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;哥敢摸si&quot;</span>); <span class="comment">//哥敢摸si</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对异常不是特别熟练的童鞋可以参考这篇文章<a href="https://blog.csdn.net/qq_44543508/article/details/102211261">【java基础之异常】死了都要try，不淋漓尽致地catch我不痛快！</a></p><p>好了，到这里，字符流Reader和Writer的故事的到这里了！</p><p>前面主要写了一些基本的流作为IO流的入门。从这里开始将要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等，而这些强大的流都是在基本的流对象基础之上而来的！这些强大的流将伴随着我们今后的开发！</p><h1 id="1、缓冲流【掌握】"><a href="#1、缓冲流【掌握】" class="headerlink" title="1、缓冲流【掌握】"></a>1、缓冲流【掌握】</h1><h2 id="1-1-简要概述"><a href="#1-1-简要概述" class="headerlink" title="1.1 简要概述"></a>1.1 简要概述</h2><p>首先我们来认识认识一下缓冲流,也叫高效流，是对4个<code>FileXxx</code> 流的“增强流”。</p><p><strong>缓冲流的基本原理</strong>：</p><blockquote><p>1、使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。<br>2、通过缓冲区的read()方法从缓冲区获取具体的字符数据，这样就提高了效率。<br>3、如果用read方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了readLine()功能。</p></blockquote><p>也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><p>缓冲书写格式为<code>BufferedXxx</code>，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code></li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>InputStream</strong>。</li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>OutputStream</strong>。</li></ul><p>构造举例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方式一： 创建字节缓冲输入流【但是开发中一般常用下面的格式申明】</span></span><br><span class="line">FileInputStream fps = <span class="keyword">new</span> FileInputStream(b.txt);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fps)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方式一： 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">///构造方式二： 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="感受缓冲流的高效"><a href="#感受缓冲流的高效" class="headerlink" title="感受缓冲流的高效"></a>感受缓冲流的高效</h3><p>缓冲流读写方法与基本的流是一致的，我们通过复制370多MB的大文件，测试它的效率。</p><ol><li>基本流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>);<span class="comment">//exe文件够大</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>)</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不好意思十分钟过去了还在玩命复制中...</span><br></pre></td></tr></table></figure><ol><li>缓冲流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">         BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>));</span><br><span class="line">     BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure><p>有的童鞋就要说了，我要更快的速度！最近看速度与激情7有点上头，能不能再快些？答案是当然可以</p><p>想要更快可以使用数组的方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">      <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line"> BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>));</span><br><span class="line"> BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">521</span> 毫秒  </span><br></pre></td></tr></table></figure><h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><p>相同的来看看其构造，其格式以及原理和字节缓冲流是一样一样的！</p><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>Reader</strong>。</li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>Writer</strong>。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="字符缓冲流特有方法"><a href="#字符缓冲流特有方法" class="headerlink" title="字符缓冲流特有方法"></a>字符缓冲流特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的<strong>特有</strong>方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: <strong>读一行数据</strong>。 读取到最后返回null</li><li>BufferedWriter：<code>public void newLine()</code>: <strong>换行</strong>,由系统属性定义符号。</li></ul><p><code>readLine</code>方法演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newLine</code>方法演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    <span class="comment">// 创建流对象</span></span><br><span class="line">  BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 写出数据</span></span><br><span class="line">      bw.write(<span class="string">&quot;哥&quot;</span>);</span><br><span class="line">    <span class="comment">// 写出换行</span></span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;敢&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;摸屎&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;你敢吗？&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">  <span class="comment">// 释放资源</span></span><br><span class="line">      bw.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">哥</span><br><span class="line">敢</span><br><span class="line">摸屎</span><br><span class="line">你敢吗？</span><br></pre></td></tr></table></figure><h2 id="1-4-字符缓冲流练习"><a href="#1-4-字符缓冲流练习" class="headerlink" title="1.4 字符缓冲流练习"></a>1.4 字符缓冲流练习</h2><p>字符缓冲流练习啥捏？先放松一下吧各位，先欣赏欣赏我写的下面的诗篇</p><blockquote><p>6.你说你的程序叫简单，我说我的代码叫诗篇<br>1.一想到你我就哦豁豁豁豁豁豁豁豁豁豁….哦nima个头啊，完全不理人家受得了受不了<br>8.Just 简单你和我 ，Just 简单程序员<br>3.约了地点却忘了见面 ，懂得寂寞才明白浩瀚<br>5.沉默是最大的发言权<br>2.总是喜欢坐在电脑前， 总是喜欢工作到很晚<br>7.向左走 又向右走，我们转了好多的弯<br>4.你从来就不问我，你还是不是那个程序员</p></blockquote><p>欣赏完了咩？没错咋们就练习如何使用缓冲流的技术把上面的诗篇归顺序，都编过号了就是前面的1到8的编号</p><p>分析：首先用字符输入缓冲流创建个源，里面放没有排过序的文字，之后用字符输出缓冲流创建个目标接收，排序的过程就要自己写方法了哦，可以从每条诗词的共同点“.”符号下手！</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象  源</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//目标</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            String key = String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            String value = lineMap.get(key);</span><br><span class="line">          <span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">&quot;.&quot;</span>+value);</span><br><span class="line">          <span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>一想到你我就哦豁豁豁豁豁豁豁豁豁豁…哦nima个头啊，完全不理人家受得了受不了</span><br><span class="line"><span class="number">2.</span>总是喜欢坐在电脑前， 总是喜欢工作到很晚</span><br><span class="line"><span class="number">3.</span>约了地点却忘了见面 ，懂得寂寞才明白浩瀚</span><br><span class="line"><span class="number">4.</span>你从来就不问我，你还是不是那个程序员</span><br><span class="line"><span class="number">5.</span>沉默是最大的发言权</span><br><span class="line"><span class="number">6.</span>你说你的程序叫简单，我说我的代码叫诗篇</span><br><span class="line"><span class="number">7.</span>向左走 又向右走，我们转了好多的弯</span><br><span class="line"><span class="number">8.</span>Just 简单你和我 ，Just 简单程序员</span><br></pre></td></tr></table></figure><h1 id="2、转换流【掌握】"><a href="#2、转换流【掌握】" class="headerlink" title="2、转换流【掌握】"></a>2、转换流【掌握】</h1><p>何谓转换流？为何由来？暂时带着问题让我们先来了解了解字符编码和字符集！<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/2019101609401732.png" alt="在这里插入图片描述" style="zoom:80%;"></p><h3 id="2-1-字符编码与解码"><a href="#2-1-字符编码与解码" class="headerlink" title="2.1 字符编码与解码"></a>2.1 字符编码与解码</h3><p>众所周知，计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照<code>A</code>规则存储，同样按照<code>A</code>规则解析，那么就能显示正确的文本符号。反之，按照<code>A</code>规则存储，再按照<code>B</code>规则解析，就会导致乱码现象。</p><p>简单一点的说就是：</p><blockquote><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p></blockquote><p>代码解释则是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName):通过指定的字符集解码字节数组</span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组</span><br><span class="line"></span><br><span class="line">编码:把看得懂的变成看不懂的</span><br><span class="line">String -- <span class="keyword">byte</span>[]</span><br><span class="line"></span><br><span class="line">解码:把看不懂的变成看得懂的</span><br><span class="line"><span class="keyword">byte</span>[] -- String</span><br></pre></td></tr></table></figure><ul><li><p><strong>字符编码</strong> <code>Character Encoding</code>: 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>而<strong>编码表</strong>则是生活中文字和计算机中二进制的对应规则</p></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li><strong>字符集</strong> <code>Charset</code>：也叫<strong>编码表</strong>。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有<code>ASCII</code>字符集、<code>GBK</code>字符集、<code>Unicode</code>字符集等。<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016090127127.png" alt="在这里插入图片描述" style="zoom:80%;"></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><p>ASCII字符集：</p><ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li></ul></li><li><p>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</p></li><li><p>ISO-8859-1字符集：</p><ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li></ul></li><li><p>ISO-8859-1使用单字节编码，兼容ASCII编码。</p></li><li><p>GBxxx字符集：</p><ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li></ul></li><li><p><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><ul><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><p>Unicode字符集：</p><ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li></ul></li><li><p>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</p><ul><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：</li></ul><ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。</li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul><h2 id="2-2-编码问题导致乱码"><a href="#2-2-编码问题导致乱码" class="headerlink" title="2.2 编码问题导致乱码"></a>2.2 编码问题导致乱码</h2><p>在java开发工具IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：���</span><br></pre></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？ 这个时候就得讲讲转换流了！</p><blockquote><p>从另一角度来讲：<strong>字符流=字节流+编码表</strong></p></blockquote><h2 id="2-3-InputStreamReader类—–-字节流到字符流的桥梁"><a href="#2-3-InputStreamReader类—–-字节流到字符流的桥梁" class="headerlink" title="2.3 InputStreamReader类—–(字节流到字符流的桥梁)"></a>2.3 InputStreamReader类—–(字节流到字符流的桥梁)</h2><p>转换流<code>java.io.InputStreamReader</code>，是<code>Reader</code>的子类，从字面意思可以看出它是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote><p><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。<br><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p></blockquote><p>构造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用转换流解决编码问题"><a href="#使用转换流解决编码问题" class="headerlink" title="使用转换流解决编码问题"></a>使用转换流解决编码问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        String FileName = <span class="string">&quot;C:\\A.txt&quot;</span>;</span><br><span class="line">      <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">      <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"><span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">      <span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read); <span class="comment">// �����ʺ      </span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 哥敢摸屎</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-OutputStreamWriter类—–-字符流到字节流的桥梁"><a href="#2-4-OutputStreamWriter类—–-字符流到字节流的桥梁" class="headerlink" title="2.4 OutputStreamWriter类—–(字符流到字节流的桥梁)"></a>2.4 OutputStreamWriter类—–(字符流到字节流的桥梁)</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，字面看容易混淆会误以为是转为字符流，其实不然，OutputStreamWriter为从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote><p><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。<br><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p></blockquote><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="指定编码构造代码"><a href="#指定编码构造代码" class="headerlink" title="指定编码构造代码"></a>指定编码构造代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 定义文件路径</span></span><br><span class="line">        String FileName = <span class="string">&quot;C:\\s.txt&quot;</span>;</span><br><span class="line">      <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      osw.write(<span class="string">&quot;哥敢&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 定义文件路径</span></span><br><span class="line">String FileName2 = <span class="string">&quot;D:\\A.txt&quot;</span>;</span><br><span class="line">     <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      osw2.write(<span class="string">&quot;摸屎&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016100612927.png" alt="在这里插入图片描述"><br>为了达到<strong>最高效率</strong>，可以考虑在 <code>BufferedReader</code> 内包装 <code>InputStreamReader</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader <span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))；</span><br></pre></td></tr></table></figure><h1 id="3、序列化流【理解】"><a href="#3、序列化流【理解】" class="headerlink" title="3、序列化流【理解】"></a>3、序列化流【理解】</h1><blockquote><p>(1)可以把对象写入文本文件或者在网络中传输<br>(2)如何实现序列化呢?<br>让被序列化的对象所属类实现序列化接口。<br>该接口是一个标记接口。没有功能需要实现。<br>(3)注意问题：<br>把数据写到文件后，在去修改类会产生一个问题。<br>如何解决该问题呢?<br>在类文件中，给出一个固定的序列化id值。<br>而且，这样也可以解决黄色警告线问题<br>(4)面试题：<br>什么时候序列化?<br>如何实现序列化?<br>什么是反序列化?</p></blockquote><h2 id="3-1-何谓序列化"><a href="#3-1-何谓序列化" class="headerlink" title="3.1 何谓序列化"></a>3.1 何谓序列化</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化：<br><img src="/2020/12/17/java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/20191016100818120.png" alt="在这里插入图片描述"></p><h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</p><p>构造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aa.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol><li>一个对象要想序列化，必须满足两个条件:</li></ol><p>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</p><p>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.写出对象方法</p><p><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">    e.age = <span class="number">20</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 写出对象</span></span><br><span class="line">        out.writeObject(e);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure><h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</p><h3 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</p><h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">             ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        <span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong></p><h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a>反序列化操作2</h3><p>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。发生这个异常的原因如下：</p><blockquote><p>1、该类的序列版本号与从流中读取的类描述符的版本号不匹配<br>2、该类包含未知数据类型<br>2、该类没有可访问的无参数构造方法</p></blockquote><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-序列化集合练习"><a href="#3-4-序列化集合练习" class="headerlink" title="3.4 序列化集合练习"></a>3.4 序列化集合练习</h2><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h3 id="案例代码实现"><a href="#案例代码实现" class="headerlink" title="案例代码实现"></a>案例代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建 学生对象</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;laow&quot;</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;老张&quot;</span>, <span class="string">&quot;laoz&quot;</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;老李&quot;</span>, <span class="string">&quot;laol&quot;</span>);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(student);</span><br><span class="line">arrayList.add(student2);</span><br><span class="line">arrayList.add(student3);</span><br><span class="line"><span class="comment">// 序列化操作</span></span><br><span class="line"><span class="comment">// serializ(arrayList);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化  </span></span><br><span class="line">ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          Student s = list.get(i);</span><br><span class="line">        System.out.println(s.getName()+<span class="string">&quot;--&quot;</span>+ s.getPwd());</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建 序列化流 </span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 写出对象</span></span><br><span class="line">oos.writeObject(arrayList);</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">oos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、打印流【掌握】"><a href="#4、打印流【掌握】" class="headerlink" title="4、打印流【掌握】"></a>4、打印流【掌握】</h1><h2 id="4-1-何谓打印流"><a href="#4-1-何谓打印流" class="headerlink" title="4.1 何谓打印流"></a>4.1 何谓打印流</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，各位用了这么久的输出语句肯定没想过这两个方法都来自于<code>java.io.PrintStream</code>类吧，哈哈。该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><p><strong>打印流分类</strong>：</p><blockquote><p>字节打印流PrintStream，字符打印流PrintWriter</p></blockquote><p><strong>打印流特点</strong>：</p><blockquote><p>A:只操作目的地,不操作数据源<br>B:可以操作任意类型的数据<br>C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新<br>D:可以直接操作文件</p></blockquote><p>这个时候有同学就要问了，哪些流可以直接操作文件呢?答案很简单，<strong>如果该流的构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的</strong>！</p><p>PrintStream是OutputStream的子类，PrintWriter是Writer的子类，两者处于对等的位置上，所以它们的API是非常相似的。二者区别无非一个是字节打印流，一个是字符打印流。</p><h2 id="4-2-字节输出打印流PrintStream复制文本文件"><a href="#4-2-字节输出打印流PrintStream复制文本文件" class="headerlink" title="4.2 字节输出打印流PrintStream复制文本文件"></a>4.2 字节输出打印流PrintStream复制文本文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;copy.txt&quot;</span>));</span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> PrintStream(<span class="string">&quot;printcopy.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> line;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(line=br.readLine())!=<span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            ps.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-字符输出打印流PrintWriter复制文本文件"><a href="#4-3-字符输出打印流PrintWriter复制文本文件" class="headerlink" title="4.3 字符输出打印流PrintWriter复制文本文件"></a>4.3 字符输出打印流PrintWriter复制文本文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用打印流复制文本文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;aa.txt&quot;</span>));</span><br><span class="line">        PrintWriter pw=<span class="keyword">new</span> PrintWriter(<span class="string">&quot;printcopyaa.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> line;</span><br><span class="line">        <span class="function"><span class="title">while</span>(<span class="params">(line=br.readLine())!=<span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            pw.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、Properties属性类"><a href="#5、Properties属性类" class="headerlink" title="5、Properties属性类"></a>5、Properties属性类</h1><p>我想各位对这个Properties类多多少少也接触过了，首先Properties类并不在IO包下，那为啥要和IO流一起讲呢？原因很简单因为properties类经常和io流的联合一起使用。</p><blockquote><p>(1)是一个集合类，Hashtable的子类<br>(2)特有功能<br>A:public Object setProperty(String key,String value)<br>B:public String getProperty(String key)<br>C:public Set stringPropertyNames()<br>(3)和IO流结合的方法<br>把键值对形式的文本文件内容加载到集合中<br>public void load(Reader reader)<br>public void load(InputStream inStream)<br>把集合中的数据存储到文本文件中<br>public void store(Writer writer,String comments)<br>public void store(OutputStream out,String comments)</p></blockquote><h2 id="5-1-Properties概述"><a href="#5-1-Properties概述" class="headerlink" title="5.1 Properties概述"></a>5.1 Properties概述</h2><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>public Properties()</code> :创建一个空的属性列表。</p><h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li><li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          System.out.println(key+<span class="string">&quot; -- &quot;</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure><h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><p><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</p><p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。现在文本数据格式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename=Properties.txt</span><br><span class="line">length=<span class="number">123</span></span><br><span class="line">location=C:\Properties.txt</span><br></pre></td></tr></table></figure><p>加载代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Properties.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          System.out.println(key+<span class="string">&quot; -- &quot;</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- Properties.txt</span><br><span class="line">length -- <span class="number">123</span></span><br><span class="line">location -- C:\Properties.txt</span><br></pre></td></tr></table></figure><blockquote><p>文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解之@Import注解的三种使用方式</title>
      <link href="2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、-Import注解须知"><a href="#1、-Import注解须知" class="headerlink" title="1、@Import注解须知"></a>1、@Import注解须知</h2><blockquote><p>1、**@Import只能用在类上** ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中</p><p>2、加入IOC容器的方式有很多种，@Import注解就相对很牛皮了，**@Import注解可以用于导入第三方包** ，当然@Bean注解也可以，但是@Import注解快速导入的方式更加便捷</p><p>3、@Import注解有三种用法</p></blockquote><h2 id="2、-Import的三种用法"><a href="#2、-Import的三种用法" class="headerlink" title="2、@Import的三种用法"></a>2、@Import的三种用法</h2><p>@Import的三种用法主要包括：</p><blockquote><p>1、直接填class数组方式<br>2、ImportSelector方式【重点】<br>3、ImportBeanDefinitionRegistrar方式</p></blockquote><h4 id="2-1、第一种用法：直接填class数组"><a href="#2-1、第一种用法：直接填class数组" class="headerlink" title="2.1、第一种用法：直接填class数组"></a>2.1、第一种用法：直接填class数组</h4><p><strong>直接填对应的class数组，class数组可以有0到多个。</strong></p><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123; 类名.class , 类名.class... &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的import的bean都将加入到spring容器中，这些在容器中bean名称是该类的<strong>全类名</strong> ，比如com.yc.类名</p><h4 id="2-2、第二种用法：ImportSelector方式【重点】"><a href="#2-2、第二种用法：ImportSelector方式【重点】" class="headerlink" title="2.2、第二种用法：ImportSelector方式【重点】"></a>2.2、第二种用法：ImportSelector方式【重点】</h4><p>这种方式的前提就是一个类要实现ImportSelector接口，假如我要用这种方法，目标对象是Myclass这个类，分析具体如下：</p><p>创建Myclass类并实现ImportSelector接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"><span class="comment">//既然是接口肯定要实现这个接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析实现接口的selectImports方法中的：</p><ul><li>1、返回值： 就是我们实际上要导入到容器中的组件全类名【<strong>重点</strong> 】</li><li>2、参数： AnnotationMetadata表示当前被@Import注解给标注的所有注解信息【不是重点】</li></ul><blockquote><p>需要注意的是selectImports方法可以返回空数组但是不能返回null，否则会报空指针异常！</p></blockquote><p>以上分析完毕之后，具体用法步骤如下：</p><p>第一步：创建Myclass类并实现ImportSelector接口，这里用于演示就添加一个全类名给其返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> <span class="title">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span>[] <span class="function"><span class="title">selectImports</span>(<span class="params">AnnotationMetadata annotationMetadata</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">&quot;com.yc.Test.TestDemo3&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：编写TestDemo 类，并标注上使用ImportSelector方式的Myclass类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;TestDemo2.class,Myclass.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AccountDao2 <span class="title">accountDao2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AccountDao2();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，宜春故意挑了个龙套角色@Bean注解，若对@Bean注解不是很清晰的童鞋可以参考<a href="https://blog.csdn.net/qq_44543508/article/details/103718958">大白话讲解Spring的@bean注解</a></p><p>第三步：编写打印容器中的组件测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印容器中的组件测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext=<span class="keyword">new</span> AnnotationConfigApplicationContext(TestDemo.class);  <span class="comment">//这里的参数代表要做操作的类</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : beanDefinitionNames)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：运行结果<br><img src="/2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/20191227145414510.png" alt="在这里插入图片描述"></p><h4 id="2-3、第三种用法：ImportBeanDefinitionRegistrar方式"><a href="#2-3、第三种用法：ImportBeanDefinitionRegistrar方式" class="headerlink" title="2.3、第三种用法：ImportBeanDefinitionRegistrar方式"></a>2.3、第三种用法：ImportBeanDefinitionRegistrar方式</h4><p>同样是一个接口，类似于第二种ImportSelector用法，相似度80%，只不过这种用法比较自定义化注册，具体如下：</p><p>第一步：创建Myclass2类并实现ImportBeanDefinitionRegistrar接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass2</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="comment">//该实现方法默认为空</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数分析：</p><ul><li>第一个参数：annotationMetadata 和之前的ImportSelector参数一样都是表示当前被@Import注解给标注的所有注解信息</li><li>第二个参数表示用于注册定义一个bean</li></ul><p>第二步：编写代码，自定义注册bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass2</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定bean定义信息（包括bean的类型、作用域...）</span></span><br><span class="line">        RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(TestDemo4.class);</span><br><span class="line">        <span class="comment">//注册一个bean指定bean名字（id）</span></span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">&quot;TestDemo4444&quot;</span>,rootBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：编写TestDemo 类，并标注上使用ImportBeanDefinitionRegistrar方式的Myclass2类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;TestDemo2.class,Myclass.class,Myclass2.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AccountDao2 <span class="title">accountDao222</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AccountDao2();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：运行结果<br><img src="/2020/12/17/Spring%E6%B3%A8%E8%A7%A3%E4%B9%8B-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/2019122715572214.png" alt="在这里插入图片描述"></p><h2 id="3、-Import注解的三种使用方式总结"><a href="#3、-Import注解的三种使用方式总结" class="headerlink" title="3、@Import注解的三种使用方式总结"></a>3、@Import注解的三种使用方式总结</h2><blockquote><p>第一种用法：<code>@Import</code>（{ 要导入的容器中的组件 } ）：容器会自动注册这个组件，<strong>id默认是全类名</strong></p><p>第二种用法：<code>ImportSelector</code>：返回需要导入的组件的全类名数组，springboot底层用的特别多【<strong>重点</strong> 】</p><p>第三种用法：<code>ImportBeanDefinitionRegistrar</code>：手动注册bean到容器</p></blockquote><p><strong>以上三种用法方式皆可混合在一个@Import中使用，特别注意第一种和第二种都是以全类名的方式注册，而第三中可自定义方式。</strong></p><p>@Import注解本身在springboot中用的很多，特别是其中的第二种用法ImportSelector方式在springboot中使用的特别多，尤其要掌握！</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring生态简介</title>
      <link href="2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/"/>
      <url>2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="http://www.cnblogs.com/nuccch/">2Simple</a><br>出处：<a href="http://www.cnblogs.com/nuccch/">http://www.cnblogs.com/nuccch/</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>做Java开发的人一提起Spring，首先在脑海中浮现出的就是“IoC”，“AOP”，“Spring MVC”，“Spring Security”等等这些名词，甚至大有“无Spring不Java”的感慨。<br>实际上，时至今日Spring已不再是一个简单的编程框架了，从最初的“SSH框架”发展到今天，Struts和Hibernate都几乎快要从程序员视野中消失了，而Spring却发展成了一个非常庞大且完整的生态。<br>所以说，除非特别指明是Spring生态中的某个具体框架，否则提起“Spring”应该指的是整个Spring生态。<br>说句不夸张的话，Java程序员只要精通了Spring，也就掌握了Java开发的精髓。</p><p>在整个Spring生态中包含了许多应用在特定场景的具体框架，如：“Spring Framework”，“Spring Security”，“Spring Boot”，“Spring Cloud”等等，其中“Spring Framework”框架是整个生态的核心基础，其他框架都需要依赖“Spring Framework”提供的基础功能，而且每个框架都有自己独立的代码仓库。</p><h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p>Spring生态下的项目分为3类：主要项目（Main Projects），社区项目（Community Projects），已经终止但是目前还保留的项目（Projects in the Attic）。<br>最新的Spring生态项目列表详见：<a href="https://spring.io/projects">https://spring.io/projects</a> 。</p><h3 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h3><p>目前，Spring生态中包含22个主要活跃的项目。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014708455-34471552.png" alt="Spring生态主要项目"></p><p><strong>1.Spring Framework</strong></p><p>Spring Framework项目是整个Spring生态的基础，包含了Spring最核心的功能，如：IoC，AOP，Spring MVC等，其他项目都需要依赖Spring Framework。<br>另外，还<strong>需要注意</strong>的是Spring Framework项目又包含多个子模块，如：spring-core，spring-beans，spring-context，spring-aop，spring-web，spring-webmvc等等。实际上，Spring Framework项目是一个模块化的架构，各模块之间又存在依赖关系。我们在Java Web后台项目中使用得最多的Spring MVC实际上就是模块spring-webmvc，它与其他模块的依赖关系如下所示：<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014737034-413265330.png" alt="Spring MVC对其他模块的依赖关系"></p><p>显然，<code>spring-webmvc</code>模块依赖<code>spring-context</code>，<code>spring-aop</code>和<code>spring-web</code>。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014801760-484921515.png" alt="spring-webmvc模块的依赖关系"></p><p><strong>2.Spring Boot</strong></p><p>Spring Boot是一个开发基于Spring的脚手架项目，它默认集成了嵌入式Tomcat，配置注解化，支持快速集成第三方开发组件（如MyBatis），大大降低了使用Spring的门槛，而且内置了许多可以直接用于生产环境的功能，是目前用于开发微服务架构项目的不二选择。<br><strong>值得注意的是：</strong> 许多人刚接触Spring Boot的人把它神话了，固然使用Spring Boot能快速开发一个健壮的、可直接运行的项目，但是它的核心和基础来源于Spring Framework。对于重度依赖Spring的开发人员，应该先去吃透Spring Framework，只要真正掌握了Spring Framework中各个模块的实现原理，对于在实际开发中使用Spring Boot遇到的问题也就迎刃而解了。</p><p><strong>3.Spring Cloud</strong></p><p>Spring Cloud为开发基于微服务架构的软件系统提供了一整套工具集合，其中包含了开发各个微服务组件的具体项目，如：Spring Cloud Config（配置中心），Spring Cloud Netflix（服务注册中心），Spring Cloud Sleuth（服务调用监控），Spring Cloud Gateway（服务网关）等等。<br>Spring Cloud的基础是Spring Boot，基于Spring Boot可以大大简化开发各微服务组件的流程。</p><p><strong>4.Spring Cloud Data Flow</strong></p><p>Spring Cloud Data Flow用于构建在云环境或K8S中基于微服务的实时或批数据处理架构，具体来讲就是支持一系列需要进行数据处理的场景，如：ETL，数据导入/导出，事件流，预测分析等等。</p><p><strong>5.Spring Data</strong></p><p>Spring Data旨在提供一套基于Spring编程模型的数据访问API，是一个数据访问框架集合，其中包含了多个具体的支持不同方式访问特定数据库类型的子模块，如：Spring Data JDBC（使用JDBC方式访问关系型数据库），Spring Data MongoDB（访问MongoDB数据库）等。<br>这个模块的功能类似于<a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis</a>这样的专门的ORM框架，在实际开发中可以根据需求进行灵活选择。</p><p><strong>6.Spring Integration</strong></p><p>Spring Integration的目的是提供一个简单的模型，用于构建企业级应用集成解决方案。</p><p><strong>7.Spring Batch</strong></p><p>Spring Batch是一个轻量级的批处理框架，旨在开发对企业系统日常运营至关重要的强大批处理应用程序。<br>支持事务管理，提供了基于Web的管理接口。</p><p><strong>8.Spring Security</strong></p><p>Spring Security是用于实现认证和授权，以及访问控制的安全框架，在Java生态与之提供类似的功能还有一个框架：<a href="https://shiro.apache.org/">Apache Shiro</a>。<br>Spring Security依赖于Spring Framework，也就是说如果要Spring Security，那么应用架构也必须是基于Spring Framework的，这大大限制了Spring Security的使用场景；反之，Shiro就没有这样限制，而且从项目架构上Shiro更加简洁。当然，Spring Security提供了非常丰富的安全控制的功能，在某些方面甚至比Shiro更加完善，与之对应的是掌握的Spring Security的复杂度比较大。因此，对于在应用中是否选择Spring Security需要根据实际需求来决定。</p><p><strong>9.Spring HATEOAS</strong></p><p>如果Web应用基于Spring框架（即：使用了Spring MVC）开发，那么可以直接使用<code>Spring HATEOAS</code>来开发满足<code>HATEOAS</code>约束的RESTFul服务。<br>这里需要理解一个单词简写：“HATEOAS”。HATEOAS（Hypermedia as the engine of application state）是REST架构风格中最复杂的约束，也是构建成熟REST服务的核心。它的重要性在于打破了客户端和服务器之间严格的契约，使得客户端可以更加智能和自适应，而 REST 服务本身的演化和更新也变得更加容易。</p><p><strong>10.Spring REST Docs</strong></p><p>Spring REST Docs是一个文档工具，用于为REST架构风格的Web服务自动生成相应的文档，这样可以解放开发者专门撰写API文档的工作。</p><p><strong>11.Spring AMQP</strong></p><p>Spring AMQP项目旨在将核心的Spring概念应用于基于AMQP的消息传递解决方案的开发中，它提供了一个“模板”的抽象用于发送和接收消息。</p><p><strong>12.Spring Mobile</strong></p><p>Spring Mobile是对Spring MVC的扩展，旨在简化移动Web应用的开发。<br>Spring Mobile可以检测出当前请求使用的设备是PC、还是手机或者是平板以及用户设备是安卓平台还是iOS平台，然后根据请求设备的不同，返回适合该设备的视图。</p><p><strong>13.Spring For Android</strong></p><p>虽然官方的说法是Spring For Android旨在简化原声Android应用的开发，但其实这个有点太过于牵强。<br>Spring For Android提供了2个对原生Android应用开发的支持：<br>(1)提供了一个REST客户端<br>(2)支持访问安全API时的认证</p><p><strong>14.Spring Web Flow</strong></p><p>Spring Web Flow主要应用于需要在Web页面上创建引导用户执行类似“下一步”这样的基于流程的应用场景，该框架构建于Spring MVC之上。</p><p><strong>15.Spring Web Services</strong></p><p>Spring Web Services用于开发WebService服务，类似的框架如：<a href="https://cxf.apache.org/">Apache CXF</a>，<a href="http://axis.apache.org/axis2/java/core/">Apache Axis2</a>。</p><p><strong>16.Spring LDAP</strong></p><p>Spring LDAP是一个工具，用于为基于Spring的应用程序使用LDAP（Lightweight Directory Access Protocol）协议。</p><p><strong>17.Spring Session</strong></p><p>Spring Session提供了管理用户Session信息的API和对应实现，Spring Session使得支持集群会话变得简单，而不依赖于特定于应用程序容器的解决方案。<br>简单来讲，传统的Session方案依赖于特定的容器（如：Tomcat），Spring Session就是提供独立于特定容器的Session解决方案。<br>其实，针对Tomcat容器，Session集群化也有一个开源方案：<a href="https://github.com/jcoleman/tomcat-redis-session-manager">tomcat-redis-session-manager</a>。</p><p><strong>18.Spring Shell</strong></p><p>Spring Shell用于开发基于命令行交互的应用。</p><p><strong>19.Spring FLO</strong></p><p>Spring FLO是一个JavaScript类库，是Spring Cloud Data Flow中流构建器的基础。</p><p><strong>20.Spring Kafka</strong></p><p>Spring Kafka用于在Spring项目中与Kafka交互。</p><p><strong>21.Spring Statemachine</strong></p><p>Spring Statemachine是一个为开发人员在Spring项目中使用状态机的框架，帮助开发者简化状态机的开发过程，让状态机结构更加层次化。</p><p><strong>22.Spring IO Platform</strong></p><p>简单来说，Spring IO Platform是一个对项目依赖进行统一版本管理的工具。本质就是一个pom文件，它记录了Spring项目和其它第三方库对应的版本信息。</p><h3 id="社区项目"><a href="#社区项目" class="headerlink" title="社区项目"></a>社区项目</h3><p>社区项目目前只有2个：Spring ROO，Spring Scala。</p><p>1.Spring ROO：这是一个开发工具包，旨在快速构建一个Java应用。<br>2.Spring Scala：支持在Scala中使用Spring框架。</p><h3 id="保留项目"><a href="#保留项目" class="headerlink" title="保留项目"></a>保留项目</h3><p>某些项目已经终止了，但是仍然保留着，不必赘述。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>Spring是一个生态系统，提供许多有用的编程框架或工具集。<br>本文的目的不在于详细介绍Spring生态的每一个项目，而是通过一个全面的整理，对Spring生态有一个完整的认识，在实际中根据需要灵活选择对应的组件来使用即可。<br>可以明确的是，当下最为流行的Spring项目是这4个：<strong>Spring Framework</strong>，<strong>Spring Security</strong>，<strong>Spring Boot</strong>，<strong>Spring Cloud</strong>。<br>如下图所示，再次对Spring生态做一个概括性总结。<br><img src="/2020/12/17/Spring%E7%94%9F%E6%80%81%E7%AE%80%E4%BB%8B/722072-20190601014836702-2034259504.png" alt="Spring生态概括"></p><p>【参考】<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-SpringHATEOAS/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-SpringHATEOAS/index.html</a> 使用 Spring HATEOAS 开发 REST 服务<br><a href="https://www.jianshu.com/p/f9024eb3f252">https://www.jianshu.com/p/f9024eb3f252</a> 使用Spring Mobile实现网站移动端适配及更换主题<br><a href="https://blog.csdn.net/csdn_xuexiaoqiang/article/details/65938744">https://blog.csdn.net/csdn_xuexiaoqiang/article/details/65938744</a> Spring学习笔记之Spring Web Flow<br><a href="https://www.hifreud.com/2015/02/27/08-spring-mvc-spring-web-service/">https://www.hifreud.com/2015/02/27/08-spring-mvc-spring-web-service/</a> Spring 使用笔记之(五) - Spring-ws实现基于契约优先的WebService<br><a href="https://www.ibm.com/developerworks/cn/web/wa-spring-session-architecture-and-design/index.html">https://www.ibm.com/developerworks/cn/web/wa-spring-session-architecture-and-design/index.html</a> 详解 Spring Session 架构与设计<br><a href="https://www.ibm.com/developerworks/cn/java/spring-shell-application/index.html">https://www.ibm.com/developerworks/cn/java/spring-shell-application/index.html</a> 使用 Spring Shell 开发 Java 命令行应用<br><a href="http://blog.didispace.com/spring-statemachine/">http://blog.didispace.com/spring-statemachine/</a> 使用Spring StateMachine框架实现状态机<br><a href="https://www.jianshu.com/p/dd0baba45f52">https://www.jianshu.com/p/dd0baba45f52</a> Spring IO Platform 简介<br><a href="https://segmentfault.com/a/1190000012743018">https://segmentfault.com/a/1190000012743018</a> Spring IO Platform项目的介绍和应用<br><a href="https://www.cnblogs.com/chenpi/p/6295855.html">https://www.cnblogs.com/chenpi/p/6295855.html</a> Spring IO Platform简介及示例</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-boot-admin配置属性详解</title>
      <link href="2020/12/16/Spring-boot-admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/16/Spring-boot-admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="client端配置属性详解"><a href="#client端配置属性详解" class="headerlink" title="client端配置属性详解"></a>client端配置属性详解</h2><p><strong>spring.boot.admin.client.enabled</strong>：是否启用springbootAdmin客户端，默认为true；<br><strong>spring.boot.admin.client.url</strong>：要注册的server端的url地址。如果要同时在多个server端口注册，则用逗号分隔各个server端的url地址；<br><strong>spring.boot.admin.client.api-path</strong>：默认值是instances。server端获取client信息的路径，默认情况下server通过访问/instances请求来获取到client端的信息。（client端向server端注册，注册成功后server端会给该client创建一个唯一的clientID值。当server端需要获取client的信息，比如health信息时，server端会发送<a href="http://111.11.11.1:8080/instances/clientID/actuator/health%E5%8D%B3%E5%8F%AF%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84http://111.11.11.1:8080%E6%98%AFclient%E6%89%80%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8Cinstances%E5%B0%B1%E6%98%AF%E8%AF%A5%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%EF%BC%89">http://111.11.11.1:8080/instances/clientID/actuator/health即可，这里的http://111.11.11.1:8080是client所在服务器的IP地址，instances就是该属性的值）</a></p><p><strong>spring.boot.admin.client.username</strong>：如果server端需要进行认证时，该属性用于配置用户名。<br><strong>spring.boot.admin.client.password</strong>：如果server端需要进行认证时，该属性用于配置密码。</p><p><strong>spring.boot.admin.client.period</strong>：注册时间间隔，单位是毫秒；默认值是10秒钟注册一次。（client通过持续不断地向server端进行注册来保持client端与server端的连接）</p><p><strong>spring.boot.admin.client.connect-timeout</strong>：注册连接超时时间，单位是毫秒，默认值是5秒。当client向server进行注册时，如果5秒钟没有注册完成则认为本次注册失败；</p><p><strong>spring.boot.admin.client.read-timeout</strong>：注册读取超时，单位是毫秒，默认值是5秒；</p><p><strong>spring.boot.admin.client.auto-registration</strong>：是否开启自动注册，默认值是true。</p><p><strong>spring.boot.admin.client.auto-deregistration</strong>：是否开启自动注销，默认值是null。如果服务端运行在云平台，默认值是true；</p><p><strong>spring.boot.admin.client.register-once</strong>：默认值为true。如果值为true的话，client只会在一个server端进行注册（按照spring.boot.admin.client.url中设置的server的顺序）。如果该server端宕机，会自动在下一个server端进行注册。如果该属性值为false，则会在所有的server端进行注册；</p><p><strong>spring.boot.admin.client.instance.management-url</strong>：注册的management-url，如果可用的url不同的话可以重写该值。如果不配置该属性的话，默认该属性值与management-base-url 和 management.context-path两个属性值有关。比如工程中该值为：managementUrl=<a href="http://192.168.200.165:8080/actuator%EF%BC%8C%E5%85%B6%E4%B8%AD[http://192.168.200.165:8080](http://192.168.200.165:8080/)%E4%B8%BAmanagement-base-url%EF%BC%8C/actuator%E6%98%AFmanagement.context-path%EF%BC%88%E8%AF%A5%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AFspring">http://192.168.200.165:8080/actuator，其中[http://192.168.200.165:8080](http://192.168.200.165:8080/)为management-base-url，/actuator是management.context-path（该属性值是spring</a> actuator的属性值）；</p><p><strong>spring.boot.admin.client.instance.management-base-url</strong>：用于计算management-url 的基本URL。该路径值在运行时进行获取并赋值给 base url。如果不配置该属性值的话，默认该属性值与management.port, service-url 以及server.servlet-path有关。比如工程中该值为<a href="http://192.168.200.165:8080/">http://192.168.200.165:8080，其中8080</a>端口是配置的获取actuator信息的端口。192.168.200.165是设置的service-url值，如果没有设置service-url的话，则为配置的server.servlet-path值（项目的启动路径）。</p><p><strong>spring.boot.admin.client.instance.health-url</strong>：注册的health-url地址，如果可用的url不同可以重写该值。如果不配置该属性的话，默认该属性值与management-url 以及endpoints.health.id有关。比如工程中该值为：healthUrl=<a href="http://192.168.200.165:8080/actuator/health%EF%BC%8C%E5%85%B6%E4%B8%ADhttp://192.168.200.165:8080/actuator%E6%98%AFmanagement-url%EF%BC%8Chealth%E6%98%AFendpoints.health.id%E3%80%82">http://192.168.200.165:8080/actuator/health，其中http://192.168.200.165:8080/actuator是management-url，health是endpoints.health.id。</a></p><p><strong>spring.boot.admin.client.instance.service-base-url</strong>：用于计算service-url 的基本URL。该路径值在运行时进行获取并赋值给 base url。如果不配置该属性值的话，默认该属性值与hostname, server.port有关。比如工程中该值为<a href="http://p-v-9:8080/">http://p-v-9:8080，其中8080</a>端口是配置的server.port。p-v-9是client所在服务器的hostname。</p><p><strong>spring.boot.admin.client.instance.service-url</strong>：注册的service-url值。如果不配置该属性值的话，基于 service-base-url 和 server.context-path进行赋值。比如工程中为<a href="http://p-v-9:8080/,%E5%85%B6%E4%B8%ADp-v-9%E6%98%AFbase-url%EF%BC%8C/%E6%98%AF%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%9A%84">http://p-v-9:8080/,其中p-v-9是base-url，/是工程配置的</a> server.context-path值。（这里要注意的是，当server端与client端不在同一台服务器上的时候，要配置该属性的值。如果不配置的话，server端就会根据默认的命名规则来配置该值，比如<a href="http://p-v-9:8080/%EF%BC%8C%E5%A6%82%E6%9E%9Cserver%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%80%BC%E6%9D%A5%E8%8E%B7%E5%8F%96client%E7%9A%84%E5%90%84%E7%A7%8D%E6%80%A7%E8%83%BD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%AF%9D%E6%98%AF%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%9A%84%EF%BC%89%EF%BC%9B">http://p-v-9:8080/，如果server使用这个值来获取client的各种性能信息的话是获取不到的）；</a></p><p><strong>spring.boot.admin.client.instance.name</strong>：客户端工程的名字。默认值是配置的spring.application.name的值，如果没有配置该属性的话，默认值是spring-boot-application；</p><p><strong>spring.boot.admin.client.instance.prefer-ip</strong>：是否使用注册的ip地址来取代上述各个url中hostname的值，默认值是false（也就是说默认情况下上述各个url中会使用hostname的值，比如我的电脑的hostname为p-v-9）。如果设置了server.address或management.address的话ip地址就是该值，如果没有设置这两个属性的话ip地址值是InetAddress.getLocalHost()的值。</p><p>*<em>spring.boot.admin.client.instance.metadata.**</em>：与该应用有关的元数据，以键值对的形式赋值。</p><h2 id="server端配置属性详解"><a href="#server端配置属性详解" class="headerlink" title="server端配置属性详解"></a>server端配置属性详解</h2><p>spring.boot.admin.context-path：server端的访问路径，默认是/。默认情况下server的访问地址是<a href="https://blog.csdn.net/">http://<strong>.</strong>.<strong>.</strong>:**/</a>,这里**.<strong>.</strong>.**:**是server所在服务器的ip地址。我们的工程设置该值是springbootAdmin，那么工程的server端访问地址是<a href="http://111.11.11.1:8000/springbootAdmin">http://111.11.11.1:8000/springbootAdmin</a>;</p><p><strong>spring.boot.admin.monitor.period</strong>:更新client端状态的时间间隔，单位是毫秒，默认值是10秒钟；</p><p><strong>spring.boot.admin.monitor.status-lifetime</strong>：client端状态的生命周期，该生命周期内不会更新client状态。单位是毫秒，默认值是10秒钟；</p><p><strong>spring.boot.admin.monitor.connect-timeout</strong>：查询client状态信息时的连接超时时间，单位是毫秒，默认是2秒（如果2秒内没有获取到client的状态信息，则认为连接已经断开）。</p><p><strong>spring.boot.admin.monitor.read-timeout</strong>：查询client状态信息时的读取超时时间，单位是毫秒，默认是2秒（如果2秒内没有获取到client的状态信息，则认为读取失败）。</p><p><strong>spring.boot.admin.metadata-keys-to-sanitize</strong>：要被过滤掉的元数据（当与正则表达式相匹配时，这些数据会在输出的json数据中过滤掉），默认值是”.<strong>password$”, “.*secret$”, “.*key$”, “.</strong>$token$”, “.<strong>credentials.</strong>“, “.*vcap_services$”；</p><p><strong>spring.boot.admin.probed-endpoints</strong>：要获取的client的端点信息，默认是”health”, “env”, “metrics”, “httptrace:trace”, “threaddump:dump”, “jolokia”, “info”, “logfile”, “refresh”, “flyway”, “liquibase”, “heapdump”, “loggers”, “auditevents”；</p><p><strong>spring.boot.admin.instance-proxy.ignored-headers</strong>：向client发起请求时不会被转发的headers信息，默认值是”Cookie”, “Set-Cookie”, “Authorization”；</p><p><strong>spring.boot.admin.ui.brand</strong>：在导航栏中显示的brand值，默认是”<img src="/2020/12/16/Spring-boot-admin%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/img/icon-spring-boot-admin.svg"><span>Spring Boot Admin</span>“；</p><p><strong>spring.boot.admin.ui.title</strong>：显示的页面标题，默认是”Spring Boot Admin”</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> admin </tag>
            
            <tag> springboot </tag>
            
            <tag> 监控 </tag>
            
            <tag> Actuator  </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-boot-admin简单使用</title>
      <link href="2020/12/16/Spring-boot-admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/16/Spring-boot-admin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot Admin 用于监控基于 Spring Boot 的应用，它是在 Spring Boot Actuator 的基础上提供简洁的可视化 WEB UI。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Spring Boot Admin 提供了很多功能，如显示 name、id 和 version，显示在线状态，Loggers 的日志级别管理，Threads 线程管理，Environment 管理等。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>在 Spring Boot 项目中，Spring Boot Admin 作为 Server 端，其他的要被监控的应用作为 Client 端</p><h2 id="简单使用（Spring-Boot-项目）"><a href="#简单使用（Spring-Boot-项目）" class="headerlink" title="简单使用（Spring Boot 项目）"></a>简单使用（Spring Boot 项目）</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>代码配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootAdminApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8788</span></span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.boot.admin.client.url</span>: <span class="string">&quot;http://localhost:8788&quot;  </span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>: <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>以上的配置，就可以实现 Spring Boot 项目中 Spring Boot Admin 监控其他应用了。</p><h2 id="进阶使用（Spring-Cloud-项目）"><a href="#进阶使用（Spring-Cloud-项目）" class="headerlink" title="进阶使用（Spring Cloud 项目）"></a>进阶使用（Spring Cloud 项目）</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>此处使用Eureka,端口8761，暂不详解</p><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p><strong>pom配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>启动类配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootAdminApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Profile(&quot;insecure&quot;)</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityPermitAllConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.authorizeRequests().anyRequest().permitAll()<span class="comment">//</span></span><br><span class="line">                    .and().csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Profile(&quot;secure&quot;)</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecuritySecureConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String adminContextPath;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SecuritySecureConfig</span><span class="params">(AdminServerProperties adminServerProperties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.adminContextPath = adminServerProperties.getContextPath();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// @formatter:off</span></span><br><span class="line">            SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">            successHandler.setTargetUrlParameter(<span class="string">&quot;redirectTo&quot;</span>);</span><br><span class="line">            http.authorizeRequests()</span><br><span class="line">                    .antMatchers(adminContextPath + <span class="string">&quot;/assets/**&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(adminContextPath + <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">                    .anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin().loginPage(adminContextPath + <span class="string">&quot;/login&quot;</span>).successHandler(successHandler).and()</span><br><span class="line">                    .logout().logoutUrl(adminContextPath + <span class="string">&quot;/logout&quot;</span>).and()</span><br><span class="line">                    .httpBasic().and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">            <span class="comment">// @formatter:on</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-admin</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secure</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8788</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span>   </span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">leaseRenewalIntervalInSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">health-check-url-path:</span> <span class="string">/actuator/health</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registryFetchIntervalSeconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;EUREKA_SERVICE_URL:http://localhost:8761&#125;/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">insecure</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">secure</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">user.name:</span> <span class="string">&quot;user&quot;</span>         <span class="comment">#These two are needed so that the server</span></span><br><span class="line">      <span class="attr">user.password:</span> <span class="string">&quot;password&quot;</span> <span class="comment">#can access the protected client endpoints</span></span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>配置文件修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8281</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="comment"># 向每个注册中心注册</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/,http://localhost:8762/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-demo-service</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">      <span class="attr">health:</span></span><br><span class="line">        <span class="attr">show-details:</span> <span class="string">ALWAYS</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> admin </tag>
            
            <tag> springboot </tag>
            
            <tag> 监控 </tag>
            
            <tag> Actuator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-boot-amqp自动配置详解</title>
      <link href="2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMQ自动装配类：RabbitAutoConfiguration"><a href="#RabbitMQ自动装配类：RabbitAutoConfiguration" class="headerlink" title="RabbitMQ自动装配类：RabbitAutoConfiguration"></a>RabbitMQ自动装配类：RabbitAutoConfiguration</h2><p>1、@EnableConfigurationProperties启动配置文件RabbitProperties<br>2、@Import导入RabbitAnnotationDrivenConfiguration</p><h3 id="RabbitConnectionFactoryCreator静态内部类："><a href="#RabbitConnectionFactoryCreator静态内部类：" class="headerlink" title="RabbitConnectionFactoryCreator静态内部类："></a>RabbitConnectionFactoryCreator静态内部类：</h3><p>1、RabbitConnectionFactoryBean配置，创建ConnectionFactory对象，内部单例是<strong>com.rabbitmq.client.ConnectionFactory</strong><br>2、使用spring-rabbitmq的<strong>CachingConnectionFactory</strong>包装ConnectionFactory</p><h3 id="RabbitTemplateConfiguration静态内部类："><a href="#RabbitTemplateConfiguration静态内部类：" class="headerlink" title="RabbitTemplateConfiguration静态内部类："></a>RabbitTemplateConfiguration静态内部类：</h3><p>1、@Import(RabbitConnectionFactoryCreator.class)<br>2、RabbitTemplate(操作spring-amqp中的Message对象)<br>3、AmqpAdmin</p><h3 id="MessagingTemplateConfiguration静态内部类："><a href="#MessagingTemplateConfiguration静态内部类：" class="headerlink" title="MessagingTemplateConfiguration静态内部类："></a>MessagingTemplateConfiguration静态内部类：</h3><p>1、(@Import(RabbitTemplateConfiguration.class))<br>2、RabbitMessagingTemplate（操作spring-message中的Message对象，底层也是使用RabbitTemplate）</p><h2 id="RabbitAnnotationDrivenConfiguration注解驱动配置类"><a href="#RabbitAnnotationDrivenConfiguration注解驱动配置类" class="headerlink" title="RabbitAnnotationDrivenConfiguration注解驱动配置类"></a>RabbitAnnotationDrivenConfiguration注解驱动配置类</h2><p>1、<strong>EnableRabbitConfiguration</strong>静态内部类（**@EnableRabbit**）<br>2、SimpleRabbitListenerContainerFactoryConfigurer配置，创建SimpleRabbitListenerContainerFactoryConfigurer<br>3、SimpleRabbitListenerContainerFactory（默认，spring.rabbitmq.listener.type=simple）通过configure方法配置SimpleRabbitListenerContainerFactory工厂对象的属性<br>4、DirectRabbitListenerContainerFactoryConfigurer配置，创建DirectRabbitListenerContainerFactoryConfigurer<br>5、DirectRabbitListenerContainerFactory(spring.rabbitmq.listener.type=direct,只能存在一个)通过configure方法配置DirectRabbitListenerContainerFactory工厂对象的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function">DirectRabbitListenerContainerFactoryConfigurer <span class="title">directRabbitListenerContainerFactoryConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactoryConfigurer configurer = <span class="keyword">new</span> DirectRabbitListenerContainerFactoryConfigurer();</span><br><span class="line">    configurer.setMessageConverter(<span class="keyword">this</span>.messageConverter.getIfUnique());</span><br><span class="line">    configurer.setMessageRecoverer(<span class="keyword">this</span>.messageRecoverer.getIfUnique());</span><br><span class="line">    configurer.setRetryTemplateCustomizers(</span><br><span class="line">        <span class="keyword">this</span>.retryTemplateCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">    configurer.setRabbitProperties(<span class="keyword">this</span>.properties);</span><br><span class="line">    <span class="keyword">return</span> configurer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean(name = &quot;rabbitListenerContainerFactory&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;rabbitListenerContainerFactory&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.rabbitmq.listener&quot;, name = &quot;type&quot;, havingValue = &quot;direct&quot;)</span></span><br><span class="line"><span class="function">DirectRabbitListenerContainerFactory <span class="title">directRabbitListenerContainerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DirectRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactory factory = <span class="keyword">new</span> DirectRabbitListenerContainerFactory();</span><br><span class="line">    <span class="comment">//为ListenerContainerFactory配置属性</span></span><br><span class="line">    configurer.configure(factory, connectionFactory);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象的RabbitListenerContainerFactory 公用参数使用</span></span><br><span class="line">AbstractRabbitListenerContainerFactory&lt;C extends AbstractMessageListenerContainer&gt;</span><br><span class="line">  implements RabbitListenerContainerFactory&lt;C&gt;, ApplicationContextAware, ApplicationEventPublisherAware</span><br><span class="line"><span class="comment">//使用模板方法创建ListenerContainer  -》注册的时候使用-&gt;创建ListenerContainer    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> C <span class="title">createListenerContainer</span><span class="params">(RabbitListenerEndpoint endpoint)</span> </span>&#123;</span><br><span class="line">    C instance = createContainerInstance();</span><br><span class="line">    <span class="comment">//... 设置公用参数</span></span><br><span class="line">    <span class="comment">//初始化实例，设置不同容器的不同配置参数</span></span><br><span class="line">    initializeContainer(instance, endpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnableRabbit注解类"><a href="#EnableRabbit注解类" class="headerlink" title="EnableRabbit注解类"></a>EnableRabbit注解类</h2><h3 id="Import-RabbitListenerConfigurationSelector-class"><a href="#Import-RabbitListenerConfigurationSelector-class" class="headerlink" title="@Import(RabbitListenerConfigurationSelector.class)"></a>@Import(RabbitListenerConfigurationSelector.class)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitListenerConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; RabbitBootstrapConfiguration.class.getName() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>selectImports方法，导入RabbitBootstrapConfiguration</p><h2 id="RabbitBootstrapConfiguration"><a href="#RabbitBootstrapConfiguration" class="headerlink" title="RabbitBootstrapConfiguration"></a>RabbitBootstrapConfiguration</h2><p>RabbitBootstrapConfiguration implements <strong>ImportBeanDefinitionRegistrar</strong>，用于注册BeanDefinition。</p><p>registerBeanDefinitions方法注册BeanDefinition<br>1、RabbitListenerAnnotationBeanPostProcessor<br>2、RabbitListenerEndpointRegistry</p><h2 id="RabbitListenerAnnotationBeanPostProcessor后置处理器"><a href="#RabbitListenerAnnotationBeanPostProcessor后置处理器" class="headerlink" title="RabbitListenerAnnotationBeanPostProcessor后置处理器"></a>RabbitListenerAnnotationBeanPostProcessor后置处理器</h2><p>主要实现了SmartInitializingSingleton，BeanPostProcessor接口，创建<strong>RabbitListenerEndpointRegistrar</strong> <strong>registrar</strong>成员变量，设置setBeanFactory</p><h4 id="afterSingletonsInstantiated方法"><a href="#afterSingletonsInstantiated方法" class="headerlink" title="afterSingletonsInstantiated方法"></a>afterSingletonsInstantiated方法</h4><p>1、**<font color="red">RabbitListenerConfigurer</font><strong>接口可以扩展，configurer.configureRabbitListeners(this.registrar);<br>2、this.registrar.setEndpointRegistry(this.endpointRegistry); 从容器中获取</strong>RabbitListenerEndpointRegistry<strong>对象<br>3、MessageHandlerMethodFactory handlerMethodFactory = this.registrar.getMessageHandlerMethodFactory();<br>4、</strong>this.registrar.afterPropertiesSet()**; //此时注册所有的Endpoints，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerAllEndpoints</span><span class="params">()</span> </span>&#123;   <span class="comment">//每个endpoint创建一个容器</span></span><br><span class="line">    <span class="comment">//通过endpoint注册监听容器</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AmqpListenerEndpointDescriptor descriptor : <span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.endpointRegistry.registerListenerContainer(<span class="comment">// NOSONAR never null</span></span><br><span class="line">                descriptor.endpoint, resolveContainerFactory(descriptor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.startImmediately = <span class="keyword">true</span>;  <span class="comment">// trigger immediate startup</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="postProcessAfterInitialization方法"><a href="#postProcessAfterInitialization方法" class="headerlink" title="postProcessAfterInitialization方法"></a>postProcessAfterInitialization方法</h4><p>1、Bean处理器，获取类、方法上的@RabbitListener，@RabbitHandler[处理不同content_type的消息]注解的元数据(方法上可使用@Payload String body, @Headers Map&lt;String,Object&gt; headers,@Header String token,Message message,String message)<br>2、processAmqpListener（）——&gt;处理RabbitListener的监听——&gt;MethodRabbitListenerEndpoint<br>3、processMultiMethodListeners==》处理RabbitHandler的监听——&gt;MultiMethodRabbitListenerEndpoint<br>4、生成MethodRabbitListenerEndpoint或者MultiMethodRabbitListenerEndpoint的实例Endpoint对象，Endpoint包含监听的相关信息（group，id,queue,exchange,相关执行方法）<br>5、最终：<strong>this.registrar.registerEndpoint(endpoint, factory);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AmqpListenerEndpointDescriptor descriptor = <span class="keyword">new</span> AmqpListenerEndpointDescriptor(endpoint, factory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.startImmediately) &#123; <span class="comment">// Register and start immediately  </span></span><br><span class="line">        <span class="keyword">this</span>.endpointRegistry.registerListenerContainer(descriptor.endpoint, <span class="comment">// NOSONAR never null</span></span><br><span class="line">                                                        resolveContainerFactory(descriptor), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.endpointDescriptors.add(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitListenerEndpointRegistry"><a href="#RabbitListenerEndpointRegistry" class="headerlink" title="RabbitListenerEndpointRegistry"></a>RabbitListenerEndpointRegistry</h2><p>主要实现了DisposableBean, SmartLifecycle接口，SmartLifecycle具有生命周期，负责创建MessageListenerContainer实例，并管理所有监听容器的启动与停止等。</p><p>RabbitListenerEndpointRegistry实例创建的MessageListenerContainer实例在其整个生命周期都是有状态的。<br>SimpleMessageListenerContainer的start()方法，负责创建消费者并启动对消息队列的监听。<br>SimpleMessageListenerContainer的stop()方法，负责销毁消费者并停止对消息队列的监听。</p><p><strong>registerListenerContainer</strong>方法， 注册监听的容器即创建监听容器<br>1、MessageListenerContainer container = createListenerContainer(endpoint, factory);<br>2、this.listenerContainers.put(id, container);<br>3、containerGroup.add(container);<br>4、startIfNecessary(MessageListenerContainer listenerContainer)——》<strong>listenerContainer.start();</strong></p><h2 id="MessageListenerContainer"><a href="#MessageListenerContainer" class="headerlink" title="MessageListenerContainer"></a>MessageListenerContainer</h2><img src="/2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/MessageListenerContainer.png" style="zoom: 67%;"><h3 id="AbstractMessageListenerContainer"><a href="#AbstractMessageListenerContainer" class="headerlink" title="AbstractMessageListenerContainer"></a>AbstractMessageListenerContainer</h3><p><strong>listenerContainer.start();</strong><br>1、configureAdminIfNeeded();<br>2、checkMismatchedQueues();<br>3、最后doStart();</p><p><strong>doStart();</strong><br>1、DirectMessageListenerContainer#doStart();<br>2、SimpleMessageListenerContainer#doStart();</p><h3 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Executor taskExecutor = <span class="keyword">new</span> SimpleAsyncTaskExecutor();</span><br><span class="line"><span class="comment">//容器开始</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> newConsumers = initializeConsumers();</span><br><span class="line">    Set&lt;AsyncMessageProcessingConsumer&gt; processors = <span class="keyword">new</span> HashSet&lt;AsyncMessageProcessingConsumer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (BlockingQueueConsumer consumer : <span class="keyword">this</span>.consumers) &#123;</span><br><span class="line">        AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">        processors.add(processor);</span><br><span class="line">        getTaskExecutor().execute(processor);</span><br><span class="line">        <span class="keyword">if</span> (getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    waitForConsumersToStart(processors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">receiveAndExecute</span><span class="params">(<span class="keyword">final</span> BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">// NOSONAR</span></span><br><span class="line">    PlatformTransactionManager transactionManager = getTransactionManager();</span><br><span class="line">    <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.transactionTemplate == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.transactionTemplate =</span><br><span class="line">                    <span class="keyword">new</span> TransactionTemplate(transactionManager, getTransactionAttribute());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.transactionTemplate</span><br><span class="line">                .execute(status -&gt; &#123; <span class="comment">// NOSONAR null never returned</span></span><br><span class="line">                    RabbitResourceHolder resourceHolder = ConnectionFactoryUtils.bindResourceToTransaction(</span><br><span class="line">                        <span class="keyword">new</span> RabbitResourceHolder(consumer.getChannel(), <span class="keyword">false</span>),</span><br><span class="line">                        getConnectionFactory(), <span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// unbound in ResourceHolderSynchronization.beforeCompletion()</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> doReceiveAndExecute(consumer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (RuntimeException e1) &#123;</span><br><span class="line">                        prepareHolderForRollback(resourceHolder, e1);</span><br><span class="line">                        <span class="keyword">throw</span> e1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> WrappedTransactionException(e2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (WrappedTransactionException e) &#123; <span class="comment">// NOSONAR exception flow control</span></span><br><span class="line">            <span class="keyword">throw</span> (Exception) e.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doReceiveAndExecute</span><span class="params">(BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//NOSONAR</span></span><br><span class="line">        Channel channel = consumer.getChannel();</span><br><span class="line">        List&lt;Message&gt; messages = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> deliveryTag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.batchSize; i++) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Waiting for message from consumer.&quot;</span>);</span><br><span class="line">            Message message = consumer.nextMessage(<span class="keyword">this</span>.receiveTimeout);</span><br><span class="line">            <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.consumerBatchEnabled) &#123;</span><br><span class="line">                Collection&lt;MessagePostProcessor&gt; afterReceivePostProcessors = getAfterReceivePostProcessors();</span><br><span class="line">                <span class="keyword">if</span> (afterReceivePostProcessors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Message original = message;</span><br><span class="line">                    deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">                    <span class="keyword">for</span> (MessagePostProcessor processor : getAfterReceivePostProcessors()) &#123;</span><br><span class="line">                        message = processor.postProcessMessage(message);</span><br><span class="line">                        <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.logger.debug(</span><br><span class="line">                                    <span class="string">&quot;Message Post Processor returned &#x27;null&#x27;, discarding message &quot;</span> + original);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (messages == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        messages = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.batchSize);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isDeBatchingEnabled() &amp;&amp; getBatchingStrategy().canDebatch(message.getMessageProperties())) &#123;</span><br><span class="line">                        <span class="keyword">final</span> List&lt;Message&gt; messageList = messages;</span><br><span class="line">                        getBatchingStrategy().deBatch(message, fragment -&gt; messageList.add(fragment));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        messages.add(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executeListener(channel, message);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (ImmediateAcknowledgeAmqpException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;User requested ack for failed delivery &#x27;&quot;</span></span><br><span class="line">                                          + e.getMessage() + <span class="string">&quot;&#x27;: &quot;</span></span><br><span class="line">                                          + message.getMessageProperties().getDeliveryTag());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.debug(<span class="string">&quot;User requested ack for failed delivery: &quot;</span></span><br><span class="line">                                              + message.getMessageProperties().getDeliveryTag());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (getTransactionManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getTransactionAttribute().rollbackOn(ex)) &#123;</span><br><span class="line">                            RabbitResourceHolder resourceHolder = (RabbitResourceHolder) TransactionSynchronizationManager</span><br><span class="line">                                .getResource(getConnectionFactory());</span><br><span class="line">                            <span class="keyword">if</span> (resourceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                consumer.clearDeliveryTags();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we don&#x27;t actually have a transaction, we have to roll back</span></span><br><span class="line"><span class="comment"> * manually. See prepareHolderForRollback().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">                                consumer.rollbackOnExceptionIfNecessary(ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">throw</span> ex; <span class="comment">// encompassing transaction will handle the rollback.</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.logger.debug(<span class="string">&quot;No rollback for &quot;</span> + ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        consumer.rollbackOnExceptionIfNecessary(ex);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.consumerBatchEnabled &amp;&amp; messages != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executeWithList(channel, messages, deliveryTag, consumer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> consumer.commitIfNecessary(isChannelLocallyTransacted());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、this.consumers = new HashSet<BlockingQueueConsumer>(this.concurrentConsumers);当前消费者数量<br>2、<strong>BlockingQueueConsumer</strong> consumer = createBlockingQueueConsumer();每个消费者处理预处理条数（prefetchCount，batchSize谁大选谁）<br>3、private final BlockingQueue<Delivery> queue =new <strong>LinkedBlockingQueue</strong><Delivery>(prefetchCount，batchSize谁大选谁); BlockingQueueConsumer 里的成员变量<br>3、循环生成<strong>AsyncMessageProcessingConsumer</strong> processor = new AsyncMessageProcessingConsumer(consumer); 私有线程内部类，实现<strong>Runnable</strong><br>4、getTaskExecutor().execute(processor); 线程池执行器执行线程</Delivery></Delivery></BlockingQueueConsumer></p><h4 id="BlockingQueueConsumer"><a href="#BlockingQueueConsumer" class="headerlink" title="BlockingQueueConsumer"></a>BlockingQueueConsumer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, InternalConsumer&gt; consumers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] queues; <span class="comment">//队列名称-》一个监听容器可以监听多个队列，会创建多个Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setQosAndreateConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.acknowledgeMode.isAutoAck() &amp;&amp; !cancelled()) &#123;</span><br><span class="line">        <span class="comment">// Set basicQos before calling basicConsume (otherwise if we are not acking the broker</span></span><br><span class="line">        <span class="comment">// will send blocks of 100 messages)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cancelled()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String queueName : <span class="keyword">this</span>.queues) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.missingQueues.contains(queueName)) &#123;</span><br><span class="line">                    consumeFromQueue(queueName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeFromQueue</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InternalConsumer consumer = <span class="keyword">new</span> InternalConsumer(<span class="keyword">this</span>.channel, queue);</span><br><span class="line">    String consumerTag = <span class="keyword">this</span>.channel.basicConsume(queue, <span class="keyword">this</span>.acknowledgeMode.isAutoAck(),</span><br><span class="line">                                                   (<span class="keyword">this</span>.tagStrategy != <span class="keyword">null</span> ?                        <span class="keyword">this</span>.tagStrategy.createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="keyword">this</span>.noLocal,</span><br><span class="line">                                                   <span class="keyword">this</span>.exclusive, <span class="keyword">this</span>.consumerArgs,</span><br><span class="line">                                                   consumer);</span><br><span class="line">    <span class="keyword">if</span> (consumerTag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.consumers.put(queue, consumer);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Started on queue &#x27;&quot;</span> + queue + <span class="string">&quot;&#x27; with tag &quot;</span> + consumerTag + <span class="string">&quot;: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Null consumer tag received for queue &quot;</span> + queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AsyncMessageProcessingConsumer"><a href="#AsyncMessageProcessingConsumer" class="headerlink" title="AsyncMessageProcessingConsumer"></a>AsyncMessageProcessingConsumer</h4><p>SimpleMessageListenerContainer内部类，实现了Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AsyncMessageProcessingConsumer(BlockingQueueConsumer consumer) &#123;</span><br><span class="line"><span class="keyword">this</span>.consumer = consumer;</span><br><span class="line"><span class="keyword">this</span>.start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// NOSONAR - complexity - many catch blocks</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、redeclareElementsIfNecessary();根据容器中的Queue、Exchange、Binding,在broker中创建</span></span><br><span class="line">    <span class="comment">//2、this.consumer.start();  调用BlockingQueueConsumer中start()。</span></span><br><span class="line">    <span class="comment">//passiveDeclarations();setQosAndreateConsumers();设置Qos</span></span><br><span class="line">    initialize(); </span><br><span class="line">    <span class="comment">//boolean receivedOk = receiveAndExecute(this.consumer);处理堵塞队列message</span></span><br><span class="line">    mainLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InternalConsumer"><a href="#InternalConsumer" class="headerlink" title="InternalConsumer"></a>InternalConsumer</h4><p>InternalConsumer 是BlockingQueueConsumer的私有内部类，继承com.rabbitmq.client.<strong>DefaultConsumer</strong>。handleDelivery方法会向BlockingQueueConsumer实例的成员变量queue中添加数据，等待消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">byte</span>[] body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Storing delivery for consumerTag: &#x27;&quot;</span></span><br><span class="line">                     + consumerTag + <span class="string">&quot;&#x27; with deliveryTag: &#x27;&quot;</span> + envelope.getDeliveryTag() + <span class="string">&quot;&#x27; in &quot;</span></span><br><span class="line">                     + BlockingQueueConsumer.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (BlockingQueueConsumer.<span class="keyword">this</span>.abortStarted &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!BlockingQueueConsumer.<span class="keyword">this</span>.queue.offer(</span><br><span class="line">                <span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body, <span class="keyword">this</span>.queueName),</span><br><span class="line">                BlockingQueueConsumer.<span class="keyword">this</span>.shutdownTimeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line"></span><br><span class="line">                Channel channelToClose = <span class="keyword">super</span>.getChannel();</span><br><span class="line">                RabbitUtils.setPhysicalCloseRequired(channelToClose, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// Defensive - should never happen</span></span><br><span class="line">                BlockingQueueConsumer.<span class="keyword">this</span>.queue.clear();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.canceled) &#123;</span><br><span class="line">                    RabbitUtils.cancel(channelToClose, consumerTag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channelToClose.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> TimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">// no-op</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//核心</span></span><br><span class="line">            BlockingQueueConsumer.<span class="keyword">this</span>.queue</span><br><span class="line">                .put(<span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body, <span class="keyword">this</span>.queueName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        BlockingQueueConsumer.logger.warn(<span class="string">&quot;Unexpected exception during delivery&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DerictMessaeListenerContainer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Executor taskExecutor = <span class="keyword">new</span> SimpleAsyncTaskExecutor();</span><br><span class="line"><span class="comment">//容器开始</span></span><br><span class="line">doStart()&#123;</span><br><span class="line">    actualStart();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真的开始，一个异步线程开始创建监听的Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">actualStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queueNames.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        doRedeclareElementsIfNecessary();</span><br><span class="line">        getTaskExecutor().execute(() -&gt; &#123; <span class="comment">// NOSONAR never null here</span></span><br><span class="line">            startConsumers(queueNames);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过监听的队列名称创建Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startConsumers</span><span class="params">(<span class="keyword">final</span> String[] queueNames)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String queue : queueNames) &#123;</span><br><span class="line">        consumeFromQueue(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更加配置的consumersPerQueue为每个队列创建对应数量的Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeFromQueue</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">    List&lt;SimpleConsumer&gt; list = <span class="keyword">this</span>.consumersByQueue.get(queue);</span><br><span class="line">    <span class="comment">// Possible race with setConsumersPerQueue and the task launched by start()</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.consumersPerQueue; i++) &#123;</span><br><span class="line">            doConsumeFromQueue(queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Consuemer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doConsumeFromQueue</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">    SimpleConsumer consumer = consume(queue, connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SimpleConsumer <span class="title">consume</span><span class="params">(String queue, Connection connection)</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    SimpleConsumer consumer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = connection.createChannel(isChannelTransacted());</span><br><span class="line">        channel.basicQos(getPrefetchCount());</span><br><span class="line">        consumer = <span class="keyword">new</span> SimpleConsumer(connection, channel, queue);</span><br><span class="line">        channel.queueDeclarePassive(queue);</span><br><span class="line">        consumer.consumerTag = channel.basicConsume(queue, getAcknowledgeMode().isAutoAck(),</span><br><span class="line">                                                    (getConsumerTagStrategy() != <span class="keyword">null</span></span><br><span class="line">                                                     ? getConsumerTagStrategy().createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="comment">// NOSONAR never null</span></span><br><span class="line">                                                    isNoLocal(), isExclusive(), getConsumerArguments(), consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AmqpApplicationContextClosedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AmqpConnectException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        RabbitUtils.closeChannel(channel);</span><br><span class="line">        RabbitUtils.closeConnection(connection);</span><br><span class="line"></span><br><span class="line">        consumer = handleConsumeException(queue, consumer, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二个消费者容器区别"><a href="#二个消费者容器区别" class="headerlink" title="二个消费者容器区别"></a>二个消费者容器区别</h2><p><img src="/2020/12/15/Spring-boot-amqp%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/image-20201216160611728.png" alt="image-20201216160611728"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-boot-amqp配置原理解析</title>
      <link href="2020/12/14/Spring-boot-amqp%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/14/Spring-boot-amqp%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="CachingConnectionFactory"><a href="#CachingConnectionFactory" class="headerlink" title="CachingConnectionFactory"></a>CachingConnectionFactory</h2><p>连接工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">getCachingConnectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    factory.setAddresses(rabbitProperties.getAddresses());</span><br><span class="line">    factory.setUsername(rabbitProperties.getUsername());</span><br><span class="line">    factory.setPassword(rabbitProperties.getPassword());</span><br><span class="line">    factory.setVirtualHost(rabbitProperties.getVirtualHost());</span><br><span class="line">    factory.setPublisherConfirms(rabbitProperties.isPublisherConfirms());</span><br><span class="line">    factory.setPublisherReturns(rabbitProperties.isPublisherReturns());</span><br><span class="line">    factory.addChannelListener(rabbitChannelListener);</span><br><span class="line">    factory.addConnectionListener(rabbitConnectionListener);</span><br><span class="line">    factory.setRecoveryListener(rabbitRecoveryListener);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean(&quot;test-consumer-connection-factory&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">consumerCachingConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getCachingConnectionFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">cachingConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getCachingConnectionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在一个应用里面同时存在消费者和生产者时，为了<strong>避免消费者由于生产者阻塞而阻塞</strong>，需要特别注意：</p><ul><li>使用一个具有相同选项的单独CachingConnectionFactory实例—一个用于生产者，一个用于消费者</li><li>rabbitTemplate.setUsePublisherConnection(true);</li></ul><h2 id="RabbitTemplate"><a href="#RabbitTemplate" class="headerlink" title="RabbitTemplate"></a>RabbitTemplate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(CachingConnectionFactory factory)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;caching factory: &#123;&#125;&quot;</span>, factory.getChannelCacheSize());</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(factory);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(rabbitConfirmCallback);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当mandatory标志位设置为true时</span></span><br><span class="line"><span class="comment">         * 如果exchange根据自身类型和消息routingKey无法找到一个合适的queue存储消息</span></span><br><span class="line"><span class="comment">         * 那么broker会调用basic.return方法将消息返还给生产者</span></span><br><span class="line"><span class="comment">         * 当mandatory设置为false时，出现上述情况broker会直接将消息丢弃</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">    rabbitTemplate.setReturnCallback(rabbitReturnCallback);</span><br><span class="line">    <span class="comment">//使用单独的发送连接，避免生产者由于各种原因阻塞而导致消费者同样阻塞</span></span><br><span class="line">    rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfirmCallback：ConfirmCallback接口用于实现消息发送到RabbitMQ交换器后接收ack回调，不管是否到交换机都会进行回调<br>ReturnCallback：ReturnCallback接口用于实现消息发送到RabbitMQ交换器后，但无相应队列与交换器绑定时的回调，即无法消息从交换机中入相应队列的回调，如果成功入队列则不回调</p><h3 id="发送的消息中携带其它信息，如唯一值"><a href="#发送的消息中携带其它信息，如唯一值" class="headerlink" title="发送的消息中携带其它信息，如唯一值"></a>发送的消息中携带其它信息，如唯一值</h3><ul><li><p>可以使用header存放，使用MessagePostProcessor设置header属性</p></li><li><p>可以发送的时候携带CorrelationData对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData correlationData = <span class="keyword">new</span> CorrelationData();</span><br><span class="line">correlationData.setId(dataId);</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName, rountingKey, message, correlationData);</span><br></pre></td></tr></table></figure><p>从2.1版本开始，CorrelationData对象具有ListenableFuture，可用于获取结果，而不是在rabbitTemplate上使用ConfirmCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData cd1 = <span class="keyword">new</span> CorrelationData();</span><br><span class="line"><span class="keyword">this</span>.templateWithConfirmsEnabled.convertAndSend(<span class="string">&quot;exchange&quot;</span>, queue.getName(), <span class="string">&quot;foo&quot;</span>, cd1);</span><br><span class="line">assertTrue(cd1.getFuture().get(<span class="number">10</span>, TimeUnit.SECONDS).isAck());</span><br></pre></td></tr></table></figure></li></ul><h2 id="Message实体"><a href="#Message实体" class="headerlink" title="Message实体"></a>Message实体</h2><ul><li>Message包含属性：MessageProperties messageProperties包含属性：Map&lt;String, Object&gt; headers</li><li>Message包含属性：byte[] body</li><li>MessagePostProcessor 对Message进行处理</li></ul><h2 id="交换机队列绑定"><a href="#交换机队列绑定" class="headerlink" title="交换机队列绑定"></a>交换机队列绑定</h2><ul><li>通过rabbitAdmin进行创建交换机、队列及绑定key</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTopicExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建交换机，类型为topic, durable 参数表示是否持久化</span></span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> TopicExchange(<span class="string">&quot;test.topic&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// 创建队列 durable 参数表示是否持久化</span></span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">//链式写法</span></span><br><span class="line">    rabbitAdmin.declareBinding(</span><br><span class="line">        BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="keyword">false</span>)) <span class="comment">// 直接创建队列</span></span><br><span class="line">        .to(<span class="keyword">new</span> TopicExchange(<span class="string">&quot;test.topic&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)) <span class="comment">// 直接创建交换机，并建立关联关系</span></span><br><span class="line">        .with(<span class="string">&quot;routing_topic.*&quot;</span>) <span class="comment">// 指定路由 key</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createHeadersExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> HeadersExchange(<span class="string">&quot;test.headers&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.headers.queue&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;headers&quot;</span>);</span><br><span class="line">    Binding binding = BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.headers.queue&quot;</span>, <span class="keyword">false</span>))</span><br><span class="line">        .to(<span class="keyword">new</span> HeadersExchange(<span class="string">&quot;test.headers&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">        .whereAll(map).match();</span><br><span class="line">    rabbitAdmin.declareBinding(binding);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDirectExchange</span><span class="params">(RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">    rabbitAdmin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue1&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue2&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    rabbitAdmin.declareBinding(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue1&quot;</span>, <span class="keyword">false</span>)</span><br><span class="line">        ).to(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)).with(<span class="string">&quot;test.direct.routing&quot;</span>));</span><br><span class="line">    rabbitAdmin.declareBinding(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">&quot;test.direct.queue2&quot;</span>, <span class="keyword">false</span>)</span><br><span class="line">        ).to(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;test.direct&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)).with(<span class="string">&quot;test.direct.routing&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单方式即直接创建Bean即可，会帮助在broker上创建对应队列等<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">posThemeExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(posThemeExchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">posThemeQueueName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(posThemeQueueName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bindingPosThemeQueueName</span><span class="params">(FanoutExchange posThemeExchange,Queue posThemeQueueName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(posThemeQueueName).to(posThemeExchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//topic模式</span></span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.topic&quot;</span>, <span class="string">&quot;routing_topic.1&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message1&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.topic&quot;</span>, <span class="string">&quot;routing_topic.2&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message2&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br><span class="line"><span class="comment">//headers模式</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;headers&quot;</span>);</span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.headers&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message3&quot;</span>.getBytes(), messageProperties));</span><br><span class="line"><span class="comment">//direct模式</span></span><br><span class="line">rabbitTemplate.send(<span class="string">&quot;test.direct&quot;</span>, <span class="string">&quot;test.direct.routing&quot;</span>, <span class="keyword">new</span> Message(<span class="string">&quot;Message4&quot;</span>.getBytes(), <span class="keyword">new</span> MessageProperties()));</span><br></pre></td></tr></table></figure><h2 id="消息监听（监听的是队列）"><a href="#消息监听（监听的是队列）" class="headerlink" title="消息监听（监听的是队列）"></a>消息监听（监听的是队列）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(factory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;test.topic.queue&quot;</span>, <span class="string">&quot;test.headers.queue&quot;</span>, <span class="string">&quot;test.direct.queue1&quot;</span>, <span class="string">&quot;test.direct.queue2&quot;</span>);</span><br><span class="line">    container.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到：&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleMessageListenerContainer和DirectMessageListenerContainer"><a href="#SimpleMessageListenerContainer和DirectMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer和DirectMessageListenerContainer"></a>SimpleMessageListenerContainer和DirectMessageListenerContainer</h2><p>在版本2.0之前的版本中，只有一种MessageListenerContainer—SimpleMessageListenerContainer;</p><p>2.0之后有第二个容器——DirectMessageListenerContainer</p><h4 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h4><p>默认情况下，侦听器容器将启动单个使用者，该使用者将从队列接收消息。控制并发性的属性concurrentConsumers，它只创建(固定的)将并发处理消息的使用者数量。还添加了一个新的属性maxConcurrentConsumers，容器将根据工作负载动态调整并发性。与四个附加属性一起工作:continutiveactivetrigger、startConsumerMinInterval、continutiveidletrigger、stopConsumerMinInterval。</p><p>在默认设置下，增加消费者的算法工作如下：</p><p>如果尚未到达maxConcurrentConsumers，并且已有的使用者连续10个周期处于活动状态，并且自上一个使用者启动以来至少已经过了10秒，那么将启动一个新的使用者。如果使用者在txSize *中接收到至少一条消息，则认为该使用者处于活动状态。</p><p>在默认设置下，减少消费者的算法工作如下:</p><p>如果有多个concurrentConsumers正在运行，并且某个consumer检测到10个连续超时(空闲)，并且上一个consumer至少在60秒之前停止，那么该consumer将停止。超时取决于receiveTimeout和txSize属性。如果使用者在txSize *中没有接收到任何消息，则认为它是空闲的。因此，在默认超时(1秒)和txSize为4的情况下，在40秒的空闲时间(4个超时对应1个空闲检测)之后将考虑停止使用者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">simpleRabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="comment">//初始化消费者数量</span></span><br><span class="line">    factory.setConcurrentConsumers(<span class="keyword">this</span>.concurrentConsumers);</span><br><span class="line">    <span class="comment">//最大消费者数量</span></span><br><span class="line">    factory.setMaxConcurrentConsumers(<span class="keyword">this</span>.maxConcurrentConsumers);</span><br><span class="line">    <span class="comment">//手动确认消息</span></span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">    factory.setErrorHandler(rabbitErrorHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DirectMessageListenerContainer"><a href="#DirectMessageListenerContainer" class="headerlink" title="DirectMessageListenerContainer"></a>DirectMessageListenerContainer</h4><p>使用DirectMessageListenerContainer，您需要确保ConnectionFactory配置了一个任务执行器，该执行器在使用该ConnectionFactory的所有侦听器容器中具有足够的线程来支持所需的并发性。默认连接池大小仅为5。</p><p>并发性基于配置的队列和consumersPerQueue。每个队列的每个使用者使用一个单独的通道，并发性由rabbit客户端库控制;默认情况下，它使用5个线程池;您可以配置taskExecutor来提供所需的最大并发性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectRabbitListenerContainerFactory <span class="title">directRabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    DirectRabbitListenerContainerFactory factory = <span class="keyword">new</span> DirectRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="comment">//每个队列的消费者数量</span></span><br><span class="line">    factory.setConsumersPerQueue(<span class="keyword">this</span>.consumersPerQueue);</span><br><span class="line">    <span class="comment">//手动确认消息</span></span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">    factory.setErrorHandler(rabbitErrorHandler);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>SimpleMessageListenerContainer提供了以下特性，但DirectMessageListenerContainer不提供:</p><ul><li>txSize—使用SimpleMessageListenerContainer，您可以将其设置为控制事务中传递的消息数量和/或减少ack的数量，但这可能会导致失败后重复传递的数量增加。(与txSize和SimpleMessageListenerContainer一样，DirectMessageListenerContainer也有mesagesPerAck，可以用来减少ack，但不能用于事务—每个消息都在单独的事务中交付和打包)。</li><li>maxconcurrentconsumer和consumer伸缩间隔/触发器—DirectMessageListenerContainer中没有自动伸缩;但是，它允许您以编程方式更改consumersPerQueue属性，并相应地调整使用者。</li></ul><p>与SimpleMessageListenerContainer相比，DirectMessageListenerContainer有以下优点:</p><ul><li>在运行时添加和删除队列更有效;使用SimpleMessageListenerContainer，整个使用者线程重新启动(所有使用者取消并重新创建);对于DirectMessageListenerContainer，不受影响的使用者不会被取消。</li><li>避免了RabbitMQ客户机线程和使用者线程之间的上下文切换。</li><li>线程是跨使用者共享的，而不是为SimpleMessageListenerContainer中的每个使用者都有一个专用线程。但是，请参阅“线程和异步使用者”一节中有关连接工厂配置的重要说明。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yingziisme/category_8289776.html">RabbitMQ</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基础之事件监听</title>
      <link href="2020/12/14/RabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/"/>
      <url>2020/12/14/RabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.csdn.net/yingziisme">yingziisme</a></p><p>出处：<a href="https://blog.csdn.net/yingziisme/article/details/86418540">https://blog.csdn.net/yingziisme/article/details/86418540</a></p><h2 id="ChannelListener"><a href="#ChannelListener" class="headerlink" title="ChannelListener"></a>ChannelListener</h2><p>用于监听通道的创建和销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitChannelListener</span> <span class="keyword">implements</span> <span class="title">ChannelListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;======================onCreate channel: &#123;&#125;, transactional: &#123;&#125;&quot;</span>, channel, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可根据isHardError判断是channel断开还是connection断开</span></span><br><span class="line">        <span class="keyword">if</span>(signal.isHardError())&#123;</span><br><span class="line">            AMQImpl.Connection.Close close = (AMQImpl.Connection.Close) signal.getReason();</span><br><span class="line">            log.warn(<span class="string">&quot;=====================Connection onShutDown replyCode: &#123;&#125;, methodId: &#123;&#125;, classId: &#123;&#125;, replyText: &#123;&#125;&quot;</span>,</span><br><span class="line">                    close.getReplyCode(), close.getMethodId(), close.getClassId(), close.getReplyText());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            AMQImpl.Channel.Close close = (AMQImpl.Channel.Close) signal.getReason();</span><br><span class="line">            log.warn(<span class="string">&quot;=====================Channel onShutDown replyCode: &#123;&#125;, methodId: &#123;&#125;, classId: &#123;&#125;, replyText: &#123;&#125;&quot;</span>,</span><br><span class="line">                    close.getReplyCode(), close.getMethodId(), close.getClassId(), close.getReplyText());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConnectionListener"><a href="#ConnectionListener" class="headerlink" title="ConnectionListener"></a>ConnectionListener</h2><p>用于监听连接的创建和关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConnectionListener</span> <span class="keyword">implements</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onCreate: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onClose: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onShutDown: &#123;&#125;&quot;</span>, signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RecoveryListener"><a href="#RecoveryListener" class="headerlink" title="RecoveryListener"></a>RecoveryListener</h2><p>监听自动重连的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitRecoveryListener</span> <span class="keyword">implements</span> <span class="title">RecoveryListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecovery</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================handleRecovery: &#123;&#125;&quot;</span>, recoverable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecoveryStarted</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================handleRecoveryStarted: &#123;&#125;&quot;</span>, recoverable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockedListener"><a href="#BlockedListener" class="headerlink" title="BlockedListener"></a>BlockedListener</h2><p>监听连接阻塞情况的监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitBlockedListener</span> <span class="keyword">implements</span> <span class="title">BlockedListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBlocked</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;=========================connection blocked, reason: &#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUnblocked</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;==============================connection unblocked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="是在RabbitMQ-connection连接上的时候设置进去的"><a href="#是在RabbitMQ-connection连接上的时候设置进去的" class="headerlink" title="是在RabbitMQ connection连接上的时候设置进去的"></a>是在RabbitMQ connection连接上的时候设置进去的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConnectionListener</span> <span class="keyword">implements</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitBlockedListener rabbitBlockedListener;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onCreate: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">        connection.addBlockedListener(rabbitBlockedListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onClose: &#123;&#125;&quot;</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;================onShutDown: &#123;&#125;&quot;</span>, signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，RabbitMQ的状态是这样的</p><p><img src="/2020/12/14/RabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/20190113143502400.jpg" alt="在这里插入图片描述"></p><h4 id="测试内存报警"><a href="#测试内存报警" class="headerlink" title="测试内存报警"></a>测试内存报警</h4><p>RabbitMQ内存报警水位是由vm_memory_high_watermark来控制的</p><p>在RabbitMQ使用 rabbitmqctl set_vm_memory_high_watermark 0.01</p><ul><li>设置内存报警的水位，当内存使用达到了该水位时，RabbitMQ将产生报警</li><li>可以通过rabbitmqctl status | grep vm_memory_high_watermark查看当前的水位设置，默认时0.4</li></ul><p>此时查看报警时的RabbitMQ的状态</p><p><img src="/2020/12/14/RabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/201901131435132.jpg" alt="在这里插入图片描述"></p><p>此时往RabbitMQ发送一条消息，将会收到BlockedListener的消息，且reason会提示具体的错误原因</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">49</span>:<span class="number">53.408</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : =========================connection blocked, reason:low on memory</span><br></pre></td></tr></table></figure><p>再将水位修改回来<br>rabbitmqctl set_vm_memory_high_watermark 0.4</p><p>查看此时的程序的打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">51</span>:<span class="number">40.386</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">2</span>:<span class="number">351</span>:<span class="number">40.396</span>  INFO <span class="number">73408</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">51</span>:<span class="number">40.398</span>  INFO <span class="number">73408</span> --- [cTaskExecutor-<span class="number">4</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="测试磁盘报警"><a href="#测试磁盘报警" class="headerlink" title="测试磁盘报警"></a>测试磁盘报警</h4><p>同样的修改磁盘的配置rabbitmqctl set_disk_free_limit  48G</p><ul><li>设置空闲磁盘的大小，空闲值小于该值时产生报警，默认时48M</li><li>也可以使用这个命令将磁盘和内存的大小关联起来设置 xx时磁盘和内存的配比 rabbitmqctl set_disk_free_limit mem_relative xx</li></ul><p>此时查看RabbitMQ的控制台<br><img src="/2020/12/14/RabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/20190113143526140.jpg" alt="在这里插入图片描述"></p><p>此时往RabbitMQ发送一条消息，将会收到BlockedListener的消息，且reason会提示具体的错误原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-01-09 23:58:17.318  INFO 49240 --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;connection blocked, reason:low on disk</span><br></pre></td></tr></table></figure><p>再将磁盘限制修改回来rabbitmqctl set_disk_free_limit 48M</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.793</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.801</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">58</span>:<span class="number">49.806</span>  INFO <span class="number">49240</span> --- [cTaskExecutor-<span class="number">3</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="测试同时报警"><a href="#测试同时报警" class="headerlink" title="测试同时报警"></a>测试同时报警</h4><p>同时设置内存和磁盘报警<br><img src="/2020/12/14/RabbitMQ%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/2019011314353976.jpg" alt="在这里插入图片描述"><br>发送消息到队列，则会在这个监听器产生报警信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">08.811</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : =========================connection blocked, reason:low on disk &amp; memory</span><br></pre></td></tr></table></figure><p>需要同时解除内存和磁盘的报警才会收到unblock的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">764</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.demo.listener.RabbitBlockedListener  : ==============================connection unblocked</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">765</span>  INFO <span class="number">49240</span> --- [xxxxxxx] c.m.d.l.i.ConfirmCallbackListenerImpl    : ConfirmCallbackListener thread:  CorrelationData: <span class="keyword">null</span>, ack: <span class="keyword">true</span>, cause: <span class="keyword">null</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">05</span>.<span class="number">766</span>  INFO <span class="number">49240</span> --- [cTaskExecutor-<span class="number">2</span>] com.mt.demo.rabbitmq.HelloListener2      : receive <span class="keyword">int</span> msg: <span class="number">30</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon源码解析</title>
      <link href="2020/12/11/Ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/11/Ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://www.cnblogs.com/trust-freedom/">Trust_FreeDom</a></p><p>出处：<a href="https://www.cnblogs.com/trust-freedom/p/11216280.html#3560239013">https://www.cnblogs.com/trust-freedom/p/11216280.html#3560239013</a></p><p>事情的起因是这样的，公司内部要实现基于Zuul网关的灰度路由，在上线时进行灰度测试，故需要配置业务微服务向Eureka注册的metadata元数据，和自定义Ribbon的负载规则达到只访问灰度服务的目的。这样就需要自定义Ribbon的IRule，实现灰度请求只会负载到带有灰度标签元数据的业务微服务上，当自定义IRule规则开发好后，问题是如何将这个IRule规则配置给某个Ribbon Client或者全局生效。</p><blockquote><p>本次使用Spring Cloud Dalston.SR5版本</p><p>在其 <a href="https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi_spring-cloud-ribbon.html">官方文档</a> 中其实已经给出了一些如何针对某个Client 或者 修改默认配置的方式，但没有说明为什么这样使用</p></blockquote><p>下面将按照这样的思路分析：</p><ul><li>简单分析Spring Cloud Ribbon启动时如何自动配置的，以了解其装配到Spring中的Bean</li><li>Spring Cloud Ribbon Client的懒加载</li><li>Spring Cloud Ribbon Client的配置加载，包含全局配置及Client配置</li><li>如何自定义Client配置、全局配置</li><li>解释官方文档中的一些注意事项<h2 id="Spring-Cloud-Ribbon自动配置"><a href="#Spring-Cloud-Ribbon自动配置" class="headerlink" title="Spring Cloud Ribbon自动配置"></a>Spring Cloud Ribbon自动配置</h2></li></ul><p>当前版本中的Netflix所有自动配置都在<code>spring-cloud-netflix-core-xxx.jar</code>中，根据其<code>META-INF/spring.factories</code>中的配置得知，Spring Cloud Ribbon的自动配置类为 <strong><code>RibbonAutoConfiguration</code></strong><br><img src="/2020/12/11/Ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/677054-20190719235138006-1969052898.jpg" alt="img"></p><h2 id="RibbonAutoConfiguration"><a href="#RibbonAutoConfiguration" class="headerlink" title="RibbonAutoConfiguration"></a>RibbonAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; IClient.class, RestTemplate.class, AsyncRestTemplate.class, Ribbon.class&#125;)</span></span><br><span class="line"><span class="meta">@RibbonClients</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(name = &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RibbonEagerLoadProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有针对某个RibbonClient指定的配置</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ribbon是否懒加载的配置文件</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会给每个RibbonClient创建独立的ApplicationContext上下文</span></span><br><span class="line">    <span class="comment">// 并在其上下文中创建RibbonClient对应的Bean：如IClient、ILoadbalancer等</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring创建的带负载均衡功能的Client，会使用SpringClientFactory创建对应的Bean和配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(LoadBalancerClient.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(springClientFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到Spring environment中加载针对某个Client的Ribbon的核心接口实现类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertiesFactory <span class="title">propertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PropertiesFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是懒加载，启动时就使用RibbonApplicationContextInitializer加载并初始化客户端配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;ribbon.eager-load.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RibbonApplicationContextInitializer <span class="title">ribbonApplicationContextInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RibbonApplicationContextInitializer(springClientFactory(),</span><br><span class="line">ribbonEagerLoadProperties.getClients());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>RibbonAutoConfiguration</code>创建的Bean主要分以下几类：</p><ul><li>为Ribbon Client创建环境及获取配置<ul><li><strong>SpringClientFactory</strong>： 会给每个Ribbon Client创建一个独立的Spring应用上下文ApplicationContext，并在其中加载对应的配置及Ribbon核心接口的实现类</li><li><strong>PropertiesFactory</strong>： 用于从Spring enviroment环境中获取针对某个Ribbon Client配置的核心接口实现类，并实例化</li></ul></li><li>创建<code>RibbonLoadBalancerClient</code>，并将springClientFactory注入，方便从中获取对应的配置及实现类，<code>RibbonLoadBalancerClient</code>是Spring对<code>LoadBalancerClient</code>接口的实现类，其<code>execute()</code>方法提供客户端负载均衡能力</li><li>懒加载相关<ul><li>RibbonEagerLoadProperties： 懒加载配置项Properties，可以指定是否懒加载，及哪些Client不懒加载</li><li>RibbonApplicationContextInitializer： 启动时就加载RibbonClient配置（非懒加载）的初始化器</li></ul></li></ul><p>可以看到默认启动流程中并没有加载RibbonClient的上下文和配置信息，而是在使用时才加载，即懒加载</p><h2 id="Spring-Cloud-RibbonClient的懒加载"><a href="#Spring-Cloud-RibbonClient的懒加载" class="headerlink" title="Spring Cloud RibbonClient的懒加载"></a>Spring Cloud RibbonClient的懒加载</h2><p>既然是在使用时才会加载，那么以Zuul网关为例，在其<code>RibbonRoutingFilter</code>中会创建RibbonCommand，其包含了Ribbon的负载均衡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## RibbonRoutingFilter  Zuul负责路由的Filter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRoutingFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line"><span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RibbonCommandContext commandContext = buildCommandContext(context);</span><br><span class="line">ClientHttpResponse response = forward(commandContext);</span><br><span class="line">setResponse(response);</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ZuulException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">forward</span><span class="params">(RibbonCommandContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; info = <span class="keyword">this</span>.helper.debug(context.getMethod(),</span><br><span class="line">context.getUri(), context.getHeaders(), context.getParams(),</span><br><span class="line">context.getRequestEntity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ribbonCommandFactory创建RibbonCommand</span></span><br><span class="line">RibbonCommand command = <span class="keyword">this</span>.ribbonCommandFactory.create(context);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ClientHttpResponse response = command.execute();</span><br><span class="line"><span class="keyword">this</span>.helper.appendDebug(info, response.getStatusCode().value(),</span><br><span class="line">response.getHeaders());</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (HystrixRuntimeException ex) &#123;</span><br><span class="line"><span class="keyword">return</span> handleException(info, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行<code>RibbonRoutingFilter#run()</code>进行路由时会执行<code>forward()</code>方法，由于此处是在<strong>HystrixCommand</strong>内部执行Ribbon负载均衡调用，故使用ribbonCommandFactory创建RibbonCommand，Ribbon客户端的懒加载就在这个方法内，这里我们看<code>HttpClientRibbonCommandFactory</code>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.zuul.filters.route.apache.HttpClientRibbonCommandFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonCommandFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRibbonCommandFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpClientRibbonCommand <span class="title">create</span><span class="params">(<span class="keyword">final</span> RibbonCommandContext context)</span> </span>&#123;</span><br><span class="line">ZuulFallbackProvider zuulFallbackProvider = getFallbackProvider(context.getServiceId());</span><br><span class="line"><span class="keyword">final</span> String serviceId = context.getServiceId();</span><br><span class="line">        <span class="comment">// 通过SpringClientFactory获取IClient接口实例</span></span><br><span class="line"><span class="keyword">final</span> RibbonLoadBalancingHttpClient client = <span class="keyword">this</span>.clientFactory.getClient(</span><br><span class="line">serviceId, RibbonLoadBalancingHttpClient.class);</span><br><span class="line">client.setLoadBalancer(<span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommand(serviceId, client, context, zuulProperties, zuulFallbackProvider,</span><br><span class="line">clientFactory.getClientConfig(serviceId));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>RibbonLoadBalancingHttpClient</code>的逻辑在 <code>SpringClientFactory#getClient(serviceId, RibbonLoadBalancingHttpClient.class)</code>，如下：</p><ul><li>SpringClientFactory#getInstance(name, clientClass)<ul><li>NamedContextFactory#getInstance(name, type)：<ul><li>获取Client对应的ApplicationContext，如没有则调用createContext()创建，其中包含注册统一默认配置类RibbonClientConfiguration，或@RibbonClient、@RibbonClients(defaultConfiguration=xxx) 设置的配置类的逻辑</li><li>从ApplicationContext中根据类型获取实例，如没有使用反射创建，并通过IClientConfig配置</li></ul></li></ul></li></ul><p>如上执行完毕RibbonClient就基本懒加载完成了，就可以到RibbonClient对应的ApplicationContext中继续获取其它核心接口的实现类了，这些实现类都是根据 <strong>默认/全局/Client自定义</strong> 配置创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.SpringClientFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringClientFactory</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">RibbonClientSpecification</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String NAMESPACE = <span class="string">&quot;ribbon&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(RibbonClientConfiguration.class, NAMESPACE, <span class="string">&quot;ribbon.client.name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the rest client associated with the name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RuntimeException if any error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;C extends IClient&lt;?, ?&gt;&gt; <span class="function">C <span class="title">getClient</span><span class="params">(String name, Class&lt;C&gt; clientClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getInstance(name, clientClass);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// name代表当前Ribbon客户端，type代表要获取的实例类型，如IClient、IRule</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">getInstance</span><span class="params">(String name, Class&lt;C&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先从父类NamedContextFactory中直接从客户端对应的ApplicationContext中获取实例</span></span><br><span class="line">        <span class="comment">// 如果没有就根据IClientConfig中的配置找到具体的实现类，并通过反射初始化后放到Client对应的ApplicationContext中</span></span><br><span class="line">C instance = <span class="keyword">super</span>.getInstance(name, type);</span><br><span class="line"><span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">IClientConfig config = getInstance(name, IClientConfig.class);</span><br><span class="line"><span class="keyword">return</span> instantiateWithConfig(getContext(name), type, config);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用IClientConfig实例化</span></span><br><span class="line">    <span class="keyword">static</span> &lt;C&gt; <span class="function">C <span class="title">instantiateWithConfig</span><span class="params">(AnnotationConfigApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;C&gt; clazz, IClientConfig config)</span> </span>&#123;</span><br><span class="line">C result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过以IClientConfig为参数的构造创建clazz类实例</span></span><br><span class="line">Constructor&lt;C&gt; constructor = clazz.getConstructor(IClientConfig.class);</span><br><span class="line">result = constructor.newInstance(config);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="comment">// Ignored</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没创建成功，使用无惨构造</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">result = BeanUtils.instantiate(clazz);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用初始化配置方法</span></span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> IClientConfigAware) &#123;</span><br><span class="line">((IClientConfigAware) result).initWithNiwsConfig(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理自动织入</span></span><br><span class="line"><span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.getAutowireCapableBeanFactory().autowireBean(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//## 父类 org.springframework.cloud.context.named.NamedContextFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">// 维护Ribbon客户端对应的ApplicationContext上下文</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护Ribbon客户端的@Configuration配置类</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defaultConfigType;  <span class="comment">// 默认配置类为 RibbonClientConfiguration</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertySourceName;  <span class="comment">// 默认为 ribbon</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertyName;  <span class="comment">// 默认读取RibbonClient名的属性为ribbon.client.name</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamedContextFactory</span><span class="params">(Class&lt;?&gt; defaultConfigType, String propertySourceName,</span></span></span><br><span class="line"><span class="function"><span class="params">String propertyName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType = defaultConfigType;</span><br><span class="line"><span class="keyword">this</span>.propertySourceName = propertySourceName;</span><br><span class="line"><span class="keyword">this</span>.propertyName = propertyName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果包含Client上下文直接返回</span></span><br><span class="line"><span class="comment">// 如果不包含，调用createContext(name)，并放入contexts集合</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建名为name的RibbonClient的ApplicationContext上下文</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// configurations集合中是否包含当前Client相关配置类，包含即注入到ApplicationContext</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//configurations集合中是否包含default.开头的通过@RibbonClients(defaultConfiguration=xxx)配置的默认配置类</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册PropertyPlaceholderAutoConfiguration、RibbonClientConfiguration</span></span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType);</span><br><span class="line"><span class="comment">// 添加 ribbon.client.name=具体RibbonClient name的enviroment配置 </span></span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置父ApplicationContext，这样可以使得当前创建的子ApplicationContext可以使用父上下文中的Bean</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line">context.refresh();  <span class="comment">//刷新Context</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面比较重要的就是在创建每个RibbonClient的ApplicationContext的<code>createContext(name)</code>方法，其中包含了根据哪个@Configuration配置类创建Ribbon核心接口的实现类的逻辑，故需重点分析（Ribbon核心接口讲解 <a href="https://blog.csdn.net/zhxdick/article/details/79710960">参考</a>）</p><p>那么在<code>createContext(name)</code>方法创建当前Ribbon Client相关的上下文，并注入配置类时，除了默认配置类<code>RibbonClientConfiguration</code>是写死的，其它的配置类，如default全局配置类，针对某个Ribbon Client的配置类，又是怎么配置的呢？</p><h2 id="Spring-Cloud-RibbonClient的配置加载，包含全局配置及Client配置"><a href="#Spring-Cloud-RibbonClient的配置加载，包含全局配置及Client配置" class="headerlink" title="Spring Cloud RibbonClient的配置加载，包含全局配置及Client配置"></a>Spring Cloud RibbonClient的配置加载，包含全局配置及Client配置</h2><h2 id="创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类"><a href="#创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类" class="headerlink" title="创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类"></a>创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.context.named.NamedContextFactory#createContext()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、注册专门为RibbonClient指定的configuration配置类，@RibbonClient注解</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、将为所有RibbonClient的configuration配置类注册到ApplicationContext</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、注册defaultConfigType，即Spring的默认配置类 RibbonClientConfiguration</span></span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line">context.refresh();  <span class="comment">// 刷新上下文</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据如上逻辑可以看出会从3个地方将Ribbon相关的Configuration配置类注册到专门为其准备的ApplicationContext上下文，并根据配置类创建Ribbon核心接口的实现类，即达到配置RibbonClient的目的</p><ol><li>从configurations这个Map中根据RibbonClient name获取专门为其指定的configuration配置类，并注册到其对应的ApplicationContext上下文</li><li>从configurations这个Map中找到 <strong>default. 开头</strong> 的配置类，即为所有RibbonClient的默认配置，并注册到其对应的ApplicationContext上下文</li><li>如果不是开发者单独指定的话，前两项都是没有数据的，还会注册Spring Cloud的默认配置类<code>RibbonClientConfiguration</code></li></ol><p>那么configurations这个Map里的配置类数据是从哪儿来的呢？？下面逐步分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## RibbonAutoConfiguration</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是在RibbonAutoConfiguration自动配置类创建<code>SpringClientFactory</code>是设置的，这个configurations集合是@Autowired的Spring容器内的<code>RibbonClientSpecification</code>集合，那么<code>RibbonClientSpecification</code>集合是何时被注册的？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.RibbonClientConfigurationRegistrar</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfigurationRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、@RibbonClients注解</span></span><br><span class="line">Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(</span><br><span class="line">RibbonClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 1.1 value是RibbonClient[]，遍历针对具体的RibbonClient配置的configuration配置类，并注册</span></span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span> &amp;&amp; attrs.containsKey(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">AnnotationAttributes[] clients = (AnnotationAttributes[]) attrs.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes client : clients) &#123;</span><br><span class="line">registerClientConfiguration(registry, getClientName(client),</span><br><span class="line">client.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 1.2 找到@RibbonClients注解的defaultConfiguration，即默认配置</span></span><br><span class="line">        <span class="comment">//     注册成以default.Classname.RibbonClientSpecification为名的RibbonClientSpecification</span></span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span> &amp;&amp; attrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">&#125;</span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">attrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、@RibbonClient注解</span></span><br><span class="line">        <span class="comment">// 注册某个具体Ribbon Client的configuration配置类</span></span><br><span class="line">Map&lt;String, Object&gt; client = metadata.getAnnotationAttributes(</span><br><span class="line">RibbonClient.class.getName(), <span class="keyword">true</span>);</span><br><span class="line">String name = getClientName(client);</span><br><span class="line"><span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">registerClientConfiguration(registry, name, client.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(Map&lt;String, Object&gt; client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String value = (String) client.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(value)) &#123;</span><br><span class="line">value = (String) client.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">&quot;Either &#x27;name&#x27; or &#x27;value&#x27; must be provided in @RibbonClient&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">Object name, Object configuration)</span> </span>&#123;</span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(RibbonClientSpecification.class);</span><br><span class="line">builder.addConstructorArgValue(name);</span><br><span class="line">builder.addConstructorArgValue(configuration);</span><br><span class="line">registry.registerBeanDefinition(name + <span class="string">&quot;.RibbonClientSpecification&quot;</span>,</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可知，configurations配置类集合是根据<code>@RibbonClient</code> 和 <code>@RibbonClients</code> 注解配置的，分别有 <em>针对具体某个RibbonClient的配置</em> 和 <em>default默认配置</em></p><p>总结一下，Ribbon相关的@Configuration配置类是如何加载的</p><ol><li>在创建完RibbonClient对应的AnnotationConfigApplicationContext后，先从根据<code>@RibbonClient</code> 和 <code>@RibbonClients</code> 注解加载的configurations集合中找当前RibbonClient name对应的配置类，如有，就注册到上下文</li><li>再从configurations集合中找根据<code>@RibbonClients</code>注解加载的 <strong>default.开头</strong> 的默认配置类，如有，就注册到上下文</li><li>最后注册Spring Cloud默认的 <code>RibbonClientConfiguration</code></li></ol><p>上面说是如何创建RibbonClient相关的ApplicationContext上下文及注册Ribbon Client相关的配置类的逻辑，在确定配置类后，其中会用到Ribbon的<code>IClientConfig</code>相关的客户端配置来加载Ribbon客户端相关的配置信息，如超时配置、具体创建哪个核心接口的实现类等，可以从Spring Cloud默认注册的 <code>RibbonClientConfiguration</code>来一探究竟</p><h2 id="RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建"><a href="#RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建" class="headerlink" title="RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建"></a>RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration</span></span><br><span class="line"><span class="meta">@Import(&#123;OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;ribbon.client.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name = <span class="string">&quot;client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span></span><br><span class="line"><span class="comment">// associated with ribbon clients</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IClientConfig <span class="title">ribbonClientConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DefaultClientConfigImpl config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">config.loadProperties(<span class="keyword">this</span>.name);</span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">rule.initWithNiwsConfig(config);</span><br><span class="line"><span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只截取了一段代码，给出了Ribbon相关的 <code>IClientConfig</code>客户端配置 和 某一个核心接口<code>IRule</code>实现类 是如何加载配置并创建的</p><p><strong>IClientConfig</strong></p><p><code>IClientConfig</code>就是Ribbon客户端配置的接口，可以看到先是创建了<code>DefaultClientConfigImpl</code>默认实现类，再<code>config.loadProperties(this.name)</code>加载当前Client相关的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## com.netflix.client.config.DefaultClientConfigImpl#loadProperties()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load properties for a given client. It first loads the default values for all properties,</span></span><br><span class="line"><span class="comment"> * and any properties already defined with Archaius ConfigurationManager.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(String restClientName)</span></span>&#123;</span><br><span class="line">    enableDynamicProperties = <span class="keyword">true</span>;</span><br><span class="line">    setClientName(restClientName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、使用Netflix Archaius的ConfigurationManager从Spring env中加载“ribbon.配置项”这类默认配置</span></span><br><span class="line">    <span class="comment">//   如没加载到有默认静态配置</span></span><br><span class="line">    loadDefaultValues();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、使用Netflix Archaius的ConfigurationManager从Spring env中加载“client名.ribbon.配置项”这类针对某个Client的配置信息</span></span><br><span class="line">    Configuration props = ConfigurationManager.getConfigInstance().subset(restClientName);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;String&gt; keys = props.getKeys(); keys.hasNext(); )&#123;</span><br><span class="line">        String key = keys.next();</span><br><span class="line">        String prop = key;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prop.startsWith(getNameSpace()))&#123;</span><br><span class="line">                prop = prop.substring(getNameSpace().length() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setPropertyInternal(prop, getStringValue(props, key));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;Property %s is invalid&quot;</span>, prop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据如上注释，如果你没有在项目中指定ribbon相关配置，那么会使用<code>DefaultClientConfigImpl</code>中的默认静态配置，如果Spring enviroment中包含“ribbon.配置项”这类针对所有Client的配置会被加载进来，有“client名.ribbon.配置项”这类针对某个Client的配置信息也会被加载进来</p><p><strong>静态配置如下：</strong></p><p><a href="https://img2018.cnblogs.com/blog/677054/201907/677054-20190719235215286-1439271885.jpg"><img src="https://img2018.cnblogs.com/blog/677054/201907/677054-20190719235215286-1439271885.jpg" alt="img"></a></p><p><strong>RibbonClient核心接口实现类配置加载及创建</strong></p><p>上面说完<code>IClientCOnfig</code>配置项是如何加载的，按道理说其中已经包含了当前RibbonClient使用哪个核心接口实现类的配置，但Spring Cloud在此处定义了自己的实现逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看propertiesFactory是否有关于当前接口的配置，如有就使用，并创建实例返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spring cloud 默认配置</span></span><br><span class="line">ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">rule.initWithNiwsConfig(config);</span><br><span class="line"><span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看<code>PropertiesFactory</code>的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">PropertiesFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">classToProperty.put(ILoadBalancer.class, <span class="string">&quot;NFLoadBalancerClassName&quot;</span>);</span><br><span class="line">classToProperty.put(IPing.class, <span class="string">&quot;NFLoadBalancerPingClassName&quot;</span>);</span><br><span class="line">classToProperty.put(IRule.class, <span class="string">&quot;NFLoadBalancerRuleClassName&quot;</span>);</span><br><span class="line">classToProperty.put(ServerList.class, <span class="string">&quot;NIWSServerListClassName&quot;</span>);</span><br><span class="line">classToProperty.put(ServerListFilter.class, <span class="string">&quot;NIWSServerListFilterClassName&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看当前clazz是否在classToProperty管理的几个核心接口之一</span></span><br><span class="line">    <span class="comment">// 如是，查看Spring environment中是否能找到 “clientName.ribbon.核心接口配置项”的配置信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StringUtils.hasText(getClassName(clazz, name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">String classNameProperty = <span class="keyword">this</span>.classToProperty.get(clazz);</span><br><span class="line">String className = environment.getProperty(name + <span class="string">&quot;.&quot;</span> + NAMESPACE + <span class="string">&quot;.&quot;</span> + classNameProperty);</span><br><span class="line"><span class="keyword">return</span> className;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是先调用getClassName()获取Spring enviroment中配置的核心接口实现类名</span></span><br><span class="line">    <span class="comment">// 再使用IClientConfig配置信息创建其实例</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">get</span><span class="params">(Class&lt;C&gt; clazz, IClientConfig config, String name)</span> </span>&#123;</span><br><span class="line">String className = getClassName(clazz, name);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(className)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; toInstantiate = Class.forName(className);</span><br><span class="line"><span class="keyword">return</span> (C) instantiateWithConfig(toInstantiate, config);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown class to load &quot;</span>+className+<span class="string">&quot; for class &quot;</span> + clazz + <span class="string">&quot; named &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故以上面创建<code>IRule</code>接口实现类的逻辑</p><ul><li>先通过<strong>propertiesFactory</strong>查看Spring enviroment中是否配置了针对当前Ribbon Client的IRule核心接口实现类的配置信息，如有，就创建其实例返回（相关配置格式： clientName.ribbon.NFLoadBalancerRuleClassName=具体IRule实现类）</li><li>如没有，那么没有直接使用Netflix在其<code>DefaultClientConfigImpl</code>中的静态配置，而是使用Spring Cloud自定义的默认实现类，拿<code>IRule</code>规则接口来说是<code>ZoneAvoidanceRule</code></li></ul><blockquote><p><strong>总结：</strong></p><p>首先会创建RibbonClient的ApplicationContext上下文，并确定使用哪个Configuration配置类</p><p>1、@RibbonClients注册的全局默认配置类</p><p>2、@RibbonClient注册的某个Client配置类</p><p>3、Spring Cloud 默认的RibbonClientConfiguration配置类</p><p>确定配置类后就是加载Client相关的IClientConfig配置信息，并创建核心接口实现类</p><p>如果没有自定义全局/客户端配置类，那么就是使用<code>RibbonClientConfiguration</code>，而其规则是</p><p>对于超时等配置（除核心接口实现类以外）：使用Netflix的配置逻辑，通过 <strong>ribbon.xxx</strong> 作为默认配置，以 <strong>clientName.ribbon.xxx</strong> 作为客户端定制配置</p><p>对于核心接口实现类配置：客户端定制配置仍然使用 <strong>clientName.ribbon.xxx</strong>，但默认配置是Spring Cloud在<code>RibbonClientConfiguration</code>方法中写死的默认实现类</p></blockquote><p>已经知道大概的逻辑了，下面就看看具体如何自定义Client配置、全局配置</p><h2 id="如何自定义RibbonClient配置、全局配置"><a href="#如何自定义RibbonClient配置、全局配置" class="headerlink" title="如何自定义RibbonClient配置、全局配置"></a>如何自定义RibbonClient配置、全局配置</h2><p>这部分在Spring Cloud官方reference中有说明 <a href="https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi_spring-cloud-ribbon.html#_customizing_the_ribbon_client">16.2 Customizing the Ribbon Client</a></p><p><img src="/2020/12/11/Ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/677054-20190719235233605-1701546833.jpg" alt="img"></p><p>大致意思如下：</p><ul><li><p>一部分配置（非核心接口实现类的配置）可以使用Netflix原生API提供的方式，即使用如 *<em>.ribbon.**</em> 的方式配置，具体有哪些配置项，可以参考 <code>com.netflix.client.config.CommonClientConfigKey</code></p></li><li><p>如果想比较全面的控制RibbonClient并添加一些额外配置，可以使用 <code>@RibbonClient</code> 或 <code>@RibbonClients</code> 注解，并配置一个配置类，如上的 FooConfiguration</p><ul><li><p>@RibbonClient(name = “foo”, configuration = FooConfiguration.class) 是针对名为 foo 的RibbonClient的配置类，也可以使用@RibbonClients({@RibbonClient数组}) 的形式给某几个RibbonClient设置配置类</p></li><li><p>@RibbonClients( defaultConfiguration = { xxx.class } ) 是针对所有RIbbonClient的默认配置</p><ul><li><p>官方文档说 FooConfiguration配置类 必须是@Configuration的，这样就必须注意，SpringBoot主启动类不能扫描到FooConfiguration，否则针对某个RibbonClient的配置就会变成全局的，原因是在创建每个RibbonClient时会为其创建ApplicationContext上下文，其parent就是主启动类创建的ApplicationContext，子ApplicationContext中可以使用父ApplicationContext中的Bean，且创建Bean时都使用了<code>@ConditionalOnMissingBean</code>，所以FooConfiguration如果被主启动类的上下文加载，且创建了比如IRule的实现类，在某个RIbbonClient创建其子ApplicationContext并@Bean想创建其自定义IRule实现类时，会发现parent ApplicationContext已经存在，就不会创建了，配置就失效了</p><blockquote><p>但在我的实验中，即使FooConfiguration不加@Configuration注解也可以加载为RibbonClient的配置，且由于没有@Configuration了，也不会被主启动类扫描到</p></blockquote></li></ul></li></ul></li></ul><p>所以主要分成2种配置：</p><p>（1）超时时间等静态配置，使用 <strong>ribbon.*** 配置所有Client，使用 *<em>.ribbon.</em></strong> 配置某个Client</p><p>（2）使用哪种核心接口实现类配置，使用**@RibbonClients注解<strong>做默认配置，使用</strong>@RibbonClient**做针对Client的配置（注意@Configuration不要被SpringBoot主启动类扫描到的问题）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-cloud-loadbalancer入门</title>
      <link href="2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://cloud.tencent.com/developer/user/1219867">冷冷</a></p><p>出处：<a href="https://cloud.tencent.com/developer/article/1491013">https://cloud.tencent.com/developer/article/1491013</a></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><strong>加入 loadbalancer pom坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置使用还是和 ribbon 一样配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LbConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://big-provider-server/demo&quot;</span>, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="LoadBalancerClient-实现"><a href="#LoadBalancerClient-实现" class="headerlink" title="LoadBalancerClient 实现"></a>LoadBalancerClient 实现</h3><p><img src="/2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/1.jpeg"></p><ul><li>目前版本只提供了 BlockingLoadBalancerClient 的实现， 注意看中文注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除只保留了核心代码注意</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingLoadBalancerClient</span> <span class="keyword">implements</span> <span class="title">LoadBalancerClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 根据 服务名称去查询可用实例</span></span><br><span class="line">ServiceInstance serviceInstance = choose(serviceId);</span><br><span class="line"><span class="keyword">return</span> execute(serviceId, serviceInstance, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取负载均衡策略</span></span><br><span class="line">ReactiveLoadBalancer&lt;ServiceInstance&gt; loadBalancer = loadBalancerClientFactory</span><br><span class="line">.getInstance(serviceId);</span><br><span class="line"><span class="comment">// 执行负载均衡策略获取可以实例</span></span><br><span class="line">Response&lt;ServiceInstance&gt; loadBalancerResponse = Mono.from(loadBalancer.choose())</span><br><span class="line">.block();</span><br><span class="line"><span class="keyword">return</span> loadBalancerResponse.getServer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadBalancer-负载均衡策略实现"><a href="#loadBalancer-负载均衡策略实现" class="headerlink" title="loadBalancer 负载均衡策略实现"></a>loadBalancer <a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>策略实现</h3><p><img src="/2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/2.jpeg">目前只有一个RoundRobinLoadBalancer 轮询选择server的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="title">implements</span> <span class="title">ReactorServiceInstanceLoadBalancer</span> </span>&#123;</span><br><span class="line">public Mono&lt;Response&lt;ServiceInstance&gt;&gt; <span class="function"><span class="title">choose</span>(<span class="params">Request request</span>)</span> &#123;</span><br><span class="line">ServiceInstanceSupplier supplier = <span class="built_in">this</span>.serviceInstanceSupplier.getIfAvailable();</span><br><span class="line"><span class="keyword">return</span> supplier.get().collectList().map(instances -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No servers available for service: &quot;</span> + <span class="built_in">this</span>.serviceId);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EmptyResponse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> enforce order?</span></span><br><span class="line">int pos = <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.position.incrementAndGet());</span><br><span class="line"></span><br><span class="line">ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultResponse(instance);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和ribbon-比较"><a href="#和ribbon-比较" class="headerlink" title="和ribbon 比较"></a>和ribbon 比较</h2><h3 id="默认负载均衡比较"><a href="#默认负载均衡比较" class="headerlink" title="默认负载均衡比较"></a>默认负载均衡比较</h3><ul><li><p>ribbon 提供7中默认的负载均衡策略，常见的常见都有覆盖，一般我们都是使用 ZoneAvoidanceRule复合判断server所在区域的性能和server的可用性选择server</p><p><img src="/2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/3.jpeg"></p></li></ul><h3 id="配置方面丰富性"><a href="#配置方面丰富性" class="headerlink" title="配置方面丰富性"></a>配置方面丰富性</h3><ul><li><p>目前<code>spring-cloud-loadbalancer</code> 仅支持 重试操作的配置</p></li><li><p>ribbon 支持超时、懒加载处理、重试及其和 hystrix整合高级属性等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> loadbalancer </tag>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack的架构设计</title>
      <link href="2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/u/4376602">osc_s8zboupn</a></p><p>出处：<a href="https://my.oschina.net/u/4376602/blog/3542502">openstack：OpenStack架构详解</a></p><p>OpenStack既是一个社区，也是一个项目和一个开源软件，提供开放源码软件，建立公共和私有云，它提供了一个部署云的操作平台或工具集，其宗旨在于：帮助组织运行为虚拟计算或存储服务的云，为公有云、私有云，也为大云、小云提供可扩展的、灵活的云计算。<br>OpenStackd开源项目由社区维护，包括OpenStack计算（代号为Nova），OpenStack对象存储（代号为Swift），并OpenStack镜像服务（代号Glance）的集合。 OpenStack提供了一个操作平台，或工具包，用于编排云。</p><p>下面列出Openstack的详细构架图</p><p><img src="/2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803154744809-483681990.png" alt="img"></p><p>Openstack的网络拓扑结构图</p><p><img src="/2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803154957606-291369411.png" alt="img"></p><p>整个OpenStack是由控制节点，计算节点，网络节点，存储节点四大部分组成。（这四个节点也可以安装在一台机器上，单机部署）<br>其中：<br>控制节点负责对其余节点的控制，包含虚拟机建立，迁移，网络分配，存储分配等等<br>计算节点负责虚拟机运行<br>网络节点负责对外网络与内网络之间的通信<br>存储节点负责对虚拟机的额外存储管理等等</p><p>控制节点架构：</p><p>控制节点包括以下服务</p><p>  管理支持服务</p><p>  基础管理服务</p><p>  扩展管理服务</p><p>  1）管理支持服务包含MySQL与Qpid两个服务</p><p>MySQL：数据库作为基础/扩展服务产生的数据存放的地方</p><p>Qpid：消息代理(也称消息中间件)为其他各种服务之间提供了统一的消息通信服务</p><p>  2）基础管理服务包含Keystone，Glance，Nova，Neutron，Horizon五个服务</p><p>Keystone：认证管理服务，提供了其余所有组件的认证信息/令牌的管理，创建，修改等等，使用MySQL作为统一的数据库</p><p>Glance：镜像管理服务，提供了对虚拟机部署的时候所能提供的镜像的管理，包含镜像的导入，格式，以及制作相应的模板</p><p>Nova：计算管理服务，提供了对计算节点的Nova的管理，使用Nova-API进行通信</p><p>Neutron：网络管理服务，提供了对网络节点的网络拓扑管理，同时提供Neutron在Horizon的管理面板</p><p>Horizon：控制台服务，提供了以Web的形式对所有节点的所有服务的管理，通常把该服务称为DashBoard</p><p>  3）扩展管理服务包含Cinder，Swift，Trove，Heat，Centimeter五个服务</p><p>Cinder：提供管理存储节点的Cinder相关，同时提供Cinder在Horizon中的管理面板</p><p>Swift：提供管理存储节点的Swift相关，同时提供Swift在Horizon中的管理面板</p><p>Trove：提供管理数据库节点的Trove相关，同时提供Trove在Horizon中的管理面板</p><p>Heat：提供了基于模板来实现云环境中资源的初始化，依赖关系处理，部署等基本操作，也可以解决自动收缩,负载均衡等高级特性。</p><p>Centimeter：提供对物理资源以及虚拟资源的监控，并记录这些数据，对该数据进行分析，在一定条件下触发相应动作</p><p>控制节点一般来说只需要一个网络端口用于通信/管理各个节点</p><p>网络节点架构</p><p>网络节点仅包含Neutron服务</p><p>Neutron：负责管理私有网段与公有网段的通信，以及管理虚拟机网络之间的通信/拓扑，管理虚拟机之上的防火等等</p><p>网络节点包含三个网络端口</p><p>eth0：用于与控制节点进行通信</p><p>eth1：用于与除了控制节点之外的计算/存储节点之间的通信</p><p>eth2：用于外部的虚拟机与相应网络之间的通信</p><p>计算节点架构</p><p>计算节点包含Nova，Neutron，Telemeter三个服务</p><p> 1）基础服务</p><p>Nova：提供虚拟机的创建，运行，迁移，快照等各种围绕虚拟机的服务，并提供API与控制节点对接，由控制节点下发任务</p><p>Neutron：提供计算节点与网络节点之间的通信服务</p><p> 2）扩展服务</p><p>Telmeter：提供计算节点的监控代理，将虚拟机的情况反馈给控制节点，是Centimeter的代理服务</p><p>计算节点包含最少两个网络端口</p><p>eth0：与控制节点进行通信，受控制节点统一调配</p><p>eth1：与网络节点，存储节点进行通信</p><p>存储节点架构</p><p>存储节点包含Cinder，Swift等服务</p><p>Cinder：块存储服务，提供相应的块存储，简单来说，就是虚拟出一块磁盘，可以挂载到相应的虚拟机之上，不受文件系统等因素影响，对虚拟机来说，这个操作就像是新加了一块硬盘，可以完成对磁盘的任何操作，包括挂载，卸载，格式化，转换文件系统等等操作，大多应用于虚拟机空间不足的情况下的空间扩容等等</p><p>Swift：对象存储服务，提供相应的对象存储，简单来说，就是虚拟出一块磁盘空间，可以在这个空间当中存放文件，也仅仅只能存放文件，不能进行格式化，转换文件系统，大多应用于云磁盘/文件</p><p>存储节点包含最少两个网络接口</p><p>eth0：与控制节点进行通信，接受控制节点任务，受控制节点统一调配</p><p>eth1：与计算/网络节点进行通信，完成控制节点下发的各类任务</p><p>-—————————————————————————————————————————————————————————————</p><p>下面说一说Openstack的各个组件作用及关系</p><p>Openstack发展至今，总共集成了下面几个组件：</p><p>Nova - 计算服务<br>Neutron-网络服务<br>Swift - 对象存储服务<br>Cinder-块存储服务<br>Glance - 镜像服务<br>Keystone - 认证服务<br>Horizon - UI服务<br>Ceilometer-监控服务<br>Heat-集群服务<br>Trove-数据库服务</p><p>组件间的关系图如下：</p><p><img src="/2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803161818153-400482667.png" alt="img"></p><p>重要组件介绍</p><p>OpenStack认证服务（Keystone）<br>Keystone为所有的OpenStack组件提供认证和访问策略服务，它依赖自身REST（基于Identity API）系统进行工作，主要对（但不限于）Swift、Glance、Nova等进行认证与授权。事实上，授权通过对动作消息来源者请求的合法性进行鉴定。下图显示了身份认证服务流程：</p><p><img src="/2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/0b988d224229300230a345f657c1c909103.png" alt="img"></p><p>Keystone采用两种授权方式，一种基于用户名/密码，另一种基于令牌（Token）。</p><p>除此之外，Keystone提供以下三种服务：<br>  令牌服务：含有授权用户的授权信息<br>  目录服务：含有用户合法操作的可用服务列表<br>  策略服务：利用Keystone具体指定用户或群组某些访问权限</p><p>keystone认证服务注意点：</p><p>服务入口：如Nova、Swift和Glance一样每个OpenStack服务都拥有一个指定的端口和专属的URL，我们称其为入口（endpoints）。</p><p>区位：在某个数据中心，一个区位具体指定了一处物理位置。在典型的云架构中，如果不是所有的服务都访问分布式数据中心或服务器的话，则也称其为区位。</p><p>用户：Keystone授权使用者<br>　　PS：代表一个个体，OpenStack以用户的形式来授权服务给它们。用户拥有证书（credentials），且可能分配给一个或多个租户。经过验证后，会为每个单独的租户提供一个特定的令牌。</p><p>服务：总体而言，任何通过Keystone进行连接或管理的组件都被称为服务。举个例子，我们可以称Glance为Keystone的服务。</p><p>角色：为了维护安全限定，就云内特定用户可执行的操作而言，该用户关联的角色是非常重要的。<br>　　PS：一个角色是应用于某个租户的使用权限集合，以允许某个指定用户访问或使用特定操作。角色是使用权限的逻辑分组，它使得通用的权限可以简单地分组并绑定到与某个指定租户相关的用户。</p><p>租间：租间指的是具有全部服务入口并配有特定成员角色的一个项目。<br>　　PS：一个租间映射到一个Nova的“project-id”，在对象存储中，一个租间可以有多个容器。根据不同的安装方式，一个租间可以代表一个客户、帐号、组织或项目。</p><p>OpenStack计算设施—-Nova</p><p>Nova是OpenStack计算的弹性控制器。OpenStack云实例生命期所需的各种动作都将由Nova进行处理和支撑，这就意味着Nova以管理平台的身份登场，负责管理整个云的计算资源、网络、授权及测度。虽然Nova本身并不提供任何虚拟能力，但是它将使用libvirt API与虚拟机的宿主机进行交互。Nova通过Web服务API来对外提供处理接口，而且这些接口与Amazon的Web服务接口是兼容的。</p><p>功能及特点：　<br>实例生命周期管理<br>计算资源管理<br>网络与授权管理<br>基于REST的API<br>异步连续通信<br>支持各种宿主：Xen、XenServer/XCP、KVM、UML、VMware vSphere及Hyper-V</p><p>Nova弹性云（OpenStack计算部件）包含以下主要部分：<br>API Server（nova-api）<br>消息队列（rabbit-mq server）<br>运算工作站（nova-compute）<br>网络控制器（nova-network）<br>卷管理（nova-volume）<br>调度器（nova-scheduler）</p><p>解释如下：<br>1）API服务器（nova-api）<br>API服务器提供了云设施与外界交互的接口，它是外界用户对云实施管理的唯一通道。通过使用web服务来调用各种EC2的API，接着API服务器便通过消息队列把请求送达至云内目标设施进行处理。作为对EC2-api的替代，用户也可以使用OpenStack的原生API，我们把它叫做“OpenStack API”。</p><p>2）消息队列（Rabbit MQ Server）<br>OpenStack内部在遵循AMQP（高级消息队列协议）的基础上采用消息队列进行通信。Nova对请求应答进行异步调用，当请求接收后便则立即触发一个回调。由于使用了异步通信，不会有用户的动作被长置于等待状态。例如，启动一个实例或上传一份镜像的过程较为耗时，API调用就将等待返回结果而不影响其它操作，在此异步通信起到了很大作用，使整个系统变得更加高效。</p><p>　3）调度器（nova-scheduler）　　</p><p>调度器负责把nova-API调用送达给目标。调度器以名为“nova-schedule”的守护进程方式运行，并根据调度算法从可用资源池中恰当地选择运算服务器。有很多因素都可以影响调度结果，比如负载、内存、子节点的远近、CPU架构等等。强大的是nova调度器采用的是可插入式架构。</p><p>目前nova调度器使用了几种基本的调度算法：<br>　　随机化：主机随机选择可用节点；<br>　　可用化：与随机相似，只是随机选择的范围被指定；<br>　　简单化：应用这种方式，主机选择负载最小者来运行实例。负载数据可以从别处获得，如负载均衡服务器。</p><p>4）运算工作站（nova-compute）<br>运算工作站的主要任务是管理实例的整个生命周期。他们通过消息队列接收请求并执行，从而对实例进行各种操作。在典型实际生产环境下，会架设许多运算工作站，根据调度算法，一个实例可以在可用的任意一台运算工作站上部署。</p><p>　5）网络控制器（nova-network）<br>网络控制器处理主机的网络配置，例如IP地址分配，配置项目VLAN，设定安全群组以及为计算节点配置网络。</p><p>　6）卷工作站（nova-volume）　<br>卷工作站管理基于LVM的 实例卷，它能够为一个实例创建、删除、附加卷，也可以从一个实例中分离卷。卷管理为何如此重要？因为它提供了一种保持实例持续存储的手段，比如当结束一个 实例后，根分区如果是非持续化的，那么对其的任何改变都将丢失。可是，如果从一个实例中将卷分离出来，或者为这个实例附加上卷的话，即使实例被关闭，数据 仍然保存其中。这些数据可以通过将卷附加到原实例或其他实例的方式而重新访问。</p><p>因此，为了日后访问，重要数据务必要写入卷中。这种应用对于数据服务器实例的存储而言，尤为重要。</p><p>OpenStack镜像服务器—-Glance</p><p>OpenStack镜像服务器是一套虚拟机镜像发现、注册、检索系统，我们可以将镜像存储到以下任意一种存储中：<br>本地文件系统（默认）<br>S3直接存储<br>S3对象存储（作为S3访问的中间渠道）<br>OpenStack对象存储等等。<br>　　<br>功能及特点：<br>提供镜像相关服务。</p><p>Glance构件：<br>1）Glance-API：<br>　 主要负责接收响应镜像管理命令的Restful请求，分析消息请求信息并分发其所带的命令（如新增，删除，更新等）。默认绑定端口是9292。<br>2）Glance-Registry：<br>　　主要负责接收响应镜像元数据命令的Restful请求。分析消息请求信息并分发其所带的命令（如获取元数据，更新元数据等）。默认绑定的端口是9191。</p><p>OpenStack存储设施—-Swift</p><p>Swift为OpenStack提供一种分布式、持续虚拟对象存储，它类似于Amazon Web Service的S3简单存储服务。Swift具有跨节点百级对象的存储能力。Swift内建冗余和失效备援管理，也能够处理归档和媒体流，特别是对大数据（千兆字节）和大容量（多对象数量）的测度非常高效。</p><p>swift功能及特点：　　<br>海量对象存储<br>大文件（对象）存储<br>数据冗余管理<br>归档能力—–处理大数据集<br>为虚拟机和云应用提供数据容器<br>处理流媒体<br>对象安全存储<br>备份与归档<br>良好的可伸缩性</p><p>Swift组件<br>Swift账户<br>Swift容器<br>Swift对象<br>Swift代理<br>Swift RING<br>　　<br>Swift代理服务器　　<br>用户都是通过Swift-API与代理服务器进行交互，代理服务器正是接收外界请求的门卫，它检测合法的实体位置并路由它们的请求。<br>此外，代理服务器也同时处理实体失效而转移时，故障切换的实体重复路由请求。</p><p>Swift对象服务器<br>对象服务器是一种二进制存储，它负责处理本地存储中的对象数据的存储、检索和删除。对象都是文件系统中存放的典型的二进制文件，具有扩展文件属性的元数据（xattr）。</p><p>注意：xattr格式被Linux中的ext3/4，XFS，Btrfs，JFS和ReiserFS所支持，但是并没有有效测试证明在XFS，JFS，ReiserFS，Reiser4和ZFS下也同样能运行良好。不过，XFS被认为是当前最好的选择。</p><p>Swift容器服务器<br>容器服务器将列出一个容器中的所有对象，默认对象列表将存储为SQLite文件（译者注：也可以修改为MySQL，安装中就是以MySQL为例）。容器服务器也会统计容器中包含的对象数量及容器的存储空间耗费。</p><p>Swift账户服务器<br>账户服务器与容器服务器类似，将列出容器中的对象。</p><p>Ring（索引环）</p><p>Ring容器记录着Swift中物理存储对象的位置信息，它是真实物理存储位置的实体名的虚拟映射，类似于查找及定位不同集群的实体真实物理位置的索引服务。这里所谓的实体指账户、容器、对象，它们都拥有属于自己的不同的Rings。</p><p>OpenStack管理的Web接口—-Horizon</p><p>Horizon是一个用以管理、控制OpenStack服务的Web控制面板，它可以管理实例、镜像、创建密匙对，对实例添加卷、操作Swift容器等。除此之外，用户还可以在控制面板中使用终端（console）或VNC直接访问实例。</p><p>总之，Horizon具有如下一些特点：　　<br>实例管理：创建、终止实例，查看终端日志，VNC连接，添加卷等<br>访问与安全管理：创建安全群组，管理密匙对，设置浮动IP等<br>偏好设定：对虚拟硬件模板可以进行不同偏好设定<br>镜像管理：编辑或删除镜像<br>查看服务目录<br>管理用户、配额及项目用途<br>用户管理：创建用户等<br>卷管理：创建卷和快照<br>对象存储处理：创建、删除容器和对象<br>为项目下载环境变量</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudFoundry的架构设计</title>
      <link href="2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/javayou">红薯</a></p><p>出处：<a href="https://www.oschina.net/question/12_32393">深度剖析CloudFoundry的架构设计</a></p><p>VMware发布了业内第一个开源的PaaS——CloudFoundry。Ruby开发的一款开源PaaS云计算平台。</p><p>本文会分为两个部份：第一部份主要介绍CloudFoundry的架构设计，从它所包含的模块介绍起，到各部份的消息流向，各模块如何协调合作；第 二部份会在第一部份的基础上，以如何在你的数据中心里面用CloudFoundry部署一个私有PaaS为目标，把第一部分介绍到的架构知识使用起来。</p><p>第一部份讲的很多内容，会引用Pat在10月12日的VMwareCloud Forum上面关于CloudFoundry架构的演讲。Pat是CloudFoundry Core的负责人，他的那次演讲很值得一听。如果你当时在场，并且理解他所说的内容，本部份可以选择直接跳过。我除了会把说的内容讲具体点外，不太可能可 以讲得比他好。</p><p><strong>一、架构及模块</strong></p><p>从总体地看，CloudFoundry的架构如下：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_dsI0.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>这个架构图以及下文所用到的各模块架构图均来自Pat的PPT。从上图能够看到CloudFoundry主要有以下几大组件组成：</p><p>1、 Router：顾名思义，Router组件在CloudFoundry中是对所有进来的Request进行路由。进入Router的request主要有两类：首先是来自VMCClient或者STS的，由CloudFoundry使用者发出的，管理型指令。</p><p>例如：列出你所有apps的vmcapps，提交一个apps等等。这类request会被路由到AppLife Management组件，又叫CloudController组件去；第二类是外界对你所部署的apps访问的request。这部份requests 会被路由到Appexecution，又或者叫做DEAs的组件去。所有进入CloudFoundry系统的requests都会经过Router组件， 看到这里可能会有朋友会担心Router成为单点，从而成为整个云的瓶颈。</p><p>但是CloudFoundry作为云系统，其设计的核心就是去单点依赖，组件平行扩充，且可替代的以保证扩展性，这是CloudFoundry，甚 至所有云计算系统的设计原则，后文会讨论CloudFoundry如何做到这点，目前只要知道，系统可以部署多个Routers共同处理进来的 requests，但是Router上层的LoadBalance不在CloudFoundry的实现范围，CloudFoundry只保证所有的 request是无状态的，这样就使上层均衡附载选择面非常非常大了，例如可以通过DNS做，也可以部署硬件的LoadBalancer，或者简单点，弄 台ngnix作负载均衡器，都是可行的。</p><p>Router组件，目前版本是对nginx的一个简单封装。熟悉ngnix的朋友应该知道，它可以一个套接字文件（.sock文件）作为输入输出。所有安装CloudFoundry的Router组件服务器都会安装一个nginx，其ngnix.conf文件有以下配置：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_k33L.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>从整体的来看，Router组件的结构如下：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_WBeV.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>外界httprequest进入CloudFoundry服务器，nginx会首先接到request，nginx通过sock与 router.rb进行交互，于是真正处理请求的是Router组件。router.rb里面根据传入的url，用户名密码等，进行逻辑判断，到 CloudController组件或者DEA组件取数据并且返通过与niginx连接的.sock文件返回。</p><p>router.rb是对nginx进行了逻辑封装。熟悉CloudFoundry的朋友肯定知道，CloudFoundry给每一个app分配了一 个url访问，如果直接使用VMware所托管的CloudFoundry.com的话，那你的app的url可能就是 xxx.cloudfoundry.com，无论通过命令给你的app扩展了多少个instances，都是从这个url访问的，这里面的url转换路由 就是由router.rb实现的。</p><p>2、DEA(Droplet Execution Agency): 首先要解析下什么叫做Droplet。Droplet在CloudFoundry的概念里面是指一个把你提交的源代码，以及CloudFoundry配套 好的运行环境，再加上一些管理脚本，例如Start/Stop这些小脚本全部压缩好在一起的tar包。还有一个概念，叫做Stagingapp，就是指制 作上面描述这个包，然后把它存储好的过程。CloudFoundry会自动保存这个Droplet，直到你start一个app的时候，一台部署了DEA 模块的服务器会来拿一个Droplet的copy去运行。所以如果你扩展你的app到10个instances，那这个Droplet就被会复制十份，让 10个DEA服务器拿去运行。</p><p>下图是DEA模块的架构图：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_GFkn.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>Cloud Controller模块（下面会介绍）会发送start/stop等基本的apps管理请求给DEA，dea.rb接收这些请求，然后从NFS里面找到 合适的Droplet。前面说到Droplet其实是一个带有运行脚本的，带运行环境的tar包，DEA只需要把它拿过来解压，并即行里面的start脚 本，就可以让这个app跑起来。到此，app算是可以访问，并start起来了，换句话说就是有这台服务器的某一个端口已经在待命，只要有request 从这个端口进来，这个app就可以接收并返回正确的信息。</p><p>接着dea.rb要做些善后的工作：1、把这个信息告诉Router模块。我们前面说到，所有进入CloudFoundry的requests都是 由Router模块处理并转发的，包括用户对app的访问request，一个app起来后，需要告诉router，让它根据loadbalance等原 则，把合适的request转进来，使这个app的instance能够干起活；2、一些统计性的工作，例如要把这个用户又新部署了一个app告诉 CloudController，以作quota控制等；3、把运行信息告诉HealthManager模块，实时报告该app的instance运行情 况。另外DEA还要负责部份对Droplet的查询工作，譬如，如果用户通过CloudController想查询一个app的log信息，那DEA需要 从该Droplet里面取到log返回等等。</p><p>3、CloudController：CloudController是CloudFoundry的管理模块。主要工作包括：</p><p>a) 对apps的增删改读；</p><p>b) 启动、停止应用程序；</p><p>c) Staging apps（把apps打包成一个droplet）；</p><p>d) 修改应用程序运行环境，包括instance、mem等等；</p><p>e) 管理service，包括service与app的绑定等；</p><p>f) Cloud环境的管理；</p><p>g) 修改Cloud的用户信息；</p><p>h) 查看Cloud Foundry，以及每一个app的log信息。</p><p>这似乎有点复杂，但简单的说，可以很简单：就是与VMC和STS交互的服务器端。VMC和STS与CloudFoundry通信采用的是 restful接口，另一方面CloudController是一个典型的Rubyon Rails项目，从VMC或者STS接到JSON格式的协议，然后写入CloudController Database，并发消息到各模快去控制管理整个云。和其他ROR项目一样，CloudController的所有API可以从 conf/routes.rb里看到。开放的Restful接口好处在于第三方应用开发和集成，企业在用CloudFoundry部署私有云的时候，可以 通过这些接口来自动化控制管理整个Cloud环境。这部份内容将在第二部份论述。</p><p>下图是Cloud Controller的架构图：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_4FyB.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>图中Health Manager和DEA是外部模块，CCDatabase就是CloudController Database，这个是整个CloudFoundry不能做HP的地方。CloudController Database的并发性不会很多，应用级别的数据库访问是由底下的Service模块处理的，这个数据库存的是Cloud的配置信息。读操作主要来自 DEA启动，作为初始化DEA的依据；以及healthmanager模块会从这里读取预期的状态信息，这部份数据会与从DEA得到的实际状态信息进行比 对。</p><p>NFS是多个CloudController的共享存储，CloudController其中一个重要工作就是StagingApps。 Droplets的存储是在集群环境的唯一的。而CloudController是集群运行，换言之，就是每一个控制Request可能由不同的 CloudController处理，假设一个简单的用户场景：我们需要部署一个app到CloudFoundry中。我们在敲完那条简单的push命令 后，VMC开始工作，在做完一轮的用户鉴权、查看所部署的apps数量是否超过预定数额，问了一堆相关app的问题后，需要发4个指令：</p><p>1．发一个POST到”apps”，创建一个app;</p><p>2．发一个PUT到”apps/:name/application”，上传app;</p><p>3．发一个GET到”apps/:name/”，取得app状态，看看是否已经启动；</p><p>4．如果没有启动，发一个PUT到”apps/:name/”，使其启动。</p><p>如果第2和第4步由不同的Cloud Controller来处理，而又无法保证他们能找到同一个Droplet，那第4步将会因为找不到对应的Droplet而启动失败。如何保证这一连串指 令过来所指向的Droplet都是同一个呢？使用NFS，使CloudController共享存储是最简单的方法。但是这个方法在安全性等方面并不完 美。在10月12日的VMwareCloud Forum上，Pat告诉我们下一版本的CloudFoundry这里将会有大调整，但是在那部份代码公开前，我不方便在这评价太多。</p><p>4、HealthManager: 做的事情不复杂，简单的说是从各个DEA里面拿到运行信息，然后进行统计分析，报告等。统计数据会与CloudController的设定指标进行比对， 并提供Alert等。HealthManager模块目前还不是十分完善，但是CloudManage栈里面，自动化health管理、分析是一个很重要 的领域，而这方面可以扩展的地方也很多，结合OrchestrationEngine可以使云自管理、自预警；而与BI方面技术结合，可以统计运营情况， 合理分配资源等。这方面CloudFoundry还在发展之中。</p><p>5、Services:Cloud Foundry的Service模块从源代码控制上看就知道是一个独立的、可Plugin的模块，以方便第三方把自己的服务整合入 CloudFoundry生态系统。在Github上看到service是与CloudFoundry Core项目vcap独立的一个repository，为vcap-service。Service模块其中设计原则是方便第三方服务提供商提供服务。在 这方面CloudFoundry做得很成功，从Github上看，已经有以下服务提供：a)MongoDB; b) mysql; c) neo4j; d) PostgreSql; e) RabbitMQ; f) Redis; g)vBlob。基类都是放在base文件夹中。</p><p>第三方如果需要自己开发CloudFoundry的服务，需要继承改写它里面的两个基础类：Node和Gateway；而里面一些操作， 如：Provision，可以在base的provisioner.rb基础上加入自己的逻辑，同样的还有Service_Error和 Service_Message等。关于如何写自己的Service，ELC的博客会推出相应文章详细论述，并不在本文的讨论范围里面，从架构了解上来 说，只要知道服务间的关系，知道个服务与base间透过继承关系来横向扩充，而CloudFoundry与apps调用Service是通过base来完 成这一简单的架构方法即可。</p><p>6、NATS(Message bus): 从CloudFoundry的总架构图看，位于各模块中心位置的是一个叫nats的组件。NATS是由CloudFoundry的架构师Derek开发的一个轻量级的，支持发布、订阅机制的消息系统。Github开源地址是：<a href="https://github.com/derekcollison/nats%E3%80%82%E5%85%B6%E6%A0%B8%E5%BF%83%E5%9F%BA%E4%BA%8EEventMachine%E5%BC%80%E5%8F%91%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%87%8F%E4%B8%8D%E5%A4%9A%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E6%85%A2%E6%85%A2%E7%A0%94%E7%A9%B6%E3%80%82">https://github.com/derekcollison/nats。其核心基于EventMachine开发，代码量不多，可以下载下来慢慢研究。</a></p><p>CloudFoundry是一个多模块的分布式系统，支持模块自发现，错误自检，且模块间低耦合。其核心原理就是基于消息发布订阅机制。每个台服务 器上的每个模块会根据自己的消息类别，向MessageBus发布多个消息主题；而同时也向自己需要交互的模块，按照需要的信息内容的消息主题订阅消息。 譬如：一个DEA被加入CloudFoundry集群中，它需要向大家吼一下，以表明它已经准备好服务了，它会发布一个主题是”dea.start”的消 息：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_gxEP.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>@ hello_message_json中包括DEA的UUID,ip, port, 版本信息等内容。</p><p>再例如，CloudController需要启动一个Droplet的instance：</p><p>a)首先一个DEA在启动的时候，会首先会对自己UUID的消息主题进行订阅。</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_xEQk.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>其他模块需要通过’’dea.#{uuid}.start”这个主题发送消息来使它启动，一旦这个DEA接收到消息，就会触发process_dea_start(msg)这个方法来处理启动所需要的工作。</p><p>b)Cloud Controller或者其他模块发送消息，让UUID为xxx的DEA启动。</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_FF7U.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>c)DEA模块接收到消息后，就会触发process_dea_start(msg)方法。msg是由其他模块发送过来的消息内容，包 括：droplet_id,instance_index, service, runtime等内容，process_dea_start会取得这些启动DEA必须的信息，然后进行一系列操作，例如从NFS中取得Droplet，解 压，修改必要环境配置，运行启动脚本等等。等一切都准备好后，然后需要给Router发个消息，告诉它这个Droplet已经随时准备好报效国家，以后有 相应的request记得让它来处理。</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_nMFD.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>d)Router模块在启动时就已经订阅”router.register”消息主题。</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_ehTo.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>收到前面DEA发出的信息后，会触发register_droplet方法，去绑定Droplet。到此启动一个Droplet的instance工作完成。</p><p>我们可以看到整个CloudFoundry的核心就是一套消息系统，如果想了解CloudFoundry的来龙去脉，去跟踪它里面复杂的消息机制是 非常好的方法。另一方面，CloudFoundry是一套基于消息的分布式系统，面向消息的架构是它节点横向扩展，组件自发现等云特性的基础。</p><p>Cloud Foundry的架构简单介绍至此，其实作为第一款开源的PaaS，CloudFoundry架构有很多可以学习借鉴的地方，很多细节上的处理是很精妙 的，这些内容如果有可能会在后续文章继续探讨，本文题虽为深入CloudFoundry，其实也只是浅尝即止，把总体架构介绍一下，目标在于使我们有足够 的背景知识去用CloudFoundry搭建企业内部的私有PaaS。总结一下，笔者从CloudFoundry的结构中学到的东西：</p><p>1、基于消息的多组件架构是实现集群的简单、且有效方法。消息可以使集群节点间解耦，使自注册，自发现这些在大规模数据中心中很重要的功能得到实现；</p><p>2、适当的抽象层，模板模式的使用，方便第三方可以方便在CloudFoundry开发扩展功能。CloudFoundry在DEA及 Service层都做了抽象层处理，相对应地使开发者可以容易地为CloudFoundry开发Runtime和Service。例如，在 CloudFoundry刚推出的时候，只支持Node.js,Java, Ruby，但第三方提供商、开源社区快速跟进，为CloudFoundry添加了PHP,Python的支持。这得益于CloudFoundry精巧的 DEA架构设计，如何开发新的Runtime支持，会在后续博文中有所论述.</p><p><strong>二、源码导读</strong></p><p>笔者一直觉得深入理解一个技术的最好方法就是读它的源码，而CloudFoundry是完全开源的PaaS平台，而因为刚发展起来，代码量不多，主 要作者们的代码功力也相当不错，读起来很舒服，很适合研读。而不得不再次表扬一下它完全基于消息机制的架构设计，对组件扩展性，第三方接入等方面做得很 好，读者可以从中学到不少思想性的东西。笔者很推荐大家去读一下它的源代码。你可以在Github上找到CloudFoundry的全部代码：<a href="https://github.com/cloudfoundry%EF%BC%8C%E4%BD%A0%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%87%A0%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84Repositories%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9A">https://github.com/cloudfoundry，你会看到几个不同的Repositories，它们分别是：</a></p><p>1、vcap: Cloud Foundry的Core，又或者称作Kernel；</p><p>2、vcap-service: Cloud Foundry的Service组件。Cloud Foundry的service是作为插件提供的，这出于它方便第三方开发service而设计的；</p><p>3、vmc: VMware Cloud CLI. 是一个Ruby应用，与Cloud Foundry的CLI交互。主要通过分析用户输入的CLI，向CloudFoundry发送Restful请求；</p><p>4、vcap-java: 如果你的app是用java开发，且需要与Cloud Foundry交互，例如取得当前serviceserver的ip地址等，你可能需要这个jar，里面对我们Java开发常用框架有所支持，它底层也是 对CloudFoundry的Restful请求的包装；</p><p>5、vcap-java-client: Cloud Foundry的Restful API的Java封装，与上面的项目不一样，它只是个简单的读取CloudFoundry信息，并放如JavaBean中；</p><p>6、vcap-test: Cloud Foundry的test cases;</p><p>7、vcap-test-assets: Cloud Foundry一些apps示例。</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudFoundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack和CloudFoundry</title>
      <link href="2020/12/10/OpenStack%E5%92%8CCloudFoundry/"/>
      <url>2020/12/10/OpenStack%E5%92%8CCloudFoundry/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h2><p>OpenStack 是一个旨在为公共及私有云的建设与管理提供软件的开源项目。它的社区拥有超过130家企业及1350位开发者，这些机构与个人都将OpenStack作为基础设施即服务（简称IaaS）资源的通用前端。OpenStack项目的首要任务是简化云的部署过程并为其带来良好的可扩展性。OpenStack 源码在 Git@OSC 上的镜像：<a href="http://git.oschina.net/openstack">http://git.oschina.net/openstack</a></p><p>开源项目，搭建私有云，公有云，混合云。openStack是偏IaaS层的开源云计算框架</p><p><img src="/2020/12/10/OpenStack%E5%92%8CCloudFoundry/001610_vm0P_5189.jpg" alt="img"></p><h2 id="CloudFoundry"><a href="#CloudFoundry" class="headerlink" title="CloudFoundry"></a>CloudFoundry</h2><p>Cloud Foundry是一个独立于云的平台即服务解决方案，也是业界最成功的PaaS平台，是PaaS层的开源框架。。Cloud Foundry提供了一个可轻松运行、扩展和维护应用程序的环境和快速便捷的开发者体验。Cloud Foundry支持Java、NodeJS、Ruby、Python等大多数语言和环境。</p><p>开源的Cloud Foundry由Cloud Foundry基金会开发并支持，基金会包括Pivotal、IBM、VMware以及其它许多厂商。商业版本的Cloud Foundry，如IBM Bluemix和Pivotal Cloud Foundry，是基于开源的Cloud Foundry项目并在其基础上提供企业级的支持。</p><p>Cloud Foundry对容器采用了一个非常固执的方式。它使用了一个叫garden的容器解决方案。PCF的较早版本的原始容器称为warden，它事实上要早于Docker本身。</p><p>Cloud Foundry自身事实上也早于Kubernetes，它的第一个版本始于2011年，而Kubernetes直到2014年才出现。</p><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Kubernetes是一个来源于谷歌Borg项目的开源云平台。它由Cloud Native Computing Foundation发起，该基金会的成员包括了许多行业巨头，如AWS、Azure、Intel、IBM、RedHat、Pivotal等许多公司。</p><p>Cloud Foundry最重要的特点是，它是一个PaaS。Kubernetes则不太像PaaS，有些人把它看做IaaS+ ，甚至Kubernetes 的文档也把自己描述为“不是传统的、包罗万象的PaaS”。</p><p>Kubernetes首要的功能是一个容器编排和容器生命周期的管理。尽管不限于此，但它通常是被用来运行Docker容器，它的受众人群更广泛一些，比如想要构建在容器服务之上的应用和服务开发人员。有一些解决方案基于Kubernetes提供了PaaS体验，比如IBM的Container Service和RedHat的OpenShift等。</p><h2 id="Cloud-Foundry的优势在于"><a href="#Cloud-Foundry的优势在于" class="headerlink" title="Cloud Foundry的优势在于"></a>Cloud Foundry的优势在于</h2><ol><li>成熟的身份验证系统UAA，用户组和multi-tenancy的支持</li><li>方便快捷的cf push</li><li>自带负载均衡Router</li><li>强大的日志和metrics整合</li><li>成熟的部署工具BOSH</li></ol><h2 id="Kubernetes的优势在于"><a href="#Kubernetes的优势在于" class="headerlink" title="Kubernetes的优势在于"></a>Kubernetes的优势在于</h2><ol><li>大量社区和第三方支持，提供强大的扩展性</li><li>完善的容器生命周期和自动伸缩管理</li><li>方便快捷的容器化应用部署</li><li>良好、多样的持久层支持</li><li>多种开源UI支持</li></ol><h2 id="Cloud-Foundry和Kubernetes相似点"><a href="#Cloud-Foundry和Kubernetes相似点" class="headerlink" title="Cloud Foundry和Kubernetes相似点"></a>Cloud Foundry和Kubernetes相似点</h2><p>两者都使用容器的思想来隔离应用和系统其它组件。<br>两者都可以既运行在公有云（AWS、Azure、GCP）上，也可以运行在预置型云平台，如使用Vmware vsphere的云平台上。<br>两者都提供了混合环境上的运行能力，允许你在不同的云平台运行应用以提高可用性，甚至支持应用在公有云和私有云上同时运行。<br>Pivotal Cloud Foundry的最新版本也开始支持Kubernetes作为通用的容器运行时。</p><h2 id="CloudFoundry和Kubernetes使用"><a href="#CloudFoundry和Kubernetes使用" class="headerlink" title="CloudFoundry和Kubernetes使用"></a>CloudFoundry和Kubernetes使用</h2><p>使用Docker，你需要定义一个Dockerfile以支持运行基于Java的应用。你可以用各种不同方式来定义这个容器。你可以选择不同的基础操作系统，不同服务商提供的不同JDK版本，你可以暴露不同的端口，以支持不同安全级别上的访问。没有一个标准说基于Java的Spring Boot应用该长什么样。</p><p>在Cloud Foundry，所有基于Java的应用都有一个基线buildpack，这个buildpack是由供应商提供的。一个buildpack是针对给定语言创建应用运行时的模板。buildpack是由Cloud Foundry自身管理的。</p><p>Cloud Foundry把定义容器的部分工作从开发者手上接了过来。它定了一个标准，基于Java的容器应该长什么样，这样所有开发者，不管是DevOps团队还是IT专家，都可以同步这个模板。你可以确信你的容器将和其他开发者提供的容器一样运行，不管在现有的集群内，还是将来有可能转到的公有云平台上。</p><h2 id="OpenShift和CloudFoundry比较"><a href="#OpenShift和CloudFoundry比较" class="headerlink" title="OpenShift和CloudFoundry比较"></a>OpenShift和CloudFoundry比较</h2><p>具体未来谁流行现在很难说清楚，从现在热度来看红帽子在云方面的力量还是弱于Vmware的，CloudFoundry应该会更加流行。两者关键区别：<br>1.语言方面：基本相同，都支持java，Pythone,php,perl,ruby等。CF多支持Elang<br>2.关系数据库：都支持mysql和PostgreSql<br>3.NoSQL:都支持MongoDB，CF多支持Redis，Neo4j，分布式缓存memcacheD</p><h2 id="CloudFoundry和Kubernetes结合"><a href="#CloudFoundry和Kubernetes结合" class="headerlink" title="CloudFoundry和Kubernetes结合"></a>CloudFoundry和Kubernetes结合</h2><h4 id="Kubernetes-CPI"><a href="#Kubernetes-CPI" class="headerlink" title="Kubernetes CPI"></a>Kubernetes CPI</h4><p>我们知道BOSH是Cloud Foundry官方指定的部署工具，它是一个针对大规模分布式系统的部署和生命周期管理的开源工具。但是BOSH不仅仅局限于部署Cloud Foundry，也可以应用于别的分布式系统，只需要其提供符合要求的Release即可。CPI全称Cloud Provider Interface，是BOSH用来与IaaS通信完成虚拟机实例和模板的创建和管理的一个API接口，CPI目前能够支持Amazon的AWS、微软的Azure、IBM的SoftLayer等IaaS平台，国内阿里云也提供了CPI的支持。BOSH的主控制器Director通过CPI与底层的IaaS层交互，将BOSH manifest.yaml 文件定义任务及组件部署到IaaS层的VM上。</p><p>也就是开发一套Kubernetes的CPI，通过BOSH和manifest.yaml的配置将Cloud Foundry部署到Kubernetes上。现在有一些大的厂商如IBM、SAP在开发相应的Kubernetes CPI，大家可以在GitHub中搜索到。我个人觉得，这种方式虽然容易上手，但还是以IaaS的角度来看待Kubernetes，底层还是通过BOSH来管理的，没能最大地发挥Kubernetes平台的优势的。</p><h4 id="Cloud-Foundry-Container-Runtime（CFCR）"><a href="#Cloud-Foundry-Container-Runtime（CFCR）" class="headerlink" title="Cloud Foundry Container Runtime（CFCR）"></a>Cloud Foundry Container Runtime（CFCR）</h4><p>Cloud Foundry基金会在2017年底宣布把Pivotal和谷歌捐献的Kubo项目改名为CFCR（Cloud Foundry Container Runtime）。总体来说是利用BOSH来部署Cloud Foundry和Kubernetes，并通过Application Runtime管理Cloud Foundry的Application Service；通过Container Runtime管理Kubernetes的Container Service，比如一些无法部署在Cloud Foundry内的服务，如数据库、监控等。然后通过Open Service Broker将两者连接起来</p><h4 id="容器化Cloud-Foundry"><a href="#容器化Cloud-Foundry" class="headerlink" title="容器化Cloud Foundry"></a>容器化Cloud Foundry</h4><p>将Cloud Foundry所有组件容器化，并部署到Kubernetes上是一种比较新型的整合方式。现在有一些大的厂商做这方面的工作，比如SUSE、IBM和SAP。其核心就是通过将Cloud Foundry的BOSH Release转化成Docker镜像，然后通过Kubernetes的部署工具Helm来将Cloud Foundry更加自然地部署到Kubernetes上。只有在生成Cloud Foundry组件的Docker镜像是需要用到BOSH Cli去转化BOSH release，部署及部署之后的管理，都不需要BOSH，而是交给Kubernetes来对所有Cloud Foundry组件的Pod、服务及相应配置资源的生命周期进行管理。这样既享受到了Cloud Foundry带来的良好的开发者体验，又用到了Kubernetes强大的管理和扩展能力</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然两者结合的探索工作不止于此，现在越来越多的厂商和开发者加入到两者整合的研究中。其中比较火的有IBM主导的Cloud Foundry孵化项目Eirini，其想法是想将Cloud Foundry中的Diego-cell容器Garden替换成Kubernetes的容器，从而将两者更紧密地连接在一起。</p><p>Kubernetes之于Cloud Foundry的关系不是挑战也不是竞争关系，Cloud Foundry希望与其更好地融合，就像Cloud Foundry Foundation执行董事Abby Kearns说的：“Cloud Foundry是结构化的PaaS平台，其他平台是非结构化的，用户的需求是多元化的，并不是一定要如何容器化，而是希望平台能够更开放、支持更多的类型。”</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_30154571/article/details/84955097">Cloud Foundry和 Kubernetes 的区别</a></p><p><a href="http://dockone.io/article/8295">Cloud Foundry和Kubernetes结合的过去与未来</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
            <tag> CloudFoundry </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> OpenShift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之Spring重试机制</title>
      <link href="2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
      <url>2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/ybyn/">一步一年</a></p><p>出处：<a href="https://www.cnblogs.com/ybyn/p/13691058.html">https://www.cnblogs.com/ybyn/p/13691058.html</a></p><p>消费端在处理消息过程中可能会报错，此时该如何重新处理消息呢？解决方案有以下两种。</p><blockquote><ul><li>在redis或者数据库中记录重试次数，达到最大重试次数以后消息进入死信队列或者其他队列，再单独针对这些消息进行处理；</li><li>使用spring-rabbit中自带的retry功能；</li></ul></blockquote><p>第一种方案我们就不再详细说了，我们主要来看一下第二种方案，老规矩，先上代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span>  <span class="comment"># 自动ack</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">max-interval:</span> <span class="number">10000</span>   <span class="comment"># 重试最大间隔时间</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">2000</span>  <span class="comment"># 重试初始间隔时间</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">2</span> <span class="comment"># 间隔时间乘子，间隔时间*乘子=下一次的间隔时间，最大不能超过设置的最大间隔时间</span></span><br></pre></td></tr></table></figure><p>此时我们的消费者代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;platform.queue-name&#125;&quot;&#125;,concurrency = &quot;1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgConsumer</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;接收到消息&gt;&gt;&gt;&#123;&#125;&quot;</span>,msg);</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">log.info(<span class="string">&quot;消息&#123;&#125;消费成功&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动程序，发送消息后可以看到控制台输出内容如下：</p><p><img src="/2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142316393-1426680370.png" alt="img"></p><p>可以看到重试次数是5次（包含自身消费的一次），重试时间依次是2s，4s，8s，10s（上一次间隔时间*间隔时间乘子），最后一次重试时间理论上是16s，但是由于设置了最大间隔时间是10s，因此最后一次间隔时间只能是10s，和配置相符合。</p><blockquote><p>注意：</p><p>重试并不是RabbitMQ重新发送了消息，仅仅是消费者内部进行的重试，换句话说就是重试跟mq没有任何关系；</p><p>因此上述消费者代码不能添加try{}catch(){}，一旦捕获了异常，在自动ack模式下，就相当于消息正确处理了，消息直接被确认掉了，不会触发重试的；</p></blockquote><h2 id="MessageReCoverer"><a href="#MessageReCoverer" class="headerlink" title="MessageReCoverer"></a>MessageReCoverer</h2><p>上面的例子在测试中我们还发现了一个问题，就是经过5次重试以后，控制台输出了一个异常的堆栈日志，然后队列中的数据也被ack掉了（自动ack模式），首先我们看一下这个异常日志是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.amqp.rabbit.listener.exception.ListenerExecutionFailedException: Retry Policy Exhausted</span><br></pre></td></tr></table></figure><p>出现消息被消费掉并且出现上述异常的原因是因为在构建SimpleRabbitListenerContainerFactoryConfigurer类时使用了MessageRecoverer接口，这个接口有一个cover方法，用来实现重试完成之后对消息的处理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListenerRetry retryConfig = configuration.getRetry();</span><br><span class="line"><span class="keyword">if</span> (retryConfig.isEnabled()) &#123;</span><br><span class="line">RetryInterceptorBuilder&lt;?, ?&gt; builder = (retryConfig.isStateless()) ? RetryInterceptorBuilder.stateless()</span><br><span class="line">: RetryInterceptorBuilder.stateful();</span><br><span class="line">RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplateFactory(<span class="keyword">this</span>.retryTemplateCustomizers)</span><br><span class="line">.createRetryTemplate(retryConfig, RabbitRetryTemplateCustomizer.Target.LISTENER);</span><br><span class="line">builder.retryOperations(retryTemplate);</span><br><span class="line">MessageRecoverer recoverer = (<span class="keyword">this</span>.messageRecoverer != <span class="keyword">null</span>) ? <span class="keyword">this</span>.messageRecoverer</span><br><span class="line">: <span class="keyword">new</span> RejectAndDontRequeueRecoverer(); <span class="comment">//&lt;1&gt;</span></span><br><span class="line">builder.recoverer(recoverer);</span><br><span class="line">factory.setAdviceChain(builder.build());</span><br></pre></td></tr></table></figure><p>注意看&lt;1&gt;处的代码，默认使用的是RejectAndDontRequeueRecoverer实现类，根据实现类的名字我们就可以看出来该实现类的作用就是拒绝并且不会将消息重新发回队列，我们可以看一下这个实现类的具体内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectAndDontRequeueRecoverer</span> <span class="keyword">implements</span> <span class="title">MessageRecoverer</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Log logger = LogFactory.getLog(RejectAndDontRequeueRecoverer.class); <span class="comment">// NOSONAR protected</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(Message message, Throwable cause)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(<span class="string">&quot;Retries exhausted for message &quot;</span> + message, cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(<span class="string">&quot;Retry Policy Exhausted&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> AmqpRejectAndDontRequeueException(cause), message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源码给出了异常的来源，但是未看到拒绝消息的代码，猜测应该是使用aop的方式实现的，此处不再继续深究。</p><p>MessageRecoverer接口还有另外两个实现类，分别是<strong>RepublishMessageRecoverer</strong>和<strong>ImmediateRequeueMessageRecoverer</strong>，顾名思义就是重新发布消息和立即重新返回队列，下面我们分别测试一个这两个实现类：</p><h3 id="RepublishMessageRecoverer"><a href="#RepublishMessageRecoverer" class="headerlink" title="RepublishMessageRecoverer"></a>RepublishMessageRecoverer</h3><p>先创建一个异常交换机和异常队列，并将两者进行绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">errorExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;error-exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">errorQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;error-queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorExchange)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorExchange).with(<span class="string">&quot;error-routing-key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建RepublishMessageRecoverer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">messageRecoverer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RepublishMessageRecoverer(rabbitTemplate,<span class="string">&quot;error-exchange&quot;</span>,<span class="string">&quot;error-routing-key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动服务，查看处理结果：</p><p><a href="https://img2020.cnblogs.com/blog/2159277/202009/2159277-20200918142342030-85649685.png"><img src="https://img2020.cnblogs.com/blog/2159277/202009/2159277-20200918142342030-85649685.png" alt="img"></a></p><p>通过控制台可以看到，消息重试5次以后直接以新的routingKey发送到了配置的交换机中，此时再查看监控页面，可以看原始队列中已经没有消息了，但是配置的异常队列中存在一条消息。</p><p><img src="/2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142352326-326808881.png" alt="img"></p><p>再测试一下ImmediateRequeueMessageRecoverer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">messageRecoverer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ImmediateRequeueMessageRecoverer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142500644-1269082311.png" alt="img"></p><p>重试5次之后，返回队列，然后再重试5次，周而复始直到不抛出异常为止，这样还是会影响后续的消息消费。</p><blockquote><p>总结：</p><p>通过上面的测试，对于重试之后仍然异常的消息，可以采用RepublishMessageRecoverer，将消息发送到其他的队列中，再专门针对新的队列进行处理。</p></blockquote><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>除了可以采用上述RepublishMessageRecoverer，还可以采用死信队列的方式处理重试失败的消息。</p><p>首先创建死信交换机、死信队列以及两者的绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">dlxExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(dlxExchangeName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">dlxQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(dlxQueueName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列绑定死信交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dlxQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dlxExchange</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">dlcBinding</span><span class="params">(Queue dlxQueue, DirectExchange dlxExchange)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(dlxRoutingKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务队列的创建需要做一些修改，添加死信交换机以及死信路由键的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">Map&lt;String,Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,dlxExchangeName);<span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,dlxRoutingKey);<span class="comment">//声明当前队列的死信路由键</span></span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(queueName).withArguments(params).build();</span><br><span class="line">    <span class="comment">//return new Queue(queueName,true);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动服务，可以看到同时创建了业务队列以及死信队列</p><p><img src="/2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142520353-1806232438.png" alt="img"></p><p>在业务队列上出现了DLX以及DLK的标识，标识已经绑定了死信交换机以及死信路由键，此时调用生产者发送消息，消费者在重试5次后，由于MessageCover默认的实现类是RejectAndDontRequeueRecoverer，也就是requeue=false，又因为业务队列绑定了死信队列，因此消息会从业务队列中删除，同时发送到死信队列中。</p><blockquote><p>注意：</p><p>如果ack模式是手动ack，那么需要调用channe.nack方法，同时设置requeue=false才会将异常消息发送到死信队列中</p></blockquote><h2 id="retry使用场景"><a href="#retry使用场景" class="headerlink" title="retry使用场景"></a>retry使用场景</h2><p>上面说了什么是重试，以及如何解决重试造成的数据丢失，那么怎么来选择重试的使用场景呢？</p><p>是否是消费者只要发生异常就要去重试呢？其实不然，假设下面的两个场景：</p><ul><li>http下载视频或者图片或者调用第三方接口</li><li>空指针异常或者类型转换异常（其他的受检查的运行时异常）</li></ul><p>很显然，第一种情况有重试的意义，第二种没有。</p><p>对于第一种情况，由于网络波动等原因造成请求失败，重试是有意义的；</p><p>对于第二种情况，需要修改代码才能解决的问题，重试也没有意义，需要的是记录日志以及人工处理或者轮询任务的方式去处理。</p><h2 id="retry最佳实践"><a href="#retry最佳实践" class="headerlink" title="retry最佳实践"></a>retry最佳实践</h2><p>对于消费端异常的消息，如果在有限次重试过程中消费成功是最好的，如果有限次重试之后仍然失败的消息，不管是采用RejectAndDontRequeueRecoverer还是使用私信队列都是可以的，同时也可以采用折中的方法，先将消息从业务队列中ack掉，再将消息发送到另外的一个队列中，后续再单独处理异常数据的队列。</p><p>另外，看到有人说retry只能在自动ack模式下使用，经过测试在手动ack模式下retry也是生效的，只不过不能使用catch捕获异常，即使在自动ack模式下使用catch捕获异常也是会导致不触发重试的。当然，在手动ackm模式下要记得确认消息，不管是确认消费成功还是确认消费失败，不然消息会一直处于unack状态，直到消费者进程重启或者停止。</p><p>如果一定要在手动ack模式下使用retry功能，最好还是确认在有限次重试过程中可以重试成功，否则超过重试次数，又没办法执行nack，就会出现消息一直处于unack的问题，我想这也就是所说的retry只能在自动ack模式下使用的原因，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;platform.queue-name&#125;&quot;&#125;,concurrency = &quot;1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgConsumer</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;接收到消息&gt;&gt;&gt;&#123;&#125;&quot;</span>,msg);</span><br><span class="line"><span class="keyword">if</span>(msg.indexOf(<span class="string">&quot;0&quot;</span>)&gt;-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">&quot;消息&#123;&#125;消费成功&quot;</span>,msg);</span><br><span class="line">channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之死信队列</title>
      <link href="2020/12/09/RabbitMQ%E4%B9%8B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
      <url>2020/12/09/RabbitMQ%E4%B9%8B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="死信交换机，死信队列"><a href="#死信交换机，死信队列" class="headerlink" title="死信交换机，死信队列"></a>死信交换机，死信队列</h2><p>DLX 全称（Dead-Letter-Exchange）,称之为死信交换器，当消息变成一个<strong>死信</strong>之后，如果这个消息所在的队列存在<strong>x-dead-letter-exchange</strong>参数，那么它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，与这个死信交换器绑定的队列就是死信队列。</p><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p>在RabbitMQ中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。</p><h2 id="死信消息"><a href="#死信消息" class="headerlink" title="死信消息"></a><strong>死信消息</strong></h2><ol><li>消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false</li><li>消息过期了</li><li>队列达到最大的长度(x-max-length)</li></ol><h2 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h2><ol><li>创建队列的时候绑定死信参数：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx-exchange&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlK-routingKey&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(queue, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params); <span class="comment">//若不存在应该是会创建Queue</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>设置过期时间（TTL）</p><ul><li><p>设置队列中消息的过期时间（所有消息的过期时间都是一样）<strong>将消息的TTL值设置为0，意味着消息到达队列后将会立即过期不会被队列保存，除非消息能够被立即传递给消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(q_name, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map); <span class="comment">//原生jar</span></span><br></pre></td></tr></table></figure></li><li><p>设置单个消息的过期时间（可以设置每个消息的过期时间不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Spring</span></span><br><span class="line"><span class="keyword">this</span>.rabbitTemplate</span><br><span class="line">    .convertAndSend(orderStatusUpdateExchange, orderStatusUpdateKey, orderMessage, message -&gt; &#123;</span><br><span class="line">        message.getMessageProperties().setExpiration(expiration);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//原生jar</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                .expiration(<span class="string">&quot;6000&quot;</span>) <span class="comment">//设置TTL 毫秒</span></span><br><span class="line">                .build();</span><br><span class="line">channel.basicPublish(my-exchange, routing-key, properties, <span class="string">&quot;msg&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>设置队列过期（队列设置TTL过期后会被删除，但是不能保证实时被删除）该值决定了队列不再被使用后直到被自动删除的时长。<strong>不再使用的意思是队列没有订阅的消费者，队列最近没有被重新声明，并且在过期时间basic.get方法没有被调用</strong>。比如，在通过RabbitMQ实现RPC调用时，会生成大量的回复队列。<strong>服务器保证如果队列在最近的过期时间内没有被使用，那么该队列将会被删除。但是不保证在过期后能够以多快的速度删除</strong>。当服务器重启时，队列的租期重新开始计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;x-expires&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(q_name, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="死信注意点"><a href="#死信注意点" class="headerlink" title="死信注意点"></a>死信注意点</h2><blockquote><p>Caveats<br>Queues that had a per-message TTL applied to them retroactively (when they already had messages) will discard the messages when specific events occur. Only when expired messages reach the head of a queue will they actually be discarded (or dead-lettered). Consumers will not have expired messages delivered to them. Keep in mind that there can be a natural race condition between message expiration and consumer delivery, e.g. a message can expire after it was written to the socket but before it has reached a consumer.<br>When setting per-message TTL expired messages can queue up behind non-expired ones until the latter are consumed or expired. Hence resources used by such expired messages will not be freed, and they will be counted in queue statistics (e.g. the number of messages in the queue).<br>When retroactively applying a per-message TTL policy, it is recommended to have consumers online to make sure the messages are discarded quicker.<br>Given this behaviour of per-message TTL settings on existing queues, when the need to delete messages to free up resources arises, queue TTL should be used instead (or queue purging, or queue deletion).</p></blockquote><p><strong>注意事项</strong><br>当队列中已有消息，并设置消息的TTL，那么会追溯设置消息的有效期，当在特定情况下将会丢弃这些消息。**只有当过期消息到达队列的头部时，它们才会被真实地丢弃(或死信路由)**。消费者将不会接收到过期的消息，但是消息的传递和有效期有天然的竞争关系。比如，一个消息在被写入到socket但还未到达消费者时过期。</p><p>当设置了TTL过期时间的消息，可以在未过期消息后面排队，直到后者被消费或者过期。因此，被过期消息使用的资源并不会被释放，它们也会被队列的统计记入(比如，队列中消息的数量)。</p><p>当回溯地设置消息的TTL策略时，建议有消费者同时在线，可以保证消息的尽快丢弃。</p><p>考虑到给已存在的队列设置消息的TTL，来实现删除消息释放资源。设置队列的TTL（或队列清空，队列删除）应该替代这种方式</p><p><strong>测试</strong>：</p><ol><li>可以看出这次是正常发送，正常消费</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.036</span>， 消息内容：<span class="number">798</span></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.039</span>， 消息内容：<span class="number">456</span></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.039</span>， 消息内容：<span class="number">123</span></span><br><span class="line">2020-07-02 15:03:35.116  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br><span class="line">2020-07-02 15:03:39.054  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:03:44.055  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>可以看出消息正常发出，但是过了10s同时被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.654</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.654</span>， 消息内容：<span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.655</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.655</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.655</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.655</span>， 消息内容：<span class="number">798</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:05:55.665  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line">2020-07-02 15:05:55.666  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:05:55.666  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br></pre></td></tr></table></figure><ol start="3"><li>可以看出过了5秒第一次被消费，再过5秒后后两条消息同时被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.929</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.929</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.931</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.931</span>， 消息内容：<span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.931</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.931</span>， 消息内容：<span class="number">798</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:11:31.928  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:11:36.946  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line">2020-07-02 15:11:36.947  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br></pre></td></tr></table></figure><ol start="4"><li>可以看出过了5秒前两条消息同时被消费，再过了5秒最后一条消息被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.818</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.818</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.821</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.821</span>， 消息内容：<span class="number">798</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.821</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.821</span>， 消息内容：<span class="number">123</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:12:32.834  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:12:32.834  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br><span class="line">2020-07-02 15:12:37.837  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br></pre></td></tr></table></figure><p><font color="red">可以看出应该就是只有消息队列头的消息被消费后，过期的消息才会被消费。</font></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>安装一个插件即可：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedRabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delay.queue.demo.delay.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delay.queue.demo.delay.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.delay.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">immediateQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">customExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingNotify</span><span class="params">(<span class="meta">@Qualifier(&quot;immediateQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;customExchange&quot;)</span> CustomExchange customExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息生产者的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayMsg</span><span class="params">(String msg, Integer delayTime)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, a -&gt;&#123;</span><br><span class="line">        a.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,延时队列收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/m0_37801313/article/details/107084076">RabbitMq 死信消息的过期时间的不同 会导致消费延时</a></p><p><a href="https://www.cnblogs.com/mfrank/p/11260355.html">【RabbitMQ】一文带你搞定RabbitMQ延迟队列</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之消息可靠性处理</title>
      <link href="2020/12/09/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/"/>
      <url>2020/12/09/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么做到消息不丢失（可靠性）"><a href="#怎么做到消息不丢失（可靠性）" class="headerlink" title="怎么做到消息不丢失（可靠性）"></a>怎么做到消息不丢失（可靠性）</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a><strong>持久化</strong></h3><ul><li><p>exchange要持久化</p></li><li><p>queue要持久化</p></li><li><p>message要持久化</p><h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3></li><li><p>生产者发送消息开启确认confirm机制：如果消息没有到达交换机,则该方法中isSuccess = false,error为错误信息; 如果消息正确到达交换机,则该方法中isSuccess = true;</p></li><li><p>生产者发送消息开启返回returnedMessage机制：消息从交换机成功到达队列，则returnedMessage方法不会执行; 消息从交换机未能成功到达队列，则returnedMessage方法会执行;</p></li><li><p>生产者发送消息开启事务，同步操作，直到入队列之后才会结束，影响性能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.transaction.RabbitTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">// @Transactional //开启事务</span><br></pre></td></tr></table></figure></li><li><p>消费者开启手动确认模式：只有手动确认返回，才删除队列里的数据，需要注意幂等性。</p></li></ul><h2 id="实现消息的失败重试"><a href="#实现消息的失败重试" class="headerlink" title="实现消息的失败重试"></a>实现消息的失败重试</h2><h4 id="生产者发送失败重试"><a href="#生产者发送失败重试" class="headerlink" title="生产者发送失败重试"></a>生产者发送失败重试</h4><p><strong>开启确认机制</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#旧版本已过期可以设置为：publisher-confirm-type=correlated 确认消息已发送到交换机选择确认类型为交互</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>确认机制代码处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitTemplateConfig</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>,<span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);            <span class="comment">//指定 ConfirmCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);             <span class="comment">//指定 ReturnCallback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息是否发送到了交换机，ack为结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息唯一标识：&quot;</span>+correlationData);</span><br><span class="line">        System.out.println(<span class="string">&quot;确认结果：&quot;</span>+ack);</span><br><span class="line">        System.out.println(<span class="string">&quot;失败原因：&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息未从交换机到达队列执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体 message : &quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体 message : &quot;</span>+replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;描述：&quot;</span>+replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的交换器 exchange : &quot;</span>+exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的路由键 routing : &quot;</span>+routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心逻辑在二个回调方法中</strong></p><ul><li><strong>发送消息异常</strong>，即可能没有连接上RabbitMQ，此时可以通过定时任务Job去重试</li><li><strong>确认回调确定消息发送失败</strong>，可以记录发送结果在Redis中，直接再次重新发送消息入队列</li><li><strong>总结</strong>：可以先收到回调之后自动发送记录发送次数，超过如5次之后，使用定时任务阶梯时间发送消息入队列</li></ul><h4 id="消费者处理失败重试（可阶梯延时处理或重试）"><a href="#消费者处理失败重试（可阶梯延时处理或重试）" class="headerlink" title="消费者处理失败重试（可阶梯延时处理或重试）"></a>消费者处理失败重试（可阶梯延时处理或重试）</h4><h5 id="简单重试（手动确认）"><a href="#简单重试（手动确认）" class="headerlink" title="简单重试（手动确认）"></a>简单重试（手动确认）</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="comment">#NONE：自动确认 AUTO：根据情况确认 MANUAL：手动确认</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>AcknowledgeMode使用AUTO时，它会根据方法的执行情况来决定是否确认还是拒绝（是否重新入queue）</p><ul><li>如果消息成功被消费（成功的意思是在消费的过程中没有抛出异常），则自动确认</li><li>当抛出 AmqpRejectAndDontRequeueException 异常的时候，则消息会被拒绝，且 requeue = false（不重新入队列）</li><li>当抛出 ImmediateAcknowledgeAmqpException 异常，则消费者会被确认</li><li>其他的异常，则消息会被拒绝，且 requeue = true（如果此时只有一个消费者监听该队列，则有发生死循环的风险，多消费端也会造成资源的极大浪费，这个在开发过程中一定要避免的）。可以通过 setDefaultRequeueRejected（默认是true）去设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二种监听处理方式</span></span><br><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">    bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(exchange = @Exchange(value = &quot;$&#123;order.order-status.update.dlx.exchange&#125;&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;$&#123;order.order-status.update.dlx.key&#125;&quot;,</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;$&#123;order.order-status.update.dlx.queue&#125;&quot;, durable = &quot;true&quot;))&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(String message,Channel channel,<span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(tag,<span class="keyword">false</span>);            <span class="comment">// 确认消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局处理消息</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>);              <span class="comment">// 监听的队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL);        <span class="comment">// 手动确认</span></span><br><span class="line">    container.setMessageListener((ChannelAwareMessageListener) (message, channel) -&gt; &#123;      <span class="comment">//消息处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="keyword">if</span>(message.getMessageProperties().getHeaders().get(<span class="string">&quot;error&quot;</span>) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息已经确认&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);</span></span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息拒绝&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="阶梯重试（考虑幂等性）"><a href="#阶梯重试（考虑幂等性）" class="headerlink" title="阶梯重试（考虑幂等性）"></a>阶梯重试（考虑幂等性）</h5><ol><li>消息生产者将消息发送到普通队列，消费者接受到后进行处理；</li><li>若处理失败，将该消息发送到缓冲队列；</li><li>消息在队列到期后会自动的被发送到普通队列，再次消费。<br><img src="/2020/12/09/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/20190113192348240.png" alt="在这里插入图片描述"></li></ol><h2 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h2><p>消息中心的消息追踪需要使用 Trace 实现，Trace 是 Rabbitmq 用于记录每一次发送的消息，方便使用 Rabbitmq 的开发者调试、排错。可通过插件形式提供可视化界面。Trace 启动后会自动创建系统 Exchange：amq.rabbitmq.trace ,每个队列会自动绑定该 Exchange，绑定后发送到队列的消息都会记录到 Trace 日志。</p><h3 id="消息开启"><a href="#消息开启" class="headerlink" title="消息开启"></a>消息开启</h3><p>需要先 用rabbitmq 启用插件，再打开开关才能使用</p><table><thead><tr><th>命令集</th><th>描述</th></tr></thead><tbody><tr><td>rabbitmq-plugins list</td><td>查看插件列表</td></tr><tr><td>rabbitmq-plugins enable rabbitmq_tracing</td><td>rabbitmq 启用 trace 插件</td></tr><tr><td>rabbitmqctl trace_on</td><td>打开 trace 的开关</td></tr><tr><td>rabbitmqctl trace_on -p huali</td><td>打开 trace 的开关(huali为需要日志追踪的 vhost)</td></tr><tr><td>rabbitmqctl trace_off</td><td>关闭 trace 的开关</td></tr><tr><td>rabbitmq-plugins disable rabbitmq_tracing</td><td>rabbitmq 关闭 Trace 插件</td></tr><tr><td>rabbitmqctl set_user_tags heima administrator</td><td>只有 administrator 的角色才能查看日志界面</td></tr></tbody></table><p>安装插件并开启 trace_on 之后，会发现多个 exchange：amq.rabbitmq.trace ，类型为：topic。<br><img src="/2020/12/09/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/20201104111658326.png" alt="在这里插入图片描述"><br><img src="/2020/12/09/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/20201104111750995.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之management管理端详解</title>
      <link href="2020/12/08/RabbitMQ%E4%B9%8Bmanagement%E7%AE%A1%E7%90%86%E7%AB%AF%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/08/RabbitMQ%E4%B9%8Bmanagement%E7%AE%A1%E7%90%86%E7%AB%AF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.csdn.net/qq_27409289">坑里水库</a></p><p>出处：<a href="https://blog.csdn.net/qq_27409289/article/details/89510687">https://blog.csdn.net/qq_27409289/article/details/89510687</a></p><p><a href="https://link.jianshu.com/?t=https://github.com/rabbitmq/rabbitmq-management">rabbitmq-management</a>是RabbitMq web管理端，用的是erlang的cowboy框架进行开发。web页面包括Overview(概述)、Connections(连接)、Channels(通道)、Exchanges(交换器)、Queues(队列)、Admin(用户管理)</p><h2 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview(概述)"></a>Overview(概述)</h2><h3 id="overview-gt-Totals"><a href="#overview-gt-Totals" class="headerlink" title="overview-&gt;Totals"></a>overview-&gt;Totals</h3><p>Ready：待消费的消息总数。<br>Unacked：待应答的消息总数。<br>Total：总数 Ready+Unacked。</p><p>所有队列的消费情况。速率=(num1-num0)/(s1-s0) num1：s1时刻的个数。num0：s0时刻的个数。</p><p>Publish：producter pub消息的速率。<br>Publisher confirm：broker确认pub消息的速率。<br>Deliver(manual ack)：customer手动确认的速率。<br>Deliver( auto ack)：customer自动确认的速率。<br>Consumer ack：customer正在确认的速率。<br>Redelivered：正在传递’redelivered’标志集的消息的速率。<br>Get (manual ack)：响应basic.get而要求确认的消息的传输速率。<br>Get (auto ack)：响应于basic.get而发送不需要确认的消息的速率。<br>Return：将basic.return发送给producter的速率。<br>Disk read：queue从磁盘读取消息的速率。<br>Disk write：queue从磁盘写入消息的速率。</p><p>整体角色的个数</p><p>Connections：client的tcp连接的总数。<br>Channels：通道的总数。<br>Exchange：交换器的总数。<br>Queues：队列的总数。<br>Consumers：消费者的总数。</p><h3 id="Overview-gt-Nodes"><a href="#Overview-gt-Nodes" class="headerlink" title="Overview-&gt;Nodes"></a>Overview-&gt;Nodes</h3><p>broker的属性</p><p>Name：broker名称<br>File descriptors：broker打开的文件描述符和限制。<br>Socket descriptors：broker管理的网络套接字数量和限制。当限制被耗尽时，RabbitMQ将停止接受新的网络连接。<br>Erlang processes：erlang启动的进程数。<br>Memory：当前broker占用的内存。<br>Disk space：当前broker占用的硬盘。<br>Uptime：当前broker持续运行的时长。<br>Info：未知。<br>Reset stats：未知。</p><h3 id="Overview-gt-Export-definitions"><a href="#Overview-gt-Export-definitions" class="headerlink" title="Overview-&gt;Export definitions"></a>Overview-&gt;Export definitions</h3><p>定义由用户，虚拟主机，权限，参数，交换，队列和绑定组成。 它们不包括队列的内容或集群名称。 独占队列不会被导出。</p><h3 id="Overview-gt-Export-definitions-1"><a href="#Overview-gt-Export-definitions-1" class="headerlink" title="Overview-&gt;Export definitions"></a>Overview-&gt;Export definitions</h3><p>导入的定义将与当前定义合并。 如果在导入过程中发生错误，则所做的任何更改都不会回滚。</p><h2 id="Connections（当前所有客户端活动的连接。包括生成者和消费者）"><a href="#Connections（当前所有客户端活动的连接。包括生成者和消费者）" class="headerlink" title="Connections（当前所有客户端活动的连接。包括生成者和消费者）"></a>Connections（当前所有客户端活动的连接。包括生成者和消费者）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>User name：使用的用户名。<br>State：当前的状态，running：运行中；idle：空闲。<br>SSL/TLS：是否使用ssl进行连接。<br>Protocol：使用的协议。<br>Channels：创建的channel的总数。<br>From client：每秒发出的数据包。<br>To client：每秒收到的数据包。</p><h2 id="Channels（当前连接所有创建的通道）"><a href="#Channels（当前连接所有创建的通道）" class="headerlink" title="Channels（当前连接所有创建的通道）"></a>Channels（当前连接所有创建的通道）</h2><p>channel：名称。<br>Virtual host：所属的虚拟主机。<br>User name：使用的用户名。<br>Mode：渠道保证模式。 可以是以下之一，或者不是：C: confirm。T：transactional(事务)。<br>State ：当前的状态，running：运行中；idle：空闲。<br>Unconfirmed：待confirm的消息总数。<br>Prefetch：设置的prefetch的个数。<br>Unacker：待ack的消息总数。<br>publish：producter pub消息的速率。<br>confirm：producter confirm消息的速率。<br>deliver/get：consumer 获取消息的速率。<br>ack：consumer ack消息的速率。</p><h2 id="Exchanges（交换器属性）"><a href="#Exchanges（交换器属性）" class="headerlink" title="Exchanges（交换器属性）"></a>Exchanges（交换器属性）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>Type：exchange type，具体的type可以查看<a href="https://www.jianshu.com/p/5319b06f2e80">RabbitMq系列之一：基础概念</a>。<br>Features：功能。 可以是以下之一，或者不是：D: 持久化。T：Internal，存在改功能表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定，否则可以推送消息也可以绑定。<br>Message rate in：消息进入的速率。<br>Message rate out：消息出去的速率。</p><h2 id="Queues（队列的属性）"><a href="#Queues（队列的属性）" class="headerlink" title="Queues（队列的属性）"></a>Queues（队列的属性）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>Features：功能。 可以是以下之一，或者不是：D: 持久化。<br>State：当前的状态，running：运行中；idle：空闲。<br>Ready：待消费的消息总数。<br>Unacked：待应答的消息总数。<br>Total：总数 Ready+Unacked。<br>incoming：消息进入的速率。<br>deliver/get：消息获取的速率。<br>ack：消息应答的速率。</p><h2 id="Admin（用户属性）"><a href="#Admin（用户属性）" class="headerlink" title="Admin（用户属性）"></a>Admin（用户属性）</h2><p>Name：名称。<br>Tags：角色标签，只能选取一个。<br>Can access virtual hosts：允许进入的vhost。<br>Has password：设置了密码。</p><p>tags(原链接:<a href="https://link.jianshu.com/?t=https://www.cnblogs.com/java-zhao/p/5670476.html">https://www.cnblogs.com/java-zhao/p/5670476.html</a>)</p><ul><li>administrator (超级管理员)<br>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li><li>monitoring(监控者)<br>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li>policymaker(策略制定者)<br>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。</li><li>management(普通管理者)<br>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</li><li>none(其他)<br>无法登陆管理控制台，通常就是普通的生产者和消费者。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（九）之堆排序</title>
      <link href="2020/12/08/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2020/12/08/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>借助于二叉堆。使用二叉堆还实现了优先级队列，出队列的永远是最大优先级的数据即删除节点，入队列上浮即插入节点。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ol><li>把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。 </li><li>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。</li></ol><p>第1步，把无序数组构建成二叉堆，这一步的时间复杂度是O(n)。<br>第2步，需要进行n-1次循环。每次循环调用一次downAdjust方法，所以第2步的计算规模是 (n-1)×logn ，时间复杂度为O(nlogn)。<br>两个步骤是并列关系，所以整体的时间复杂度是O(nlogn)。</p><h2 id="堆排序和快速排序区别"><a href="#堆排序和快速排序区别" class="headerlink" title="堆排序和快速排序区别"></a>堆排序和快速排序区别</h2><p>相同点，堆排序和快速排序的平均时间复杂度都是O(nlogn)，并且都是不稳定排序。至于不同点，快速排序的最坏时间复杂度是O(n2)，而堆排序的最坏时间复杂度稳定在O(nlogn)。 </p><p>快速排序递归和非递归方法的平均空间复杂度都是O(logn)，而堆排序的空间复杂度是O(1)。 </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array       待调整的堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex 要“下沉”的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length      堆的有效大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">  <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">  <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">    <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">      childIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果父节点大于任何一个孩子的值，则直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">    array[parentIndex] = array[childIndex];</span><br><span class="line">    parentIndex = childIndex;</span><br><span class="line">    childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序（升序） * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 把无序数组构建成最大堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    downAdjust(array, i, array.length);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(Arrays.toString(array));</span><br><span class="line">  <span class="comment">// 循环删除堆顶元素，移到集合尾部，调整堆产生新的堆顶</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 最后1个元素和第1个元素进行交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[<span class="number">0</span>];</span><br><span class="line">    array[<span class="number">0</span>] = temp;</span><br><span class="line">    <span class="comment">// “下沉”调整最大堆</span></span><br><span class="line">    downAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  heapSort(arr);</span><br><span class="line">  System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-MVC原理</title>
      <link href="2020/12/07/Spring-MVC%E5%8E%9F%E7%90%86/"/>
      <url>2020/12/07/Spring-MVC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux发送http请求</title>
      <link href="2020/12/04/Linux%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/"/>
      <url>2020/12/04/Linux%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/kaleidoscope/">kaleidoscopic</a></p><p>出处：<a href="https://www.cnblogs.com/kaleidoscope/p/9719841.html">https://www.cnblogs.com/kaleidoscope/p/9719841.html</a></p><h2 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h2><h3 id="curl命令模拟Get请求："><a href="#curl命令模拟Get请求：" class="headerlink" title="curl命令模拟Get请求："></a>curl命令模拟Get请求：</h3><p>1、使用curl命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://www.baidu.com&quot;     如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span><br><span class="line">curl -i &quot;http://www.baidu.com&quot;  显示全部信息</span><br><span class="line">curl -I &quot;http://www.baidu.com&quot;  只显示头部信息</span><br><span class="line">curl -v &quot;http://www.baidu.com&quot;  显示get请求全过程解析</span><br></pre></td></tr></table></figure><p>2、使用wget命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;http://www.baidu.com&quot;</span><br></pre></td></tr></table></figure><h3 id="curl命令模拟Get请求携带参数（linux）："><a href="#curl命令模拟Get请求携带参数（linux）：" class="headerlink" title="curl命令模拟Get请求携带参数（linux）："></a>curl命令模拟Get请求携带参数（linux）：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com</span><br></pre></td></tr></table></figure><p>上述命令在linux系统，get请求携带的参数只到version=1，”&amp;”符号在linux系统中为后台运行的操作符，此处需要使用反斜杠”\”转义，即：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://127.0.0.1:80/xcloud/test?version=1\&amp;client_version=1.1.0\&amp;seq=1001\&amp;host=aaa.com</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com&quot;</span><br></pre></td></tr></table></figure><h2 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h2><p>1、使用curl命令，通过-d参数，把访问参数放在里面，如果没有参数，则不需要-d，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;username=user1&amp;password=123&quot; &quot;www.test.com/login&quot;</span><br></pre></td></tr></table></figure><p>2、使用wget命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget –post-data &#x27;username=user1&amp;password=123&#x27; http://www.baidu.com</span><br></pre></td></tr></table></figure><p>3、发送格式化json请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -k -H &quot;Content-type: application/json&quot; -X POST -d &#x27;&#123;&quot;version&quot;:&quot;6.6.0&quot;, &quot;from&quot;:&quot;mu&quot;, &quot;product_version&quot;:&quot;1.1.1.0&quot;&#125;&#x27; https://10.10.10.10:80/test</span><br></pre></td></tr></table></figure><h2 id="curl和wget区别"><a href="#curl和wget区别" class="headerlink" title="curl和wget区别"></a>curl和wget区别</h2><p>curl模拟的访问请求一般直接在控制台显示，而wget则把结果保存为一个文件。如果结果内容比较少，需要直接看到结果可以考虑使用curl进行模拟请求，如果返回结果比较多，则可考虑wget进行模拟请求。</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（八）之快速排序</title>
      <link href="2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快排原理"><a href="#快排原理" class="headerlink" title="快排原理"></a>快排原理</h2><ol><li>随机选择一个元素作为基准元素（pivot），并且让基准元素和数列首元素交换位置。解决最大值或最小值本身就是第一个元素，退化成O(n^2^)。</li><li>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。</li></ol><p>虽然快速排序的平均时间复杂度是O(nlogn)，但最坏情况下的时间复杂度是O(n^2^)。</p><h2 id="元素的交换"><a href="#元素的交换" class="headerlink" title="元素的交换"></a>元素的交换</h2><ul><li>双边循环法。</li><li>单边循环法</li></ul><h4 id="双边循环法"><a href="#双边循环法" class="headerlink" title="双边循环法"></a>双边循环法</h4><p><strong>原则</strong>：</p><ol><li>选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。<img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207112907329.png" alt="image-20201207112907329" style="zoom: 50%;"></li><li>从right指针开始，让指针所指向的元素和基准元素做比较。如果大于或等于pivot，则指针向左移动；如果小于pivot，则right指针停止移动，切换到left指针。 <img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207132506437.png" alt="image-20201207132506437" style="zoom:50%;"></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex&gt;=endIndex)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition(arrays, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort(arrays,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">    quickSort(arrays,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arrays[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line">    <span class="keyword">while</span> (left!=right)&#123;</span><br><span class="line">      <span class="comment">//控制right 指针比较并左移</span></span><br><span class="line">      <span class="keyword">while</span> (left&lt;right &amp;&amp; arrays[right]&gt;pivot)&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">      <span class="keyword">while</span> (left&lt;right &amp;&amp; arrays[left]&lt;=pivot)&#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//交换left和right 指针所指向的元素</span></span><br><span class="line">      <span class="keyword">if</span>(right&gt;left)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arrays[right];</span><br><span class="line">        arrays[right] = arrays[left];</span><br><span class="line">        arrays[left] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pivot 和指针重合点交换</span></span><br><span class="line">    arrays[startIndex] = arrays[left];</span><br><span class="line">    arrays[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="单边循环法"><a href="#单边循环法" class="headerlink" title="单边循环法"></a>单边循环法</h4><p><strong>原理</strong>：</p><ol><li>首先选定基准元素pivot。同时，设置一个mark指针指向数列起始位置，这个mark指针代表小于基准元素的区域边界<img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207135733083.png" alt="image-20201207135733083" style="zoom:50%;"></li><li>如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1；第二，让最新遍历到的元素和mark指针所 在位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。 <img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207135924557.png" alt="image-20201207135924557" style="zoom:50%;"></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex&gt;=endIndex)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition2(arrays, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort2(arrays,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">    quickSort2(arrays,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arrays[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= startIndex+<span class="number">1</span>;i&lt;=endIndex;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrays[i]&lt; pivot)&#123;</span><br><span class="line">        mark++;</span><br><span class="line">        <span class="keyword">int</span> temp = arrays[mark];</span><br><span class="line">        arrays[mark] = arrays[i];</span><br><span class="line">        arrays[i] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arrays[startIndex] = arrays[mark];</span><br><span class="line">    arrays[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用一个集合栈来代替递归的函数栈 </span></span><br><span class="line">  Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">  <span class="comment">// 整个数列的起止下标，以哈希的形式入栈 </span></span><br><span class="line">  Map rootParam = <span class="keyword">new</span> HashMap();</span><br><span class="line">  rootParam.put(<span class="string">&quot;startIndex&quot;</span>, startIndex);</span><br><span class="line">  rootParam.put(<span class="string">&quot;endIndex&quot;</span>, endIndex);</span><br><span class="line">  quickSortStack.push(rootParam);</span><br><span class="line">  <span class="comment">// 循环结束条件：栈为空时 </span></span><br><span class="line">  <span class="keyword">while</span> (!quickSortStack.isEmpty()) &#123; </span><br><span class="line">    <span class="comment">// 栈顶元素出栈，得到起止下标 </span></span><br><span class="line">    Map&lt;String, Integer&gt; param = quickSortStack.pop(); </span><br><span class="line">    <span class="comment">// 得到基准元素位置 </span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, param.get(<span class="string">&quot;startIndex&quot;</span>), param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">    <span class="comment">// 根据基准元素分成两部分, 把每一部分的起止下标入栈 </span></span><br><span class="line">    <span class="keyword">if</span> (param.get(<span class="string">&quot;startIndex&quot;</span>) &lt; pivotIndex - <span class="number">1</span>) &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">      leftParam.put(<span class="string">&quot;startIndex&quot;</span>, param.get(<span class="string">&quot;startIndex&quot;</span>));</span><br><span class="line">      leftParam.put(<span class="string">&quot;endIndex&quot;</span>, pivotIndex - <span class="number">1</span>);</span><br><span class="line">      quickSortStack.push(leftParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pivotIndex + <span class="number">1</span> &lt; param.get(<span class="string">&quot;endIndex&quot;</span>)) &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">      rightParam.put(<span class="string">&quot;startIndex&quot;</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">      rightParam.put(<span class="string">&quot;endIndex&quot;</span>, param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">      quickSortStack.push(rightParam);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（七）之排序算法</title>
      <link href="2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法时间复杂度对比"><a href="#排序算法时间复杂度对比" class="headerlink" title="排序算法时间复杂度对比"></a>排序算法时间复杂度对比</h2><table><thead><tr><th>排序算法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2^)</td></tr><tr><td>选择排序</td><td>O(n^2^)</td></tr><tr><td>插入排序</td><td>O(n^2^)</td></tr><tr><td>希尔排序</td><td>性能略优于O(n^2^),但又比不上O(nlog<del>2</del>n)</td></tr><tr><td>快速排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>归并排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>堆排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>计数排序</td><td>O(n)</td></tr><tr><td>桶排序</td><td>O(n)</td></tr><tr><td>基数排序</td><td>O(n)</td></tr></tbody></table><h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 更新为最后一次交换元素的位置</span></span><br><span class="line">          lastExchangeIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortBorder = lastExchangeIndex;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    bubbleSort2(array);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>排序过程就像钟摆一样，第1轮从左到右，第2轮从右到左，第3轮再从左到右……</p><p>在大部分元素已经有序的情况下能发挥优势，减少排序的回合数；代码量几乎增加了1倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 有元素交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在偶数轮之前，将isSorted重新标记为true</span></span><br><span class="line">      isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 偶数轮，从右向左比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length - i - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">          array[j - <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一轮：从左到右，先从2开始比较，找到最大值</span></span><br><span class="line">    <span class="comment">//第二轮：从右到左，从8开始比较，找到最小值</span></span><br><span class="line">    <span class="comment">//之后轮询继续比较</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（六）之二叉堆实现优先级队列</title>
      <link href="2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的特点是先进先出（FIFO）。 </p><ul><li>入队列，将新元素置于队尾。</li><li>出队列，队头元素最先被移出。</li></ul><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列不再遵循先入先出的原则，而是分为两种情况。</p><ul><li>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 </li><li>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队 </li></ul><h2 id="优先队列实现"><a href="#优先队列实现" class="headerlink" title="优先队列实现"></a>优先队列实现</h2><p>利用线性数据结构并非不能实现，但是时间复杂度较高。因此可以利用二叉堆的特性来实现优先队列。最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。</p><p><strong>二叉堆的特性</strong>：</p><ul><li><p>最大堆的堆顶是整个堆中的最大元素。 </p></li><li><p>最小堆的堆顶是整个堆中的最小元素。 </p></li></ul><p><strong>二叉堆的时间复杂度</strong>：</p><p>插入和删除操作都是O(logn)，构建二叉堆的时间复杂度为O(n)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列初始长度为</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队 * <span class="doctag">@param</span> key 入队元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列长度超出范围，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= array.length) &#123;</span><br><span class="line">      resize();</span><br><span class="line">    &#125;</span><br><span class="line">    array[size++] = key;</span><br><span class="line">    upAdjust();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;the queue is empty !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取堆顶元素</span></span><br><span class="line">    <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 让最后一个元素移动到堆顶</span></span><br><span class="line">    array[<span class="number">0</span>] = array[--size];</span><br><span class="line">    downAdjust();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “上浮”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex]) &#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childIndex] = array[parentIndex];</span><br><span class="line">      childIndex = parentIndex;</span><br><span class="line">      parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “下沉”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp 保存父节点的值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">        childIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点大于任何一个孩子的值，直接跳出</span></span><br><span class="line">      <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childIndex];</span><br><span class="line">      parentIndex = childIndex;</span><br><span class="line">      childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 队列扩容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列容量翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">    priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（五）之二叉堆</title>
      <link href="2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
      <url>2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆本质上是一种完全二叉树，它分为两个类型。 </p><ol><li><p>最大堆。 最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值</p></li><li><p>最小堆。最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200307460.png" alt="image-20201203200307460" style="zoom:80%;"></li></ol><p>二叉堆的根节点叫作<strong>堆顶</strong>。最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>插入节点：单一节点上浮，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li><li>删除节点：单一节点下沉，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li><li>构建二叉堆：要所有非叶子节点依次“下沉”，时间复杂度是O(n)</li></ul><p><strong>时间复杂度推导</strong></p><p>n为节点数，level为层级</p><ul><li>插入和删除：f(n) = level-1; n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=log<del>2</del>(n+1)-1，所以时间复杂度为O(log<del>2</del>n)</li><li>构建二叉堆：满二叉树堆则f(n) = 2^level-1^；n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=2^log(n+1)^-2=n-1,所以为O(n)</li></ul><h2 id="自我调整"><a href="#自我调整" class="headerlink" title="自我调整"></a>自我调整</h2><p>这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。</p><ol><li>插入节点 </li></ol><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是 0。这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节点“上浮”，和父节点交换位置。继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。继续比较，最终新节点0“上浮”到了堆顶位置。<br><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203105517492.png" alt="image-20201203105517492"></p><ol start="2"><li>删除节点 </li></ol><p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点。例如删除最小堆的堆顶节点1。这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到原本堆顶的位置。接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果左、右孩子节点中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203194844232.png" alt="image-20201203194844232"><ol start="3"><li>构建二叉堆</li></ol><p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，**<font color="red">本质就是让所有 非叶子节点依次“下沉”</font>**。</p><p>如下图的无序完全二叉树，找到第一个非叶子节点即10，与其子节点比较，节点6与节点10交互位置。数组方式存储，则下一个节点为节点3，与其子节点比较，节点3与节点2交互位置。下一个节点为1，与字节点比较，不用交换位置。最后一个节点为7，与其子节点比较，节点7下沉，与节点1交互位置，继续与子节点比较，子节点为6和5，最后于5节点交换位置。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200122412.png" alt="image-20201203200122412" style="zoom:80%;"><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childrenIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&gt;<span class="number">0</span> &amp;&amp; temp&lt;array[parentIndex])&#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childrenIndex] = array[parentIndex];</span><br><span class="line">      childrenIndex = parentIndex;</span><br><span class="line">      parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childrenIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> array  待调整的堆</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parentIndex  要“下沉”的父节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> parentIndex,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&lt;length)&#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span>(childrenIndex+<span class="number">1</span>&lt;length &amp;&amp; array[childrenIndex+<span class="number">1</span>]&lt;array[childrenIndex])&#123;</span><br><span class="line">        childrenIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">      <span class="keyword">if</span>(temp&lt;array[childrenIndex])&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childrenIndex];</span><br><span class="line">      parentIndex = childrenIndex;</span><br><span class="line">      childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeapTree</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">      downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    upAdjust(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    buildHeapTree(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除是用最后一个节点值替换要删除的节点，之后再下沉自我调整</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    downAdjust(array,<span class="number">1</span>,array.length);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉堆的使用场景"><a href="#二叉堆的使用场景" class="headerlink" title="二叉堆的使用场景"></a>二叉堆的使用场景</h2><p>二叉堆是实现<strong>堆排序</strong>及<strong>优先队列</strong>的基础</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（四）之树及二叉树和遍历</title>
      <link href="2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/"/>
      <url>2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="树概念"><a href="#树概念" class="headerlink" title="树概念"></a>树概念</h2><p>树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。 </p><ol><li>有且仅有一个特定的称为根的节点。</li><li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 <img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134605336.png" alt="image-20201201134605336" style="zoom: 33%;"></li></ol><p>在上图中，节点1是根节点（root）；节点5、6、7、8是树的末端，没有“孩子”，被称为叶子节点（leaf）。图中的虚线部分，是根节点1的其中一个子树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134818417.png" alt="image-20201201134818417" style="zoom: 33%;"></p><p>树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如下。</p><p>在上图中，节点4的上一级节点，是节点4的<strong>父节点（parent）</strong>；从节点4衍生出来的节点，是节点4的<strong>孩子节点（child）</strong>；和节点4同级，由同一个父节点衍生出来的节点，是节点4的<strong>兄弟节点（sibling）</strong></p><p>树的最大层级数，被称为树的高度或深度。显然，上图这个树的高度是4。</p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135228229.png" alt="image-20201201135228229" style="zoom: 33%;"><br>二叉树节点的两个孩子节点，一个被称为<strong>左孩子（left child）</strong>，一个被称为<strong>右孩子（right child）</strong>。这两个孩子节点的顺序是固定的，就像人的左手就是左手，右手就是右手，不能够颠倒或混淆。</p><p>二叉树还有两种特殊形式，一个叫作<strong>满二叉树</strong>，另一个叫作<strong>完全二叉树</strong></p><h3 id="什么是满二叉树"><a href="#什么是满二叉树" class="headerlink" title="什么是满二叉树"></a>什么是满二叉树</h3><p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。简单点说，满二叉树的每一个分支都是满的。一棵深度为k且有2^K^-1个节点的二叉树称为满二叉树。满二叉树每一层的结点个数都达到了最大值, 即满二叉树的第i层上有2^i-1^个节点（i&gt;=1）<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135513962.png" alt="image-20201201135513962" style="zoom:33%;"></p><h3 id="什么是完全二叉树"><a href="#什么是完全二叉树" class="headerlink" title="什么是完全二叉树"></a>什么是完全二叉树</h3><p>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135646991.png" alt="image-20201201135646991" style="zoom:33%;"><br>在上图中，二叉树编号从1到12的12个节点，和前面满二叉树编号从1到12的节点位置完全对应。因此这个树是完全二叉树。<br>完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树</p><h3 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h3><p>链式存储结构。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140333971.png" alt="image-20201201140333971" style="zoom:25%;"></p><ul><li>存储数据的data变量 </li><li>指向左孩子的left指针 </li><li>指向右孩子的right指针</li></ul><p>数组。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140524048.png" alt="image-20201201140524048" style="zoom:25%;"><br>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p><p><strong>为什么这样设计</strong><br>因为这样可以更方便地在数组中定位二叉树的孩子节点和 父节点。</p><p>假设一个父节点的下标是parent，那么它的左孩子节点下标就是2×parent +1；右孩子节点下标就是2×parent + 2。<br>反过来，假设一个左孩子节点的下标是leftChild，那么它的父节点下标就是（leftChild-1）/ 2。<br>假如节点4在数组中的下标是3，节点4是节点2的左孩子，节点2的下标可以直接<br>通过计算得出。节点2的下标 = (3-1)/2 = 1 </p><p>显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p><p><strong>什么样的二叉树最适合用数组表示呢？</strong></p><p>一种特殊的完全二叉树，就是用数组来存储的。</p><h3 id="二叉树应用"><a href="#二叉树应用" class="headerlink" title="二叉树应用"></a>二叉树应用</h3><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行<strong>查找操作和维持相对顺序</strong>这两个方面。 </p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>二叉树的树形结构使它很适合扮演索引的角色。 <strong>二叉查找树（binary search tree）</strong>主要作用就是进行查找操作</p><p><strong>二叉查找树</strong><br>二叉查找树在二叉树的基础上增加了以下几个条件。 <font color="red"><strong>为了查找方便</strong></font>。</p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值 </li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值 </li><li>左、右子树也都是二叉查找树<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141125488.png" alt="image-20201201141125488" style="zoom:25%;">对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度是一样的。这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。 #### **维持相对顺序**二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。因此二叉查找树还有另一个名字——二叉排序树（binary sort tree）。 </li></ul><h4 id="二叉查找树（二叉排序树）的问题"><a href="#二叉查找树（二叉排序树）的问题" class="headerlink" title="二叉查找树（二叉排序树）的问题"></a>二叉查找树（二叉排序树）的问题</h4><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141637961.png" alt="image-20201201141637961" style="zoom:25%;">在根节点为10的节点情况下，插入9、8、7节点时，会出现如图的情况。查询节点的时间复杂度退化成O(n)。<h4 id="二叉树自平衡"><a href="#二叉树自平衡" class="headerlink" title="二叉树自平衡"></a>二叉树自平衡</h4><p>二叉树自平衡的方式有多种，如红黑树、AVL树、树堆等</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>从节点之间位置关系的角度来看，二叉树的遍历分为4种</p><ul><li><p><strong>前序遍历</strong>：输出顺序是根节点、左子树、右子树。</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200256982.png" alt="image-20201201200256982" style="zoom:25%;"></li><li><p><strong>中序遍历</strong>：输出顺序是左子树、根节点、右子树</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200341762.png" alt="image-20201201200341762" style="zoom:25%;"></li><li><p><strong>后序遍历</strong>：输出顺序是左子树、右子树、根节点</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200417902.png" alt="image-20201201200417902" style="zoom:25%;"></li><li><p>层序遍历。层级输出</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201202112654756.png" alt="image-20201202112654756" style="zoom:25%;"></li></ul><p>从更宏观的角度来看，二叉树的遍历归结为两大类。</p><ul><li><p>深度优先遍历（前序遍历、中序遍历、后序遍历）。 所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。</p></li><li><p>广度优先遍历（层序遍历）。就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点 。</p><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。 </p></li></ul><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(LinkedList list)</span> </span>&#123;</span><br><span class="line">    TreeNode treeNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(list) || list.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object o = list.removeFirst();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(o)) &#123;</span><br><span class="line">      treeNode = <span class="keyword">new</span> TreeNode();</span><br><span class="line">      treeNode.date = o;</span><br><span class="line">      treeNode.leftNode = createTree(list);</span><br><span class="line">      treeNode.rightNode = createTree(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeachWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode treeNode = root;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (treeNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        stack.push(treeNode.leftNode);</span><br><span class="line">        treeNode = treeNode.leftNode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop != <span class="keyword">null</span>) &#123;</span><br><span class="line">          treeNode = pop.rightNode;</span><br><span class="line">          stack.push(treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    Object date;</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList list = <span class="keyword">new</span> LinkedList(Arrays</span><br><span class="line">        .asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">7</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">10</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="number">4</span>&#125;));</span><br><span class="line">    TreeNode treeNode = createTree(list);</span><br><span class="line">    preOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    preOrderForeachWithStack(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    inOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    postOrderForeach(treeNode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderForeach</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">    TreeNode treeNode = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(treeNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.print(treeNode.date+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(treeNode.leftNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.leftNode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(treeNode.rightNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.rightNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之数据结构线性结构和非线性结构</title>
      <link href="2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://www.cnblogs.com/mr-wuxiansheng/">Mr_伍先生</a></p><p>出处：<a href="https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html">https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html</a></p><h2 id="线性结构："><a href="#线性结构：" class="headerlink" title="线性结构："></a>线性结构：</h2><p>一、概念</p><ol><li><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</p></li><li><p>线性结构拥有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</p></li><li><p>线性结构中存在两种操作受限的使用场景，即队列和栈。栈的操作只能在线性表的一端进行，就是我们常说的先进后出（FILO），队列的插入操作在线性表的一端进行而其他操作在线性表的另一端进行，先进先出（FIFO），由于线性结构存在两种存储结构，因 此队列和栈各存在两个实现方式。</p></li></ol><p>二、部分实现</p><ol><li><p>顺序表（顺序存储）</p><p>　　按照我们的习惯，存放东西时，一般是找一块空间，然后将需要存放的东西依次摆放，这就是顺序存储。计算机中的顺序存储是指在内存中用一块地址连续的空间依次存放数据元素，用这种方式存储的线性表叫顺序表其特点是表中相邻的数据元素在内存中存储位置也相邻，如下图：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809140928262-492338500.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置线性表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     T tmp = <span class="keyword">default</span>(T);</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> len = GetLength() - <span class="number">1</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (i.Equals(len - i))</span><br><span class="line"><span class="number">10</span>         &#123;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>         tmp = data[i];</span><br><span class="line"><span class="number">15</span>         data[i] = data[len - i];</span><br><span class="line"><span class="number">16</span>         data[len - i] = tmp;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>链表（链式存储）</p><p>　　假如我们现在要存放一些物品，但是没有足够大的空间将所有的物品一次性放下（电脑中使用链式存储不是因为内存不够先事先说明一下…，具体原因后续会说到），同时设定我们因为脑容量很小，为了节省空间，只能记住一件物品位置。此时我们很机智的找到了解决方案：存放物品时每放置一件物品就在物品上贴一个小纸条，标明下一件物品放在那里，只记住第一件物品的位置，寻找的时候从第一件物品开始寻找，通过小纸条我们可以找到所有的物品，这就是链式存储。链表实现的时候不再像线性表一样只存储数据即可，还有下一个数据元素的地址，因此先定义一个节点类(Node)，记录物品信息和下一件物品的位置，我们把物品本身叫做数据域，存储下一件物品地址信息的小纸条称为引用域。链表结构示意图如下：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809143506652-1333091670.png" alt="img"></p><p>　　寻找物品的时候发现了一个问题，我们从一件物品找下一件物品的时候很容易，但是如果要找上一件物品就得从头开始找，真的很麻烦。为了解决这个问题我们又机智了一把，模仿之前的做法，在存放物品的时候多放置一个小纸条记录上一件物品的位置，这样就可以很快的找到上一件物品了。我们把这种方式我们称为双向链表，前面只放置一张小纸条的方式称为单向链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置单链表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; oldHead = Head;</span><br><span class="line"> <span class="number">5</span>     Node&lt;T&gt; tmp ;</span><br><span class="line"> <span class="number">6</span>     Head = <span class="keyword">null</span>;    <span class="comment">//清空链表，解除Head跟oldHead之间的相同引用</span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="keyword">while</span> (oldHead != <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">9</span>     &#123;</span><br><span class="line"><span class="number">10</span>         tmp = Head;</span><br><span class="line"><span class="number">11</span>         Head = oldHead;</span><br><span class="line"><span class="number">12</span>         <span class="comment">//解除Head跟oldHead之间的相同引用</span></span><br><span class="line"><span class="number">13</span>         oldHead = oldHead.Next;</span><br><span class="line"><span class="number">14</span>         Head.Next = tmp;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure><p>　　由于数据存储结构不同导致使用场景上的巨大差异，顺序表由于元素连续具有随机存储的特点，所以查找数据很方便效率很高，但是插入、删除操作为了确保数据元素连续，需要移动大量的数据导致效率很低。而链表由于存储空间不要求连续，插入、删除只需修改相邻元素的引用域地址即可，所以效率很高，但查询需要从头引用开始遍历链表，效率很低。因此，如果只是进行查找操作而不经常插入、删除线性表中的数据元素，则使用顺序存储结构，反之，使用链式存储结构。</p></li><li><p>栈</p><p>　　其实成功完成顺序表和链表之后，栈已经没太多可说的了，主要是逻辑上的不同，毕竟栈也是一种特殊的线性结构。栈是一种操作限定在表尾部进行的线性表，表尾称为栈顶（Top），另一端固定不动，称为栈底（Bottom）。进栈、出栈示意图如下：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809151153090-1514548602.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链栈入驻</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; tmp = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Top == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Top = tmp;</span><br><span class="line"> <span class="number">8</span>     &#125;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>     &#123;</span><br><span class="line"><span class="number">11</span>         tmp.Next = Top;</span><br><span class="line"><span class="number">12</span>         Top = tmp;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     Num++;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">//顺序栈入栈</span></span><br><span class="line"><span class="number">18</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">19 </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">21</span>     &#123;</span><br><span class="line"><span class="number">22</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"><span class="number">25</span>     data[++Top] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>队列</p><p>　　队列与栈类似，仅仅是逻辑有一丢丢不同。队列是一种插入操作限定在表尾其他操作限定在表头的线性表。把进行插入操作的表尾称为队尾（Rear）,把进行其它操作的头部称为队首（Front）。入队、出队示意图如下：</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809152906777-1048463470.png" alt="img" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链队入队</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Rear == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Rear = node;</span><br><span class="line"> <span class="number">8</span>         Front = Rear;</span><br><span class="line"> <span class="number">9</span>     &#125;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">11</span>     &#123;</span><br><span class="line"><span class="number">12</span>         Rear.Next = node;</span><br><span class="line"><span class="number">13</span>         Rear = Rear.Next;</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     ++num;</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span> <span class="comment">//循环队列入队</span></span><br><span class="line"><span class="number">19</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">20 </span>&#123;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">22</span>     &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span>     data[++Rear] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="非线性结构："><a href="#非线性结构：" class="headerlink" title="非线性结构："></a>非线性结构：</h2><h3 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a><strong>一、相关概念</strong></h3><p>　　树作为一种应用广泛的一对多非线性数据结构，不仅有数据间的指向关系，还有层级关系，示例见图一。因树的结构比较复杂，为了简化操作及存储，我们一般将树转换为二叉树处理，因此本文主要讨论二叉树。</p><ol><li><p><strong>二叉树</strong><br>　　二叉树是每个节点最多拥有两个子节点的树结构，若移除根节点则其余节点会被分成两个互不相交的子树，分别称为左子树和右子树。二叉树是有序树，左右子树有严格的次序，若颠倒则成为一棵不一样的二叉树。</p></li><li><p><strong>满二叉树</strong>　　</p><p>​       满二叉树，顾名思义除叶子节点外所有节点都拥有两个孩子，且叶子节点在同一层的二叉树，示例见图二。</p></li><li><p><strong>完全二叉树</strong>　　</p><p>​        完全二叉树，移除最后一层节点后是满二叉树，且最后一层的节点都连续集中在最左面，示例见图三。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812141855625-736751376.png" alt="img"></p></li></ol><h3 id="二、二叉树存储结构"><a href="#二、二叉树存储结构" class="headerlink" title="二、二叉树存储结构"></a>二、二叉树存储结构</h3><ol><li><p><strong>顺序存储</strong>　　</p><p>​        根据完全二叉树的特性，可以计算出任意节点n的双亲节点及左右孩子节点的序号，因此完全二叉树的节点可以按照从上到下从左到右的顺序依次存储到一维数组中。非完全二叉树存储时应先将其改造为完全二叉树，以空替代不存在的节点，比较浪费存储空间，存储示意图见图四。</p></li><li><p><strong>链式存储</strong></p><p>　　树结构链式存储类似线性结构链式存储，先定义包含数据域和引用域的节点(Node)，然后通过引用域存储节点之间的关系。根据二叉树的结构来看，节点Node至少包含数据域(Data)，引用域(左孩子LChild、右孩子RChild)，为了方便通过孩子节点查找父节点，引用域中可以考虑添加父节点引用(Parent)，存储示意图见图五。</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812161601265-1301764954.png" alt="img"> </p></li></ol><h3 id="三、树与二叉树的转换"><a href="#三、树与二叉树的转换" class="headerlink" title="三、树与二叉树的转换"></a>三、树与二叉树的转换</h3><ol><li><p>树转二叉树</p><p><strong>加线</strong>，所有兄弟结点之间加一条连线。<br><strong>抹线</strong>，对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812155626000-1300189010.png" alt="img"></p></li><li><p>二叉树转树</p><p><strong>加线</strong>，若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来。<br><strong>抹线</strong>，删除原二叉树中所有结点与其右孩子结点的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812160125515-698914833.png" alt="img"></p></li></ol><h3 id="四、树遍历实现"><a href="#四、树遍历实现" class="headerlink" title="四、树遍历实现"></a>四、树遍历实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"> <span class="number">2</span> <span class="comment">/// 先序遍历（DLR）</span></span><br><span class="line"> <span class="number">3</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"> <span class="number">4</span> <span class="comment">/// &lt;![CDATA[首先访问跟节点，然后遍历左子树，最后右子树]]&gt;</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function"> 6 </span>&#123;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     Print(root);</span><br><span class="line"><span class="number">13</span>     PreOrder(root.LChild);</span><br><span class="line"><span class="number">14</span>     PreOrder(root.RChild);</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/// 中序遍历（LDR）</span></span><br><span class="line"><span class="number">19</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">20</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后根节点，最后遍历右子树]]&gt;</span></span><br><span class="line"><span class="number">21</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">22 </span>&#123;</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">24</span>     &#123;</span><br><span class="line"><span class="number">25</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     InOrder(root.LChild);</span><br><span class="line"><span class="number">29</span>     Print(root);</span><br><span class="line"><span class="number">30</span>     InOrder(root.RChild);</span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">34</span> <span class="comment">/// 后序遍历（LRD）</span></span><br><span class="line"><span class="number">35</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">36</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后遍历右子树，最后遍历根节点]]&gt;</span></span><br><span class="line"><span class="number">37</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">38 </span>&#123;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">40</span>     &#123;</span><br><span class="line"><span class="number">41</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">42</span>     &#125;</span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>     PostOrder(root.LChild);</span><br><span class="line"><span class="number">45</span>     PostOrder(root.RChild);</span><br><span class="line"><span class="number">46</span>     Print(root);</span><br><span class="line"><span class="number">47</span> &#125;</span><br><span class="line"><span class="number">48</span> </span><br><span class="line"><span class="number">49</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">50</span> <span class="comment">/// 层序遍历</span></span><br><span class="line"><span class="number">51</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">52</span> <span class="comment">/// &lt;![CDATA[从上向下从左到右]]&gt;</span></span><br><span class="line"><span class="number">53</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">54 </span>&#123;</span><br><span class="line"><span class="number">55</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">56</span>     &#123;</span><br><span class="line"><span class="number">57</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">58</span>     &#125;</span><br><span class="line"><span class="number">59</span>     CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt; sq = <span class="keyword">new</span> CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt;(<span class="number">50</span>);</span><br><span class="line"><span class="number">60</span>     sq.In(root);</span><br><span class="line"><span class="number">61</span>     <span class="keyword">while</span> (!sq.IsEmpty())</span><br><span class="line"><span class="number">62</span>     &#123;</span><br><span class="line"><span class="number">63</span>         Node&lt;<span class="keyword">char</span>&gt; tmp = sq.Out();</span><br><span class="line"><span class="number">64</span>         Print(tmp);</span><br><span class="line"><span class="number">65</span> </span><br><span class="line"><span class="number">66</span>         <span class="keyword">if</span> (tmp.LChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">67</span>         &#123;</span><br><span class="line"><span class="number">68</span>             sq.In(tmp.LChild);</span><br><span class="line"><span class="number">69</span>         &#125;</span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">71</span>         <span class="keyword">if</span> (tmp.RChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">72</span>         &#123;</span><br><span class="line"><span class="number">73</span>             sq.In(tmp.RChild);</span><br><span class="line"><span class="number">74</span>         &#125;</span><br><span class="line"><span class="number">75</span>     &#125;</span><br><span class="line"><span class="number">76</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程池</title>
      <link href="2020/11/30/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/11/30/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发集合</title>
      <link href="2020/11/30/java%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/"/>
      <url>2020/11/30/java%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="2020/11/30/java%E9%9B%86%E5%90%88/"/>
      <url>2020/11/30/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><strong>数组</strong></p><p>​    开辟连续内存地址空间，数组长度固定，不能进行扩容，顺序存储。</p><hr><p><strong>List集合</strong></p><p>​    list集合可以使用数组或链表存储数据。</p><ul><li><p>ArrayList 使用数组进行存储。查找、更新效率高，插入、删除效率低，顺序存储，扩容为旧数组</p></li><li><p>LinkedList 使用双向链表进行存储。查找、更新效率低，插入、删除效率高，随机存储，不需要考虑扩容。<font color="red">使用二分查找法</font></p></li><li><p>Vector 使用数组进行存储，使用synchronized保证线程安全</p></li></ul><hr><p><strong>Map哈希表</strong></p><ul><li><p>HashMap 1.7使用数组+单链表  1.8使用数组+单链表/红黑树(提升插入和查找的效率)，原容量的二倍扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_INITIAL_CAPACITY <span class="comment">//初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</span></span><br><span class="line">MAXIMUM_CAPACITY <span class="comment">//哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</span></span><br><span class="line">DEFAULT_LOAD_FACTOR <span class="comment">//默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span></span><br><span class="line">TREEIFY_THRESHOLD <span class="comment">//如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。</span></span><br><span class="line">UNTREEIFY_THRESHOLD <span class="comment">// 在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。</span></span><br><span class="line">MIN_TREEIFY_CAPACITY <span class="comment">//在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash <span class="comment">//计算下标</span></span><br></pre></td></tr></table></figure></li><li><p>LinkedHashMap  继承HashMap,多了二个自定义的继承HashMap的Node(增加了Entry&lt;K,V&gt; before, after)类的Entry类型的变量head、tail。通过head和tail节点记录数据的<font color="red">插入顺序或者访问顺序。</font>默认是插入顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head; <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail; <span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">//访问顺序，默认为false</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TreeMap  使用红黑树，可以自定义<font color="red">比较器</font>。自动通过key比较大小，如果key相等，则覆盖value的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//根节点</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WeakHashMap 弱键值对，与HashMap类似，使用的是数组+单链表，涉及到扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;(); <span class="comment">//弱引用队列</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弱引用——&gt;回收之后会存入引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashTable 线程安全的，与HashMap类似，使用数组+单链表，涉及到扩容。使用同步块synchronized，保证线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EnumMap</p></li></ul><hr><p><strong>Set集合</strong></p><ul><li><p>HashSet 使用的是HashMap进行数据存储，value为Object对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LinkedHashSet 继承HashSet，使用LinkedHashMap进行数据存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TreeSet 成员变量m的类型为TreeMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>Stack栈</strong> 先进后出（FILO），synchronized同步块保证线程安全，继承Vector，底层使用数组保存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Vector,线程同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>BitSet位图</strong> 使用数组存储，每位存储的值为0或者1，使用位运算。二倍原数组长度扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] words;</span><br><span class="line"><span class="comment">//计算value[值为0,1]在那个数组里下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;  <span class="comment">//ADDRESS_BITS_PER_WORD=6,&gt;&gt;6表示除以2的6次方即64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算bitIndex的值 1L&lt;&lt;64 还是等于为1</span></span><br><span class="line">(words[wordIndex] &amp; (<span class="number">1L</span> &lt;&lt; bitIndex)) != <span class="number">0</span></span><br><span class="line"><span class="comment">//设置bitIndex的值为1</span></span><br><span class="line">words[wordIndex] |= (<span class="number">1L</span> &lt;&lt; bitIndex);</span><br></pre></td></tr></table></figure><hr><p><strong>Queue队列</strong></p><ul><li><p>ArrayDeque 双端队列</p></li><li><p>PriorityQueue 优先级队列</p></li><li><p>BlockingQueue 堵塞队列</p><ul><li><p><strong>LinkedBlockingQueue</strong> 的容量是没有上限的（说的不准确，在不指定时容量为Integer.MAX_VALUE，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。</p></li><li><p><strong>ArrayBlockingQueue</strong> 在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序。</p></li><li><p><strong>DelayQueue</strong>（基于PriorityQueue来实现的）是一个存放Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。 </p></li><li><p><strong>PriorityBlockingQueue</strong> 是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。</p></li><li><p><strong>SynchronousQueue</strong> 一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没 有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null 元素。</p><p>同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p><p> 看起来很有意思吧。队列竟然是没有内部容量的。这个队列其实是BlockingQueue的一种实现。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。它给我们提供了在线程之间交换单一元素的极轻量级方法</p></li></ul></li></ul><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><strong>add</strong></td><td>增加一个元索           如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td></tr><tr><td><strong>remove</strong></td><td>移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td><strong>element</strong></td><td>返回队列头部的元素 ，如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td><strong>offer</strong></td><td>添加一个元素并返回true    如果队列已满，则返回false</td></tr><tr><td><strong>poll</strong></td><td>移除并返问队列头部的元素  如果队列为空，则返回null</td></tr><tr><td><strong>peek</strong></td><td>返回队列头部的元素       如果队列为空，则返回null</td></tr><tr><td><strong>put</strong></td><td>添加一个元素           如果队列满，则阻塞</td></tr><tr><td><strong>take</strong></td><td>移除并返回队列头部的元素   如果队列为空，则阻塞</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s之调度器和调度过程</title>
      <link href="2020/11/30/k8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/"/>
      <url>2020/11/30/k8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本文作者</strong>：**<a href="https://www.cnblogs.com/xzkzzz/p/9963511.html">大胖猴</a>**<br><strong>本文链接</strong>：<a href="https://www.cnblogs.com/xzkzzz/p/9963511.html">https://www.cnblogs.com/xzkzzz/p/9963511.html</a></p><h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><p>当Scheduler通过API server 的watch接口监听到新建Pod副本的信息后，它会检查所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。Scheduler在整个系统中承担了承上启下的作用，承上是负责接收创建的新Pod，为安排一个落脚的地（Node）,启下是安置工作完成后，目标Node上的kubelet服务进程接管后继工作，负责Pod生命周期的后半生。具体来说，Scheduler的作用是将待调度的Pod安装特定的调度算法和调度策略绑定到集群中的某个合适的Node上，并将绑定信息传给API server 写入etcd中。整个调度过程中涉及三个对象，分别是：待调度的Pod列表，可以的Node列表，以及调度算法和策略。</p><p>Kubernetes Scheduler 提供的调度流程分三步：</p><ol><li>预选策略(predicate) 遍历nodelist，选择出符合要求的候选节点，Kubernetes内置了多种预选规则供用户选择。</li><li>优选策略(priority) 在选择出符合要求的候选节点中，采用优选规则计算出每个节点的积分，最后选择得分最高的。</li><li>选定(select) 如果最高得分有好几个节点，select就会从中随机选择一个节点。</li></ol><p>如图：</p><p><img src="/2020/11/30/k8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/1076553-20181115142949847-1134192119.png" alt="img"></p><p>预选策略算法的集合在<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithm/predicates/predicates.go">官方源码</a></p><h3 id="常用的预选策略（代码里的策略不一定都会被使用）"><a href="#常用的预选策略（代码里的策略不一定都会被使用）" class="headerlink" title="常用的预选策略（代码里的策略不一定都会被使用）"></a>常用的预选策略（代码里的策略不一定都会被使用）</h3><ul><li>CheckNodeConditionPred 检查节点是否正常</li><li>GeneralPred HostName(如果pod定义hostname属性，会检查节点是否匹配。pod.spec.hostname)、PodFitsHostPorts（检查pod要暴露的hostpors是否被占用。pod.spec.containers.ports.hostPort）</li><li>MatchNodeSelector pod.spec.nodeSelector 看节点标签能否适配pod定义的nodeSelector</li><li>PodFitsResources 判断节点的资源能够满足Pod的定义（如果一个pod定义最少需要2C4G node上的低于此资源的将不被调度。用kubectl describe node NODE名称 可以查看资源使用情况）</li><li>NoDiskConflict 判断pod定义的存储是否在node节点上使用。（默认没有启用）</li><li>PodToleratesNodeTaints 检查pod上Tolerates的能否容忍污点（pod.spec.tolerations）</li><li>CheckNodeLabelPresence 检查节点上的标志是否存在 （默认没有启动）</li><li>CheckServiceAffinity 根据pod所属的service。将相同service上的pod尽量放到同一个节点（默认没有启动）</li><li>CheckVolumeBinding 检查是否可以绑定（默认没有启动）</li><li>NoVolumeZoneConflict 检查是否在一起区域（默认没有启动）</li><li>CheckNodeMemoryPressure 检查内存是否存在压力</li><li>CheckNodeDiskPressure  检查磁盘IO压力是否过大</li><li>CheckNodePIDPressure 检查pid资源是否过大</li></ul><h3 id="优选策略"><a href="#优选策略" class="headerlink" title="优选策略"></a>优选策略</h3><ul><li>least_requested 选择消耗最小的节点（根据空闲比率评估 cpu(总容量-sum(已使用)*10/总容量) ）**<br>**</li><li>balanced_resource_allocation 从节点列表中选出各项资源使用率最均衡的节点（CPU和内存）</li><li>node_prefer_avoid_pods 节点倾向</li><li>taint_toleration 将pod对象的spec.toleration与节点的taints列表项进行匹配度检查，匹配的条目越多，得分越低。</li><li>selector_spreading 与services上其他pod尽量不在同一个节点上，节点上通一个service的pod越少得分越高。</li><li>interpod_affinity 遍历node上的亲和性条目，匹配项越多的得分越高</li><li>most_requested 选择消耗最大的节点上（尽量将一个节点上的资源用完）</li><li>node_label 根据节点标签得分，存在标签既得分，没有标签没得分。标签越多 得分越高。</li><li>image_locality 节点上有所需要的镜像既得分，所需镜像越多得分越高。（根据已有镜像体积大小之和）</li></ul><h2 id="高级调度方式"><a href="#高级调度方式" class="headerlink" title="高级调度方式"></a>高级调度方式</h2><p>当我们想把调度到预期的节点，我们可以使用高级调度分为：</p><ul><li>节点选择器： nodeSelector、nodeName</li><li>节点亲和性调度： nodeAffinity</li><li>Pod亲和性调度：PodAffinity</li><li>Pod反亲和性调度：podAntiAffinity</li></ul><h3 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h3><p>我们定义一个pod,让其选择带有node=ssd这个标签的节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-1</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  nodeSelector:</span><br><span class="line">    node: ssdkubectl apply -f test.yaml</span><br></pre></td></tr></table></figure><p>查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#get一下pod 一直处于Pending状态</span><br><span class="line">$ kubectl get pod </span><br><span class="line">NAME      READY     STATUS    RESTARTS   AGE</span><br><span class="line">pod-1     0&#x2F;1       Pending   0          7s</span><br><span class="line">#查看详细信息,是没有可用的selector</span><br><span class="line">$ kubectl describe pod pod-1</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  9s (x14 over 36s)  default-scheduler  0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line">#我们给node2打上这个标签</span><br><span class="line">$  kubectl label node k8s-node02 node&#x3D;ssd</span><br><span class="line">node&#x2F;k8s-node02 labeled</span><br><span class="line">#Pod正常启动</span><br><span class="line">$  kubectl describe pod pod-1</span><br><span class="line">....</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From                 Message</span><br><span class="line">  ----     ------            ----               ----                 -------</span><br><span class="line">  Warning  FailedScheduling  2m (x122 over 8m)  default-scheduler    0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line">  Normal   Pulled            7s                 kubelet, k8s-node02  Container image &quot;ikubernetes&#x2F;myapp:v1&quot; already present on machine</span><br><span class="line">  Normal   Created           7s                 kubelet, k8s-node02  Created container</span><br><span class="line">  Normal   Started           7s                 kubelet, k8s-node02  Started container</span><br></pre></td></tr></table></figure><h3 id="nodeAffinity"><a href="#nodeAffinity" class="headerlink" title="nodeAffinity"></a>nodeAffinity</h3><p>kubectl explain pod.spec.affinity.nodeAffinity </p><ul><li>requiredDuringSchedulingIgnoredDuringExecution 硬亲和性 必须满足亲和性。<ul><li>matchExpressions 匹配表达式,这个标签可以指定一段，例如pod中定义的key为zone，operator为In(包含那些)，values为 foo和bar。就是在node节点中包含foo和bar的标签中调度</li><li>matchFields 匹配字段 和上面的意思 不过他可以不定义标签值，可以定义</li></ul></li><li>preferredDuringSchedulingIgnoredDuringExecution  软亲和性 能满足最好，不满足也没关系。<ul><li>preference 优先级</li><li>weight 权重1-100范围内，对于满足所有调度要求的每个节点，调度程序将通过迭代此字段的元素计算总和，并在节点与对应的节点匹配时将“权重”添加到总和。</li></ul></li></ul><p>运算符包含：<code>In</code>，<code>NotIn</code>，<code>Exists</code>，<code>DoesNotExist</code>，<code>Gt</code>，<code>Lt</code>。可以使用<code>NotIn</code>和<code>DoesNotExist</code>实现节点反关联行为。</p><p>硬亲和性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - foo</span><br><span class="line">            - bar</span><br><span class="line">$ kubectl apply -f pod-affinity-demo.yaml </span><br><span class="line">$ kubectl describe pod node-affinity-pod </span><br><span class="line">.....</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  33s (x25 over 1m)  default-scheduler  0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line"># 给其中一个node打上foo的标签</span><br><span class="line">$ kubectl label node k8s-node03 zone&#x3D;foo</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                READY     STATUS    RESTARTS   AGE</span><br><span class="line">node-affinity-pod   1&#x2F;1       Running   0          8m</span><br></pre></td></tr></table></figure><p> 软亲和性：</p><p>与requiredDuringSchedulingIgnoredDuringExecution比较，这里需要注意的是preferredDuringSchedulingIgnoredDuringExecution是个列表项，而preference不是一个列表项了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod-2</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 50</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - foo</span><br><span class="line">            - bar$ kubectl get pod -o wide NAME                  READY     STATUS    RESTARTS   AGE       IP           NODEnode-affinity-pod     1&#x2F;1       Running   0          3h        10.244.3.2   k8s-node03node-affinity-pod-2   1&#x2F;1       Running   0          1m        10.244.3.3   k8s-node03</span><br></pre></td></tr></table></figure><h3 id="podAffinity"><a href="#podAffinity" class="headerlink" title="podAffinity"></a>podAffinity</h3><p>Pod亲和性场景，我们的k8s集群的节点分布在不同的区域或者不同的机房，当服务A和服务B要求部署在同一个区域或者同一机房的时候，我们就需要亲和性调度了。</p><p>kubectl explain pod.spec.affinity.podAffinity 和NodeAffinity是一样的，都是有硬亲和性和软亲和性</p><p>硬亲和性：</p><ul><li>labelSelector 选择跟那组Pod亲和</li><li>namespaces 选择哪个命名空间</li><li>topologyKey 指定节点上的哪个键</li></ul><p>样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod1</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: service</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod2</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: front</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - podaffinity-myapp</span><br><span class="line">        topologyKey: kubernetes.io&#x2F;hostname </span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide </span><br><span class="line">NAME                  READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">node-affinity-pod1    1&#x2F;1       Running   0          12s       10.244.2.6   k8s-node02</span><br><span class="line">node-affinity-pod2    1&#x2F;1       Running   0          12s       10.244.2.5   k8s-node02</span><br></pre></td></tr></table></figure><h3 id="podAntiAffinity"><a href="#podAntiAffinity" class="headerlink" title="podAntiAffinity"></a>podAntiAffinity</h3><p>Pod反亲和性场景，当应用服务A和数据库服务B要求尽量不要在同一台节点上的时候。</p><p> kubectl explain pod.spec.affinity.podAntiAffinity 也分为硬反亲和性和软反亲和性调度（和podAffinity一样的配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#首先把两个node打上同一个标签。</span><br><span class="line">kubectl label node k8s-node02 zone&#x3D;foo </span><br><span class="line">kubectl label node k8s-node03 zone&#x3D;foo</span><br><span class="line">#反硬亲和调度</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod1</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: service</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod2</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: front</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - podaffinity-myapp</span><br><span class="line">        topologyKey: zone</span><br></pre></td></tr></table></figure><p>查看一下(因为zone这个key在每个node都有会，所以第二个Pod没有办法调度，所以一直Pending状态)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get  pod </span><br><span class="line">NAME                 READY     STATUS    RESTARTS   AGE</span><br><span class="line">node-affinity-pod1   1&#x2F;1       Running   0          11s</span><br><span class="line">node-affinity-pod2   0&#x2F;1       Pending   0          11s</span><br></pre></td></tr></table></figure><h3 id="污点容忍调度（Taint和Toleration）"><a href="#污点容忍调度（Taint和Toleration）" class="headerlink" title="污点容忍调度（Taint和Toleration）"></a>污点容忍调度（Taint和Toleration）</h3><p>前两种方式都是pod选择那个pod，而污点调度是node选择的pod，污点就是定义在节点上的键值属性数据。举要作用是让节点拒绝pod，拒绝不合法node规则的pod。Taint（污点）和 Toleration（容忍）是相互配合的，可以用来避免 pod 被分配到不合适的节点上,每个节点上都可以应用<strong>一个或多个</strong> taint ，这表示对于那些不能容忍这些 taint 的 pod，是不会被该节点接受的。</p><h4 id="Taint"><a href="#Taint" class="headerlink" title="Taint"></a>Taint</h4><p>Taint是节点上属性，我们看一下Taints如何定义</p><p>kubectl explain node.spec.taints（对象列表）</p><ul><li>key 定义一个key</li><li>value 定义一个值</li><li>effect pod不能容忍这个污点时，他的行为是什么，行为分为三种：NoSchedule 仅影响调度过程，对现存的pod不影响。PreferNoSchedule 系统将<em>尽量</em>避免放置不容忍节点上污点的pod，但这不是必需的。就是软版的NoSchedule NoExecute 既影响调度过程，也影响现存的pod，不满足的pod将被驱逐。</li></ul><h4 id="node-打-taint"><a href="#node-打-taint" class="headerlink" title="node 打 taint"></a>node 打 taint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint NODE NAME KEY_1&#x3D;VAL_1:TAINT_EFFECT_1 ... KEY_N&#x3D;VAL_N:TAINT_EFFECT_N [options]</span><br><span class="line">增加taint</span><br><span class="line">kubectl  taint node k8s-node02 node-type&#x3D;prod:NoSchedule</span><br><span class="line">删除taint</span><br><span class="line">kubectl  taint node k8s-node02 node-type:NoSchedule-</span><br></pre></td></tr></table></figure><h4 id="tolerations"><a href="#tolerations" class="headerlink" title="tolerations"></a>tolerations</h4><ul><li>key 被容忍的key</li><li>tolerationSeconds 被驱逐的宽限时间，默认是0 就是立即被驱逐</li><li>value 被容忍key的值</li><li>operator Exists只要key在就可以调度，Equal（等值比较）必须是值要相同</li><li>effect 节点调度后的操作</li></ul><p>创建一个容忍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-deploy</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">      release: dev</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myapp</span><br><span class="line">        release: dev</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myapp-containers</span><br><span class="line">        image: ikubernetes&#x2F;myapp:v2</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: &quot;node-type&quot;</span><br><span class="line">        operator: &quot;Equal&quot;</span><br><span class="line">        value: &quot;prod&quot;</span><br><span class="line">        effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s控制台rancher</title>
      <link href="2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0rancher/"/>
      <url>2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0rancher/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> rancher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s控制台Dashboard</title>
      <link href="2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/"/>
      <url>2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.51cto.com/happylab">Happy老师</a></p><p>出处：[<a href="https://blog.51cto.com/happylab/2496756]">https://blog.51cto.com/happylab/2496756]</a>(</p><h2 id="kubernetes-dashboard简介"><a href="#kubernetes-dashboard简介" class="headerlink" title="kubernetes-dashboard简介"></a>kubernetes-dashboard简介</h2><p>kubernetes中管理集群中资源的方式通常有四种：命令行、YAML、API和图形界面，四种不同的方式适用于不同的人群和场景，对比如下：</p><ul><li>命令行kubectl，kubectl提供了命令行管理kubernetes资源<ul><li>优点：使用方便、便捷、快速管理集群资源</li><li>缺点：功能相对有限，部分操作无法支持，有一定的门槛</li></ul></li><li>YAML资源定义，kubernetes中最终转换形式，推荐使用方式<ul><li>优点：功能齐备，能够定义kubernetes的所有对象和资源</li><li>缺点：门槛较高，需要具备专业技术能力，使用排障难度大</li></ul></li><li>API管理接入，提供各种编程语言SDK接口，方便各种编程语言应用程序接入<ul><li>优点：适配各种编程语言，如Java，Go，Python，C等，方便开发kubernetes</li><li>缺点：门槛较高，适用于开发人员</li></ul></li><li>图形kubernetes-dashboard，提供图形化管理界面，能够利用metric-server实现node和pod的监控<ul><li>优点：使用简单，便捷，适合大众。</li><li>缺点：功能相对简单，功能原生，适用于demo</li></ul></li></ul><h2 id="kubernetes-dashboard安装"><a href="#kubernetes-dashboard安装" class="headerlink" title="**kubernetes-**dashboard安装"></a>**kubernetes-**dashboard安装</h2><p>社区提供了kubernetes-dashbaord的YAML资源定义文件，直接下载YAML文件安装即可实现dashboard的安装接入，需要准备条件如下：</p><ul><li>已安装好的kubernetes集群，本文环境为1.15.3</li><li>metric-server监控，node监控和pod监控视图需依赖于监控系统</li><li>RBAC认证授权，设置好账户并授予访问权限</li></ul><p>1、下载kubernetes-dashboard安装文件并应用YAML资源定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard configured</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard unchanged</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br></pre></td></tr></table></figure><p>安装文件中定义了dashboard相关的资源，可以查阅YAML文件，资源包含有：</p><ul><li>kubernetes-dashboard命名空间</li><li>ServiceAccount访问用户</li><li>Service服务访问应用，默认为ClusterIP</li><li>Secrets，存放有kubernetes-dashboard-certs，kubernetes-dashboard-csrf，kubernetes-dashboard-key-holder证书</li><li>ConfigMap配置文件</li><li>RBAC认证授权，包含有Role，ClusterRole，RoleBinding，ClusterRoleBinding</li><li>Deployments应用，kubernetes-dashboard核心镜像，还有一个和监控集成的dashboard-metrics-scraper</li></ul><p>2、校验资源的安装情况，kubernetes-dashbaord的资源都安装在kubernetes-dashboard命名空间下,包含有Deployments，Services，Secrets，ConfigMap等</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/1.gif"></p><p>3、kubernetes-dashbaord安装完毕后，kubernetes-dashboard默认service的类型为ClusterIP，为了从外部访问控制面板，开放为NodePort类型</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/2.gif"></p><p>4、此时通过https协议访问30433端口即可打开dashboard的控制台，为了保护数据安全性，集群默认开启了RBAC认证授权，需要授予权限的用户才可以访问到kubernetes集群，因此需要授权用户访问集群，集群中已定有了cluster-admin的角色和相关的Role，ClusterRole和ClusterRoleBinding角色，定义ServiceAccount将其关联即可，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# cat dashboard-rbac.yaml </span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: happycloudlab </span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: happycloudlab</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: happycloudlab</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>5、应用RBAC规则，创建一个happycloudlab的用户，并和cluster-admin的角色关联</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# kubectl apply -f dashboard-rbac.yaml </span><br><span class="line">serviceaccount/happycloudlab created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/happylau created</span><br><span class="line">[root@node-1 ~]# kubectl get serviceaccounts -n kubernetes-dashboard </span><br><span class="line">NAME                   SECRETS   AGE</span><br><span class="line"><span class="keyword">default</span>                <span class="number">1</span>         <span class="number">114</span>m</span><br><span class="line">happycloudlab   <span class="number">1</span>         <span class="number">8</span>s</span><br><span class="line">kubernetes-dashboard   <span class="number">1</span>         <span class="number">114</span>m</span><br></pre></td></tr></table></figure><p>6、此时通过kubernetes-dashboard-csrf服务会自动创建一个和用户名关联的Secrets，通过token字段来登陆，token通过base64加密，解密后即可登录，如下演示登录的过程<img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/3.gif"></p><p>自此，kubernetes-dashboard安装完毕，通过RBAC认证授权特定用户访问集群权限，接下来一起探索dashboard带来的魔力吧。</p><h2 id="探索kubernetes-dashboard"><a href="#探索kubernetes-dashboard" class="headerlink" title="探索kubernetes-dashboard"></a>探索<strong>kubernetes-dashboard</strong></h2><p>kubernetes-dashboard图形工具能提供以下功能：</p><ul><li>查看kubernetes中的资源对象，包含kubernetes中各种资源<ul><li>Cluster 集群级别的资源，如命名空间，节点，PV，StorageClass，ClusterRole等</li><li>Workloads，不同类型的工作负载，包含Deployments，StatefulSets，DaemonSets，Jobs等</li><li>Discovery and LoadBalancing，服务发现和负载均衡，包含service和ingress</li><li>ConfigMap and Storage，包含ConfigMap，Secrets和PVC</li><li>Costom Resource Definition，自定义资源定义</li></ul></li><li>kubernetes资源监控，调用metric-server监控系统，实现Cluster集群，Workloads应用负载，存储等资源的监控</li><li>管理资源对象，包含创建，编辑yaml，删除负载等，主要是以Deployments等应用为主的管理</li></ul><p>1、查看集群整体概览资源，可以看到整体集群，应用负载，Pod资源的资源使用情况</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/4.gif" alt="资源概览"></p><p>2、Cluster集群资源管理，包含还有Nodes，Namespace，StorageClass等，提供在线编辑yaml方式</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/5.gif" alt="集群资源"></p><p>3、查看应用工作负载Workloads，包含各种不同的工作负载如Deployments，StatefulSets，Jobs等</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/6.gif" alt="工作负载"></p><p>4、部署Deployments工作负载，支持从YAML文件输入，YAML文件加载和图形界面部署应用</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/7.gif" alt="部署工作负载"></p><p>5、工作负载管理，扩展工作负载副本数目，滚动更新等</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/8.gif" alt="扩展副本+滚动更新"></p><p>6、远程登录容器和查看容器日志</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/9.gif" alt="登录容器和查看日志"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>kubernetes-dashboard提供了原生的k8s管理工具，提供一个便捷的可视化界面，方便使用控制台管理k8s资源，dashboard提供的功能相对原生，企业可以根据公司的需求通过api进行二次开发，以满足需求。对于k8s管理员而言，一般以使用命令行或yaml文件为主。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>dashboard安装手册：<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p><p>RBAC认证授权：<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p><p><a href="https://www.jianshu.com/p/40c0405811ee">k8s Dashboard部署</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络</title>
      <link href="2020/11/30/k8s%E7%BD%91%E7%BB%9C/"/>
      <url>2020/11/30/k8s%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s基础</title>
      <link href="2020/11/30/k8s%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/30/k8s%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.51cto.com/happylab">Happy老师</a></p><p>出处：<a href="https://blog.51cto.com/happylab/2496756">https://blog.51cto.com/happylab/2496756</a></p><h2 id="kubernetes简介与功能"><a href="#kubernetes简介与功能" class="headerlink" title="kubernetes简介与功能"></a>kubernetes简介与功能</h2><p>Kubernetes是google开源的一套微服务，容器化的编排引擎，提供容器话应用的自动化部署，横向扩展和管理，是google内部容器十多年实战沉淀的结晶，已战胜Swarm，Mesos成为容器编排的行业标准。</p><p>三大容器编排引擎：</p><ul><li>Swarm Docker原生提供的容器化编排引擎，随着docker支持kubernetes逐渐废弃</li><li>Mesos 结合Marathon提供容器调度编排的能力，还能提供其他framwork的调度</li><li>Kubernetes 已成为容器编排引擎的唯一标准，越来越多程序支持kubernetes。</li></ul><p>kuberntes内置有很多非常优秀的特性使开发者专注于业务本身，其包含的功能如下：</p><p><img src="/2020/11/30/k8s%E5%9F%BA%E7%A1%80/c23e352655b2ddd6d7e9fffd224accc9.png" alt="kubernetes入门到实战（一）初窥kubernetes全貌"></p><ul><li>Service discovery and load balancing，服务发现和负载均衡，通过DNS实现内部解析，service实现负载均衡</li><li>Storage orchestration，存储编排，通过plungin的形式支持多种存储，如本地，nfs，ceph，公有云快存储等</li><li>Automated rollouts and rollbacks，自动发布与回滚，通过匹配当前状态与目标状态一致，更新失败时可回滚</li><li>Automatic bin packing，自动资源调度，可以设置pod调度的所需（requests）资源和限制资源（limits）</li><li>Self-healing，内置的健康检查策略，自动发现和处理集群内的异常，更换，需重启的pod节点</li><li>Secret and configuration management，密钥和配置管理，对于敏感信息如密码，账号的那个通过secret存储，应用的配置文件通过configmap存储，避免将配置文件固定在镜像中，增加容器编排的灵活性</li><li>Batch execution，批处理执行，通过job和cronjob提供单次批处理任务和循环计划任务功能的实现</li><li>Horizontal scaling,横向扩展功能，包含有HPA和AS，即应用的基于CPU利用率的弹性伸缩和基于平台级的弹性伸缩，如自动增加node和删除nodes节点。</li></ul><h2 id="kubernetes架构解析"><a href="#kubernetes架构解析" class="headerlink" title="kubernetes架构解析"></a>kubernetes架构解析</h2><p><img src="/2020/11/30/k8s%E5%9F%BA%E7%A1%80/9b512f2d62081a5fa35d8266f5c03a78.png" alt="kubernetes组件"></p><p>kubernetes包含两种角色：master节点和node节点，master节点是集群的控制管理节点，作为整个k8s集群的大脑。</p><ul><li>负责集群所有接入请求(kube-apiserver)，在整个集群的入口；</li><li>集群资源调度(kube-controller-scheduler)，通过watch监视pod的创建，负责将pod调度到合适的node节点；</li><li>集群状态的一致性(kube-controller-manager)，通过多种控制器确保集群的一致性，包含有Node Controller，Replication Controller，Endpoints Controller等；</li><li>元数据信息存储(etcd)，数据持久存储化，存储集群中包括node，pod，rc，service等数据；</li></ul><p>node节点是实际的工作节点，负责集群负载的实际运行，即pod运行的载体，其通常包含三个组件：Container Runtime，kubelet和kube-proxy</p><ul><li>Container Runtime是容器运行时，负责实现container生命周期管理，如docker，containerd，rktlet；</li><li>kubelet负责镜像和pod的管理，</li><li>kube-proxy是service服务实现的抽象，负责维护和转发pod的路由，实现集群内部和外部网络的访问。</li></ul><p>其他组件还包括：</p><ul><li>cloud-controller-manager，用于公有云的接入实现，提供节点管理(node)，路由管理，服务管理(LoadBalancer和Ingress)，存储管理(Volume，如云盘，NAS接入)，需要由公有云厂商实现具体的细节，kubernetes提供实现接口的接入，如腾讯云目前提供CVM的node管理，节点的弹性伸缩(AS),负载均衡的接入(CLB),存储的管理(CBS和CFS)等产品的集成；</li><li>DNS组件由kube-dns或coredns实现集群内的名称解析；</li><li>kubernetes-dashboard用于图形界面管理；</li><li>kubectl命令行工具进行API交互；</li><li>服务外部接入，通过ingress实现七层接入，由多种controller控制器组成<ul><li>traefik</li><li>nginx ingress controller</li><li>haproxy ingress controller</li><li>公有云厂商ingress controller</li></ul></li><li>监控系统用于采集node和pod的监控数据<ul><li>metric-server 核心指标监控</li><li>prometheus 自定义指标监控，提供丰富功能</li><li>heapster+influxdb+grafana 旧核心指标监控方案，现已废弃</li></ul></li><li>日志采集系统，用于收集容器的业务数据,实现日志的采集，存储和展示，由EFK实现<ul><li>Fluentd 日志采集</li><li>ElasticSearch 日志存储+检索</li><li>Kiabana 数据展示</li></ul></li></ul><h2 id="kubernetes生态"><a href="#kubernetes生态" class="headerlink" title="kubernetes生态"></a>kubernetes生态</h2><p><a href="https://landscape.cncf.io/">https://landscape.cncf.io/</a></p><h2 id="kubernetes高可用架构"><a href="#kubernetes高可用架构" class="headerlink" title="kubernetes高可用架构"></a>kubernetes高可用架构</h2><p>kubernetes高可用集群通常由3或5个节点组成高可用集群，需要保障各个节点的高可用性</p><ul><li>etcd 内置集群机制，保障数据持久存储</li><li>kube-apiserver 无状态api服务，有负载均衡调度器做负载分发，如haproxy或nginx</li><li>kube-scheduler 内置选举机制，保障调度器高可用，确保同个时刻一个leader节点工作，其他处于阻塞，防止脑裂</li><li>kube-controller-manager 内置的选举机制保障控制器高可用，机制和kube-scheduler一致。<br><img src="/2020/11/30/k8s%E5%9F%BA%E7%A1%80/61235bc58859458922f5ab4f6484ed99.jpg" alt="kubernetes入门到实战（一）初窥kubernetes全貌"></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li>kubernetes功能介绍，<a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></li><li>kubernetes组件介绍<a href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker网络</title>
      <link href="2020/11/30/docker%E7%BD%91%E7%BB%9C/"/>
      <url>2020/11/30/docker%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="docker网络知识"><a href="#docker网络知识" class="headerlink" title="docker网络知识"></a>docker网络知识</h2><h3 id="docker网络类型（–network指定网络）"><a href="#docker网络类型（–network指定网络）" class="headerlink" title="docker网络类型（–network指定网络）"></a>docker网络类型（–network指定网络）</h3><ul><li><p>bridge  默认连接到docker0这个网桥上</p></li><li><p>none 容器只能使用127.0.0.1的本机网络</p></li><li><p>host 与宿主机共享ip</p></li><li><p>link  docker run -it –name vm5 –link vm1:db1 ubuntu 创建一个容器vm5，并使用link方式连接vm1,此时的vm1的是容器名，db1是容器的别名</p></li><li><p>container 网络模式，必须同一个宿主机</p></li><li><p>自定义网络模式：</p><ul><li>bridge network  可以通过容器名互通，单一主机上运行一个相对小的网络，使用桥接网络</li><li>overlay network  创建一个大网络，可以通过overlay 网络来实现</li><li>MACVLAN network</li><li>network plugin</li><li>remote network</li></ul></li><li><p>跨主机docker容器通信方案介绍（就是自定义网络下的方案，除开bridge）</p><ul><li><p>隧道（Overlay Networking）方案：</p><ul><li>  Weave：UDP广播，本机建立新的BR，通过PCAP互通。</li><li>  Open vSwitch(OVS)：基于VxLAN和GRE协议，但是性能方面损失比较严重。</li><li>  Flannel：UDP广播，VxLan。  </li></ul></li><li><p>路由方案</p><ul><li>  Calico：基于BGP协议的路由方案，支持很细致的ACL控制，对混合云亲和度比较高。</li><li>  Macvlan：从逻辑和Kernel层来看隔离性和性能最优的方案，基于二层隔离，所以需要二层路由器支持，大多数云服务商不支持，所以混合云上比较难以实现。</li></ul></li></ul></li></ul><p><code>    隧道方案在IaaS层的网络中应用也比较多，大家共识是随着节点规模的增长复杂度会提升，而且出了网络问题跟踪起来比较麻烦，大规模集群情况下这是需要考虑的一个点。</code></p><p><code>    路由方案一般是从3层或者2层实现隔离和跨主机容器互通的，出了问题也很容易排查。</code></p><h5 id="bridge-模式的网络。其特点如下："><a href="#bridge-模式的网络。其特点如下：" class="headerlink" title="bridge 模式的网络。其特点如下："></a>bridge 模式的网络。其特点如下：</h5><ul><li>  使用一个 linux bridge，默认为 docker0</li><li>  使用 veth 对，一头在容器的网络 namespace 中，一头在 docker0 上</li><li>  该模式下Docker Container不具有一个公有IP，因为宿主机的IP地址与vethpair的 IP地址不在同一个网段内</li><li>  Docker采用NAT网络地址转换(Network Address Translation)方式，将容器内部的服务监听的端口与宿主机的某一个端口port 进行“绑定”，使得宿主机以外的世界可以主动将网络报文发送至容器内部</li><li>  外界访问容器内的服务时，需要访问宿主机的 IP 以及宿主机的端口 port</li><li>  NAT 模式由于是在三层网络上的实现手段，故肯定会影响网络的传输效率。</li><li>容器拥有独立、隔离的网络栈；让容器和宿主机以外的世界通过NAT建立通信<br>  <img src="/2020/11/30/docker%E7%BD%91%E7%BB%9C/bridge_20201013104542.png" alt="输入图片描述"></li></ul><h5 id="主要使用的网络模式"><a href="#主要使用的网络模式" class="headerlink" title="主要使用的网络模式"></a>主要使用的网络模式</h5><ul><li>Libnetwork 从Docker核心代码中分离出去，形成一个单独的库</li><li>Flannel CoreOS团队针对Kubernetes设计的一个重载网络工具，它的主要思路是：预先留出一个网段，每个主机使用其中一部分，然后每个容器被分配不同的ip；让所有的容器认为大家在同一个直连的网络，底层通过UDP/VxLAN等进行报文的封装和转发</li><li>Calico 是一个纯3层的数据中心网络方案，而且无缝集成像OpenStack这种IaaS云架构，能够提供可控的VM、容器、裸机之间的IP通信</li></ul><p><a href="https://www.jianshu.com/p/d84cdfe2ea86">详细网络知识</a><br><a href="https://blog.csdn.net/dhaiuda/article/details/82824333">docker的overlay网络</a></p><h3 id="docker网络操作"><a href="#docker网络操作" class="headerlink" title="docker网络操作"></a>docker网络操作</h3><ul><li>docker network ls            查看docker网卡</li><li>docker network rm 网卡id    删除docker网卡</li><li>docker network inspect 网卡id   查看docker网卡的相关详细信息</li><li>创建网络，如下使用–subnet创建网络（用来指定ip段），–gateway（用来指定网关），my_net3为创建的名字：<br>docker network create –driver bridge –subnet 172.22.1.0/24 –gateway 172.22.1.1 my_net3</li></ul><h3 id="设置主机名和DNS"><a href="#设置主机名和DNS" class="headerlink" title="设置主机名和DNS"></a>设置主机名和DNS</h3><p>docker run -it –name mycon -h lion –dns=8.8.8.8 ubuntu:14.04</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="2020/11/30/docker%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/30/docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Docker提供了一种将应用程序安全，隔离运行的一种方式，能够将应用程序依赖和库文件打包在一个容器中，后续再任何地方运行起来即可，其包含了应用程序所依赖相关环境，一次构建，任意运行（build once，run anywhere）</p><h2 id="Docker-包括三个基本概念"><a href="#Docker-包括三个基本概念" class="headerlink" title="Docker 包括三个基本概念"></a>Docker 包括三个基本概念</h2><ul><li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。<br>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li></ul><p>Docker容器通过Docker镜像来创建。</p><h2 id="Docker原理"><a href="#Docker原理" class="headerlink" title="Docker原理"></a>Docker原理</h2><img src="/2020/11/30/docker%E5%9F%BA%E7%A1%80/6d20ecb467fa6d571d7dd74fe0187f07.png" alt="docker架构" style="zoom: 50%;"><table><thead><tr><th align="left">概念</th><th>说明</th></tr></thead><tbody><tr><td align="left">Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td align="left">Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td align="left">Docker Daemon</td><td>容器管理组件，守护进程，负载容器，镜像，存储，网络等管理</td></tr><tr><td align="left">Docker 客户端(Client)</td><td>Docker客户端通过命令行或者其他工具使用 <a href="https://docs.docker.com/develop/sdk/">Docker SDK </a> 与Docker的守护进程（Docker Daemon）通信</td></tr><tr><td align="left">Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="left">Docker Registry</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。容器镜像仓库，负责存储，分发，打包</td></tr><tr><td align="left">Docker Object</td><td>容器对象，主要包含container和images</td></tr><tr><td align="left">Docker Machine</td><td>是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，<br>比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr><tr><td align="left">docker swarm</td><td>Swarm 集群中每台 Docker 主机称为一个节点。集群管理，容器编排项目</td></tr><tr><td align="left">docker compose</td><td>容器编排项目，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具</td></tr></tbody></table><p><a href="https://hub.docker.com/">Docker Hub</a> 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><h2 id="容器优缺点"><a href="#容器优缺点" class="headerlink" title="容器优缺点"></a>容器优缺点</h2><p>容器给应用程序开发环境带来很大的便利，从根本上解决了容器的环境依赖，打包等问题，然而，Docker带来的容器打包的便利，同时也带来了以下的挑战：</p><ul><li><p>容器如何调度，分发</p></li><li><p>多台机器如何协同工作</p></li><li><p>Docker主机故障时应用如何恢复</p></li><li><p>如何保障应用高可用，横向扩展，动态伸缩</p></li></ul><img src="/2020/11/30/docker%E5%9F%BA%E7%A1%80/875f955cc9bb7b51036b58e59a2763bb.png" alt="容器挑战" style="zoom:50%;"><h2 id="docker容器命令"><a href="#docker容器命令" class="headerlink" title="docker容器命令"></a>docker容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -q </span><br><span class="line">docker container stop|start|rm nginx</span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx-test -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it nginx sh|bash</span><br></pre></td></tr></table></figure><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p><a href="https://www.runoob.com/docker/docker-dockerfile.html" title="dockerfile描述文件细节">如何写dockerfile文件</a></p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>容器编排工具 <a href="https://www.runoob.com/docker/docker-compose.html" title="docker-compose描述文件细节">如何写docker-compose.yml</a></p><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d //后台运行</span><br><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h2 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker swarm"></a>docker swarm</h2><p>Swarm 集群中每台 Docker 主机称为一个节点。其中主动初始化一个 Swarm 集群的节点称为管理节点（Manager），加入一个Swarm 集群的节点称为工作节点（Worker Node）。工作节点是任务执行节点，管理节点将任务下发至工作节点执行。管理节点默认也作为工作节点。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader</p><p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p><p>swarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。<br>work node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</p><h4 id="基本实用命令"><a href="#基本实用命令" class="headerlink" title="基本实用命令"></a>基本实用命令</h4><ul><li>docker swarm init –advertise-addr 192.168.58.144</li><li>docker swarm join 。。。</li><li>docker swarm leave –f</li><li>docker node ls</li><li>docker node ls –filter role=worker</li><li>docker node ls –filter role=manager</li><li>docker node update swarm02 –role=worker //将swarm02节点降级为worker节点</li><li>docker service inspect mynginx</li><li>docker service create –replicas 3 -p 8888:80 –name mynginx nginx</li><li>docker service rm mynginx</li><li>docker stack rm getstartedlab</li><li>docker stack deploy -c docker-compose.yml getstartedlab</li></ul><h4 id="docker-service"><a href="#docker-service" class="headerlink" title="docker service"></a>docker service</h4><p>与docker swarm一起使用，docker service部署的是单个服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 3 -p 8888:80 --name mynginx nginx</span><br></pre></td></tr></table></figure><h4 id="Docker-Stack"><a href="#Docker-Stack" class="headerlink" title="Docker Stack"></a>Docker Stack</h4><p>与docker swarm一起使用，使用docker-compose.yml配置文件，进行多服务编排部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stack  deploy -c docker-compose1.yml phpadmin</span><br><span class="line"></span><br><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure><h4 id="Swarm-Service网络模型"><a href="#Swarm-Service网络模型" class="headerlink" title="Swarm Service网络模型"></a>Swarm Service网络模型</h4><ul><li><strong>Overlay networks</strong> 管理 Swarm 中 Docker 守护进程间的通信。你可以将服务附加到一个或多个已存在的 overlay 网络上，使得服务与服务之间能够通信。</li><li><strong>ingress network</strong> 是一个特殊的 overlay 网络，用于服务节点间的负载均衡。当任何 Swarm 节点在发布的端口上接收到请求时，它将该请求交给一个名为 IPVS 的模块。IPVS 跟踪参与该服务的所有IP地址，选择其中的一个，并通过 ingress 网络将请求路由到它。<br>初始化或加入 Swarm 集群时会自动创建 ingress 网络，大多数情况下，用户不需要自定义配置，但是 docker 17.05 和更高版本允许你自定义。</li><li><strong>docker_gwbridge</strong>是一种桥接网络，将 overlay 网络（包括 ingress 网络）连接到一个单独的 Docker 守护进程的物理网络。默认情况下，服务正在运行的每个容器都连接到本地 Docker 守护进程主机的 docker_gwbridge 网络。<br>docker_gwbridge 网络在初始化或加入 Swarm 时自动创建。大多数情况下，用户不需要自定义配置，但是 Docker 允许自定义。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create</span><br><span class="line">docker network connect</span><br><span class="line">docker network ls</span><br><span class="line">docker network rm</span><br><span class="line">docker network disconnect</span><br><span class="line">docker network inspect</span><br><span class="line">docker run --rm --network=host alpine ifconfig</span><br></pre></td></tr></table></figure><h4 id="swarm编排工具的控制台docker-portainer"><a href="#swarm编排工具的控制台docker-portainer" class="headerlink" title="swarm编排工具的控制台docker portainer"></a>swarm编排工具的控制台docker portainer</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--constraint &#x27;node.role == manager&#x27; \</span><br><span class="line">--mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><h2 id="docker-compose与docker-swarm区别"><a href="#docker-compose与docker-swarm区别" class="headerlink" title="docker compose与docker swarm区别"></a>docker compose与docker swarm区别</h2><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合</p><h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>创建Docker主机（开放远程2375端口 安装docker）</p><ul><li>docker-machine create -d hyperv –hyperv-virtual-switch “myswitch” myvm2</li><li>docker-machine env myvm3</li><li>docker-machine ssh myvm1</li><li>docker-machine ls</li><li>docker-machine stop</li><li>docker-machine start</li><li>docker-machine env</li><li>docker-machine regenerate-certs</li></ul><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基础</title>
      <link href="2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>消息队列可以实现流量削峰、降低系统耦合度、提高系统性能等。</p><p><strong>RabbitMQ</strong>是一个实现了AMQP协议（Advanced Message Queue Protocol）的消息队列。</p><h2 id="RabbitMQ中的概念"><a href="#RabbitMQ中的概念" class="headerlink" title="RabbitMQ中的概念"></a><strong>RabbitMQ中的概念</strong></h2><ul><li><strong>producer</strong>： producer 是一个发送消息的应用</li><li><strong>exchange</strong>：producer并不会直接将消息发送到 queue 上，而是将消息发送给exchange，由exchange按照一定规则转发给指定queue</li><li><strong>queue</strong>： queue 用来存储 producer 发送的消息</li><li><strong>consumer</strong>： consumer是接收并处理消息的应用</li><li><strong>routing key</strong>：发送消息时绑定的路由key</li><li><strong>binding key</strong>：队列与交换机绑定的key</li><li><strong>consumerTag</strong>: 消费者标签，同一个会话， consumerTag 是固定的 可以做此会话的名字。</li><li><strong>consumer</strong>：消费者，extends DefaultConsumer。一个channel上可以配置多个consumer，真正的接收消息类，有处理消息的方法</li><li><strong>Envelope</strong>：可以获取交换机及routingKey信息和deliveryTag</li><li><strong>deliveryTag</strong>： deliveryTag 每次接收消息+1，可以做此消息处理通道的名字。用来回传告诉 rabbitmq 这个消息处理成功 清除此消息</li><li><strong>BasicProperties</strong>：基本属性，如Header中的信息。</li><li><strong>Delivery</strong>：封装了Envelope，BasicProperties及字节数组消息</li></ul><h2 id="Exchanges交换机"><a href="#Exchanges交换机" class="headerlink" title="Exchanges交换机"></a>Exchanges交换机</h2><p><strong>默认Exchange(RabbitMQ自带的Direct交换机，没有名称，与所有队列相连)**：比较Message的routing key和Queue的名字，完全匹配时，Message才会发送到该Queue<br><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/1-1607999220900.gif" style="zoom:80%;"><br>**Direct Exchange</strong>：比较Message的routing key和Queue的binding key，完全匹配时，Message才会发送到该Queue<br><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/2.gif" style="zoom:80%;"><br><strong>Fanout Exchange</strong>：忽略key对比，发送Message到Exchange下游绑定的所有Queue<br><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/1.gif" style="zoom: 80%;"><br><strong>Topic Exchange</strong>：比较Message的routing key和Queue的binding key，按规则匹配成功时，Message才会发送到该Queue</p><ul><li><strong>routing key命名规则</strong>：用”.”分割的字母或数字</li><li><strong>匹配规则</strong>：<ul><li>*：匹配单个字母或数字</li><li>#：匹配0~多个字母或数字</li><li>比如：*.stock.#与usd.stock、eur.stock.db匹配；但与stock.nasdaq不匹配<br><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/640" alt="img"></li></ul></li></ul><p><strong>Headers Exchange</strong>：比较队列上带有的Headers的键值对是否和发送的消息Message对象带的message是否匹配，通过Headers上的键值对判断是使用全匹配还是包含匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headerMap.put(<span class="string">&quot;x-match&quot;</span>, (matchAll ? <span class="string">&quot;all&quot;</span> : <span class="string">&quot;any&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h2><ul><li>存放消息</li><li>消息消费监听，监听的是队列，和其它如交换机没有关联</li></ul><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><ul><li>生产者指定Message的routing key，并指定Message发送到哪个Exchange</li><li>Queue会通过binding key绑定到指定的Exchange</li><li>Exchange根据对比Message的routing key和Queue的binding key，然后按一定的分发路由规则，决定Message发送到哪个Queue</li></ul><h2 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h2><p>​    监听指定队列，消息push到消费者端。spring的监听注解会自动创建不存在的交换机，队列，及绑定key。</p><h3 id="消息队列有两种工作方式"><a href="#消息队列有两种工作方式" class="headerlink" title="消息队列有两种工作方式"></a>消息队列有两种工作方式</h3><ul><li><p>轮询分发(默认)默认Spring是获取250个数据，RabbitMQ官方建议是30</p></li><li><p>公平分发即当某个消费者没有消费完成之前不用再分发消息。当执行时间增长的时候验证是否正确</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者每次从队列获取的消息数量。此属性当不设置时为：轮询分发，设置为1为：公平分发</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;direct.queue&quot;), exchange = @Exchange(value = &quot;direct.exchange&quot;), key = &quot;HelloWorld&quot;)&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDirectMessage</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 模拟异常</span></span><br><span class="line">            String is = <span class="keyword">null</span>;</span><br><span class="line">            is.toString();</span><br><span class="line">            <span class="comment">// 确认收到消息，false只确认当前consumer一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已重复处理失败,拒绝再次接收&quot;</span> + user.getName());</span><br><span class="line">                <span class="comment">// 拒绝消息，requeue=false 表示不再重新入队，如果配置了死信队列则进入死信队列</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息即将再次返回队列处理&quot;</span> + user.getName());</span><br><span class="line">                <span class="comment">// requeue为是否重新回到队列，true重新入队</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDirectMessageCopy</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;--jxb--MQConsumer--getDirectMessageCopy：&quot;</span> + user.toString());</span><br><span class="line">            <span class="comment">// 确认收到消息，false只确认当前consumer一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已重复处理失败,拒绝再次接收！&quot;</span>);</span><br><span class="line">                <span class="comment">// 拒绝消息，requeue=false 表示不再重新入队，如果配置了死信队列则进入死信队列</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息即将再次返回队列处理！&quot;</span>);</span><br><span class="line">                <span class="comment">// requeue为是否重新回到队列，true重新入队</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h2><p>​    主动拉取队列里的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(ConnectionUtils.QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h2 id="基本AIPI"><a href="#基本AIPI" class="headerlink" title="基本AIPI"></a>基本AIPI</h2><p><strong>channel.exchangeDeclare()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type：有direct、fanout、topic三种</span><br><span class="line">durable：true：服务器重启会保留下来Exchange。警告：仅设置此选项，不代表消息持久化。即不保证重启后消息还在。</span><br><span class="line">autoDelete: true:当已经没有消费者时，服务器是否可以删除该Exchange。</span><br></pre></td></tr></table></figure><p><strong>chanel.exchangeBind()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);</span><br><span class="line">用于通过绑定bindingKey将queue到Exchange，之后便可以进行消息接收</span><br></pre></td></tr></table></figure><p><strong>channel.queueDeclare(QUEUE_NAME, false, false, false, null);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">durable：true：在服务器重启时，能够存活</span><br><span class="line">exclusive ：是否为当前连接的专用队列，在连接断开后，会自动删除该队列，生产环境中应该很少用到吧。</span><br><span class="line">autodelete：当没有任何消费者使用时，自动删除该队列。this means that the queue will be deleted when there are no more processes consuming messages from it.</span><br></pre></td></tr></table></figure><p><strong>chanel.basicQos()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prefetchSize：0 目前好像没有作用，至少rabbitmq3.8.5不能使用，报错</span><br><span class="line">prefetchCount：会告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack。是服务端属性，通过rpc方法调用，存在服务端，客户端不需要使用</span><br><span class="line">global：true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别的还是consumer级别。如果true并且prefetchCount为4，有二个消费者，此时每个消费者可以读取到二条。如果为fasle，每个消费者获取到4条数据</span><br></pre></td></tr></table></figure><p><strong>channel.basicPublish()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routingKey：路由键，#匹配0个或多个单词，*匹配一个单词，在topic exchange做消息转发用</span><br><span class="line">mandatory：true：如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue，那么会调用basic.return方法将消息返还给生产者。false：出现上述情形broker会直接将消息扔掉</span><br><span class="line">immediate：true：如果exchange在将消息route到queue(s)时发现对应的queue上没有消费者，那么这条消息不会放入队列中。当与消息routeKey关联的所有queue(一个或多个)都没有消费者时，该消息会通过basic.return方法返还给生产者。</span><br><span class="line">BasicProperties ：需要注意的是BasicProperties.deliveryMode，0:不持久化 1：持久化 这里指的是消息的持久化，配合channel(durable&#x3D;true),queue(durable)可以实现，即使服务器宕机，消息仍然保留</span><br><span class="line">简单来说：mandatory标志告诉服务器至少将该消息route到一个队列中，否则将消息返还给生产者；immediate标志告诉服务器如果该消息关联的queue上有消费者，则马上将消息投递给它，如果所有queue都没有消费者，直接把消息返还给生产者，不用将消息入队列等待消费者了。</span><br></pre></td></tr></table></figure><p><strong>channel.basicAck();</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息。</span><br></pre></td></tr></table></figure><p><strong>channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">multiple：是否批量.true:将一次性拒绝所有小于deliveryTag的消息。</span><br><span class="line">requeue：被拒绝的是否重新入队列</span><br></pre></td></tr></table></figure><p><strong>channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">requeue：被拒绝的是否重新入队列</span><br><span class="line">channel.basicNack 与 channel.basicReject 的区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</span><br></pre></td></tr></table></figure><p><strong>channel.basicConsume(QUEUE_NAME, true, consumer);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</span><br></pre></td></tr></table></figure><p><strong>channel.basicGet(ConnectionUtils.QUEUE_NAME, false);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><strong>Connection与Channel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createChannel();</span><br></pre></td></tr></table></figure><p>一个连接可以创建多个Channel</p><p><strong>Channel与消费者Consume</strong></p><p>一个Channel上可以设置多个Consume,因此可以设置最大值，Spring中通过设置concurrency和max-concurrency配置消费者个数</p><p><strong>prefetchSize、prefetchCount、Global</strong></p><p>spring中有prefetch即prefetchCount，batch-size。取最大值设置为prefetchCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue</span><br><span class="line"><span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">InternalConsumer consumer = <span class="keyword">new</span> InternalConsumer(<span class="keyword">this</span>.channel, queue);</span><br><span class="line">String consumerTag = <span class="keyword">this</span>.channel.basicConsume(queue, <span class="keyword">this</span>.acknowledgeMode.isAutoAck(),</span><br><span class="line">                                               (<span class="keyword">this</span>.tagStrategy != <span class="keyword">null</span> ? <span class="keyword">this</span>.tagStrategy.createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="keyword">this</span>.noLocal,</span><br><span class="line">                                               <span class="keyword">this</span>.exclusive, <span class="keyword">this</span>.consumerArgs,</span><br><span class="line">                                               consumer);</span><br></pre></td></tr></table></figure><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（三）之数据结构总章</title>
      <link href="2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/"/>
      <url>2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><p>数组（数组、循环数组）查找、更新可以通过下标，时间复杂度为O(1);插入、删除需要移动数据在数组的位置O(n)</p><p><strong>基本操作</strong>：读取元素，更新元素，插入元素，删除元素（涉及数组元素移动位置，取巧方式：将最后一个元素更新删除元素）</p></li><li><p>链表（单向链表、双向链表、循环链表）查找需要一直向下查找，时间复杂度为O(n);插入、删除、更新指针变动即可O(1)</p><p><strong>基本操作</strong>：查找节点，更新节点，插入节点，删除节点</p><p><img src="/2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/image-20201201102615715.png" alt="image-20201201102615715"></p></li><li><p>栈（Stack）：FILO（First In Last Out，先入后出），最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作栈顶（top）。可以使用数组或链表来实现。时间复杂度都是O(1)</p><p><strong>基本操作</strong>：入栈push（从栈顶压入元素），出栈pop（从栈顶弹出元素）</p></li><li><p>队列（queue，单向队列，双端队列，优先队列，堵塞队列）：FIFO（First In First Out，先进先出），队列的出口端叫作队头（front），队列的入口端叫作队尾（rear）。可以使用数组或链表来实现。时间复杂度都是O(1)。数组实现队列会导致空间越来越小，可以使用循环数组。</p><p><strong>基本操作</strong>：入队enqueue（从队尾插入元素），出队dequeue（从对头移出元素）</p><table><thead><tr><th>对比项</th><th>作用及示例</th></tr></thead><tbody><tr><td>栈的应用</td><td>栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。<br>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。<br>栈还有一个著名的应用场景是面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面。</td></tr><tr><td>队列的应用</td><td>队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。<br>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。<br>再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的</td></tr></tbody></table><p><font color="red"><strong>双端队列（deque）</strong></font>：既可以先入先出，也可以先入后出。从队头一端可以入队或出队，从队尾一端也可以入队或出队</p><p><font color="red"><strong>优先队列</strong></font>：它遵循的不是先入先出，而是谁的优先级最高，谁先出队。优先队列已经<strong>不属于线性数据结构的范畴</strong>了，它是<strong>基于二叉堆来实现的</strong></p></li><li><p>散列表：也叫哈希表（Hash table），提供了键（Key）和值（Value）的映射关系,只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于O(1)。<font color="red">散列表可以说是数组和链表的结合。</font></p><p><strong>基本操作</strong>：写操作put,读操作get,扩容resize</p><p><strong>哈希冲突（哈希碰撞）</strong>解决方法：</p><p>​        <strong>开放寻址法</strong>：当一个Key通过哈希函数获得对应的数组下标已被占用时，我们可以“另谋高就”，寻找下一个空档位置，一直向下找。在Java中，ThreadLocal所使用的就是开放寻址法</p><p>​        <strong>链表法</strong>：应用在了Java的集合类HashMap当中，数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可</p></li><li><p>树（tree,二叉树、二叉查找树（排序树）、平衡二叉树、红黑树、B-树、B+树）是n（n≥0）个节点的有限集。当n=0时，称为空树。</p><p>树–&gt;二叉树–&gt;完全二叉树–&gt;满二叉树–&gt;二叉堆–&gt;二叉查找树（排序树）</p></li><li><p>图（？）</p></li></ul><h2 id="java数据结构"><a href="#java数据结构" class="headerlink" title="java数据结构"></a>java数据结构</h2><p>见java集合文章</p><h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序 存储，访问方式是随机访问。利用下标查找数组元素的时间复杂度是O(1)，中间插入、删除数组元素的时间复杂度是O(n)。 </p><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查找链表节点的时间 复杂度是O(n)，中间插入、删除节点的时间复杂度是O(1)。 </p><h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p>栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和 出栈操作，遵循先入后出的原则（FILO）。 </p><h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。 </p><h2 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h2><p>散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作。散列表通过哈希函数实现Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突</p><h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><p>树是n个节点的有限集，有且仅有一个特定的称为根的节点。当n&gt;1时，其余节点可分为m个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 </p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点。二叉树包含完全二叉树和满二叉树两种特殊形式。 </p><h2 id="二叉树的遍历方式有几种"><a href="#二叉树的遍历方式有几种" class="headerlink" title="二叉树的遍历方式有几种"></a>二叉树的遍历方式有几种</h2><p>根据遍历节点之间的关系，可以分为前序遍历、中序遍历、后序遍历、层序遍历这4种方式；从更宏观的角度划分，可以划分为深度优先遍历和广度优先遍历两大类。</p><h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。<br>在最大堆中，任何一个父节点的值，都大于或等于它左、右孩子节点的值。<br>在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的值。 </p><h2 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h2><p>优先队列分为最大优先队列和最小优先队列。<br>在最大优先队列中，无论入队顺序如何，当前最大的元素都会优先出队，这是基于最大堆实现的。<br>在最小优先队列中，无论入队顺序如何，当前最小的元素都会优先出队，这是基于最小堆实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（二）</title>
      <link href="2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211111476.png" alt="img" style="zoom: 67%;"><h2 id="数据结构内容"><a href="#数据结构内容" class="headerlink" title="数据结构内容"></a>数据结构内容</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211129378.png" alt="img" style="zoom: 67%;"><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/201901212111451.png" alt="img" style="zoom: 67%;"><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201124212642358.png" alt="image-20201124212642358" style="zoom:50%;"><h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><p>大多数以数组和链表作为存储方式，因此物理结构为：</p><ul><li>顺序存储结构 （一段连续的内存空间。随机访问效率高；插入删除效率低，大小固定，可以扩容）</li><li>链式存储结构（不连续的内存空间。大小动态扩展，插入删除效率高；不能随机访问）</li><li>散列存储结构（为了方便查找，整体无序，但索引块之间有序，需要额外空间，存储索引表。对顺序查找的一种改进，查找效率高；需额外空间存储索引）</li><li>索引存储结构（选取某个函数，数据元素根据函数计算存储位置可能存在多个数据元素存储在同一位置，引起地址冲。查找基于数据本身即可找到，查找效率高，存取效率高。存取随机，不便于顺序查找）</li></ul><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是抽象的概念，它依赖于物理结构而存在。是对数据元素之间存在的逻辑关系的描述。分为二大类：线性结构和非线性结构。细分为四种：</p><ul><li><p>线性结构（线性结构中的数据元素之间是一对一的关系。注意：<font color="red">重点在一对一</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103023829.png" alt="image-20201125103023829" style="zoom: 33%;"></li><li><p>集合结构（就是数据元素同属一个集合，单个数据元素之间<font color="red">没有任何关系</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125102951179.png" alt="image-20201125102951179" style="zoom: 33%;"></li><li><p>树形结构（树形结构中的数据元素之间存在一对多的关系。各元素及元素关系所组成图形类似于树状图。注意：<font color="red">关系为一对多</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103039123.png" alt="image-20201125103039123" style="zoom: 33%;"></li><li><p>图形结构（数据元素之间是<font color="red">多对多的关系</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103056213.png" alt="image-20201125103056213" style="zoom: 33%;"></li></ul><p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211307827.png" alt="img"></p><p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211350180.png" alt="img"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_39385118/article/details/80835048">数据结构之逻辑结构与物理结构（存储结构）</a></p><p><a href="https://blog.csdn.net/qq_41523096/article/details/86566982">《数据结构》| 第一章 绪论 知识梳理</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（一）</title>
      <link href="2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>在数学领域里，算法是用于解决某一类问题的公式和思想。</li><li>在计算机科学领域，算法的本质是一系列程序指令，用于解决特定的运算和逻辑问题。是对特定问题求解方法（步骤）的一种描述，是指令的有限序列，其中每一条指令表示一个或多个操作。</li></ul><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125100745940.png" alt="image-20201125100745940"></p><h2 id="算法的设计目标"><a href="#算法的设计目标" class="headerlink" title="算法的设计目标"></a>算法的设计目标</h2><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125101019149.png" alt="image-20201125101019149"></p><h2 id="算法标准"><a href="#算法标准" class="headerlink" title="算法标准"></a>算法标准</h2><p>在计算机领域，我们同样会遇到各种高效和拙劣的算法。衡量算法好坏的重要标准有两个。 </p><ul><li>时间复杂度</li><li>空间复杂度</li></ul><h2 id="算法的应用领域"><a href="#算法的应用领域" class="headerlink" title="算法的应用领域"></a>算法的应用领域</h2><p>算法可以应用在很多不同的领域中，其应用场景更是多种多样。</p><ul><li>运算（如最大公约数）</li><li>查找（搜索引擎，Mysql查询）</li><li>排序（电商商品排序，排名）。排序算法是实现诸多复杂程序的基石</li><li>最优决策（如找出最佳路线，有限背包存价值最高物品使用动态规划算法）</li><li>面试（主要时为了它，不然学它干嘛）</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构，对应的英文单词是data structure，是数据的组织、管理和存储格式， 其使用目的是为了高效地访问和修改数据。</p><h2 id="数据结构组成方式"><a href="#数据结构组成方式" class="headerlink" title="数据结构组成方式"></a>数据结构组成方式</h2><ul><li>线性结构（最简单的数据结构，包含数组，链表及由它们衍生的栈、队列、哈希表）</li><li>树（树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构）</li><li>图（图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系）</li><li>其他数据结构（除上述基本数据结构外，还有其它千奇百怪的数据结构。由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等）</li></ul><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>有了数据结构这个舞台，算法才可以尽情舞蹈。在解决问题时，不同的算法会选用不同的数据结构。例如排序算法中的堆排序，利用的就是二叉堆这样一种数据结构；再如缓存淘汰算法LRU（Least Recently Used，最近最少使用），利用的就是特殊数据结构哈希链表。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>基本操作执行次数的函数T(n),若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。 <font color="red">因为渐进时间复杂度用大写O来表示，所以也被称为大O表示法。</font> </p><p>直白地讲，时间复杂度就是把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是n、n2、n3等。</p><p>时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作T(n)=O(f(n))。</p><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125101210140.png" alt="image-20201125101210140"></p><h2 id="推导出时间复杂度原则"><a href="#推导出时间复杂度原则" class="headerlink" title="推导出时间复杂度原则"></a>推导出时间复杂度原则</h2><ul><li><p>如果运行时间是常数量级，则用常数1表示 </p></li><li><p>只保留时间函数中的最高阶项 </p></li><li><p>如果最高阶项存在，则省去最高阶项前面的系数</p></li></ul><h2 id="不同时间复杂度"><a href="#不同时间复杂度" class="headerlink" title="不同时间复杂度"></a>不同时间复杂度</h2><ul><li><p>多项式时间算法的时间复杂度：O(1)&lt;O(log<del>2</del>n)&lt;O(n)&lt;O(nlog<del>2</del>n)&lt;O(n^2^) &lt;O(n^3^)</p></li><li><p>指数时间算法的时间复杂度：O(2^n^)&lt;O(n!)&lt;O(n^n^)</p></li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中<font color="red"><strong>临时占用存储空间大小的量度</strong></font>，它同样使用了大O表示法。程序占用空间大小的计算公式记作S(n)=O(f(n))，其中n为问题的规模，f(n)为算法所占存储空间的函数。 <font color="red">空间复杂度就离不开数据结构。</font></p><h2 id="不同空间复杂度"><a href="#不同空间复杂度" class="headerlink" title="不同空间复杂度"></a>不同空间复杂度</h2><ul><li><p>常量空间（当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1)）</p></li><li><p>线性空间（当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];&#125;</span><br></pre></td></tr></table></figure></li><li><p>二维空间（当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n^2^)）</p></li><li><p>递归空间（递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。空间复杂度就是O(n)）</p></li></ul><h2 id="时间与空间的取舍"><a href="#时间与空间的取舍" class="headerlink" title="时间与空间的取舍"></a>时间与空间的取舍</h2><p>在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间，也要提升程序的执行速度。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataSource介绍及对比</title>
      <link href="2020/11/23/DataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/"/>
      <url>2020/11/23/DataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>DriverManager通过getConnection方法获取的连接，<font color="red">是建立与数据库的连接</font>。但是建立与数据库的连接是一项较耗资源的工作，频繁的进行数据库连接建立操作会产生较大的系统开销。</p><p>随着企业级应用复杂度的提升以及对性能要求的提高，这一点是难以接受的。</p><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p><strong>既然每次使用时都重新建立与数据库之间的连接，会产生较大的系统开销。是否可以事先创建一些连接备用，当需要时，从这些连接中选择一个提供出去；当连接使用完毕后，并不是真正的关闭，而是将这些数据状态还原，然后继续等待下一个人使用</strong></p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>DriverManager只是建立与数据库之间的连接，如何才能将连接池的概念应用其中？</p><p><strong>一种很自然的方式就是提供一个薄层的封装，建立一个中间层，这个中间层将DriverManager生成的连接，组织到连接池中，然后从池中提供连接</strong></p><p><img src="/2020/11/23/DataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/897393-20190125140250476-31357459.png" alt="img"></p><p><strong>Data Source就是DriverManager的一种替代角色，对外呈现就类似于一个DriverManager，拥有对外提供连接的能力</strong></p><p>直接使用DriverManager，驱动程序与管理器是“服务者—管理者”的形式，借助于管理者才能提供服务。</p><p>Data Source将驱动程序的概念淡化了，突出驱动程序能够提供的服务与能力，将驱动程序提供的服务与能力抽象为Data Source数据源这一角色。</p><p><img src="/2020/11/23/DataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/897393-20190125140251236-665240055.png" alt="img"></p><p><strong>DataSource中获取的连接来自于连接池中，而池中的连接根本也还是从DriverManager获取而来</strong></p><p>有了数据源这一中间层，就可以实现连接池和分布式事务的管理。</p><p><strong>对外呈现DataSource就是类似于DriverManager的一个存在。</strong></p><p><strong>DataSource的形式是JNDI （Java Naming Directory Interface）</strong></p><p>DataSource是JNDI资源的一种，那么到底什么是JNDI呢</p><p>此处不过多解释，可以简单认为JNDI是类似这样一个东西：</p><p>一个哈希表，类型为&lt;String，Object&gt;</p><p>JNDI的两个最主要操作：bind和lookup。bind操作负责往哈希表里存对象，lookup则根据这个键值字符串往外取对象。</p><p>开发人员可以使用键值——也就是一个字符串名称——来获取某个对象。</p><p><strong>简言之就是可以给一个对象命名，然后可以通过名称找到这个对象。</strong></p><p><strong>数据源的概念在应用程序与数据库连接之间插入了一个中间层，进而可以实现连接池以及事务管理，并且以JNDI的形式，也能够以非常方便的形式使用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> DataSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC原理分析</title>
      <link href="2020/11/20/JDBC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>2020/11/20/JDBC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JDBC（Java Database Connection）,java提供的一套操作数据库的api。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><strong>java.sql包主要接口</strong></p><ul><li>DriverManager ：驱动管理，可以加载驱动，获取Connection（通过Driver），高版本自动加载驱动Driver</li><li>Driver ：获取Connection</li><li>Connection: 创建Statement </li><li>Statement: Statement为一条Sql语句生成执行计划</li><li>PreparedStatement: 预编译sql语句，更安全，字符串参数会自动被驱动器忽略；PreparedStatement用于使用绑定变量重用执行计划，对于批量处理可以大大提高效率，但是如果是一次性存取操作性能开销更大。</li><li>ResultSet：Statement调用执行方法返回的结果</li><li><font color="red">Warapper</font>: 重点，<strong>适配器类</strong>，提供的扩展接口，方法unwrap返回未适配的对象， 方法isWrapperFor返回是否适配 。Connetion，Statement，ResultSet都继承Warapper接口。把一个由第三方供应商提供的、非 JDBC 标准的接口包装成标准接口</li></ul><p><strong>javax.sql包主要接口</strong></p><ul><li>DataSource：基本数据源接口，返回普通Connection</li><li>ConnectionPoolDataSource：连接池数据源接口，返回连接池连接（PooledConnection）</li><li>XADataSource：XA事务数据源，分布式事务，返回XA事务连接池连接（XAConnection 继承PooledConnection）</li><li>PooledConnection：连接池连接</li><li>XAConnection：XA事务连接池连接</li><li>RowSet：继承ResultSet</li><li>RowSetEvent，RowSetListener</li><li>StatementEvent,StatementEventListener</li><li>ConnectionEvent,ConnectionEventListener</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Driver loaded&quot;</span>);</span><br><span class="line">        Connection connection = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost/javabook&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Databases connected&quot;</span>);</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(</span><br><span class="line">                <span class="string">&quot;select ?, ?, ? from Student where lastName = ?&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;firstName&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, <span class="string">&quot;mi&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">3</span>, <span class="string">&quot;lastName&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">4</span>, <span class="string">&quot;Smith&quot;</span>);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="number">1</span>) + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                    resultSet.getString(<span class="number">2</span>) + <span class="string">&quot;\t&quot;</span> + resultSet.getString(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> DataSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java获取ip地址</title>
      <link href="2020/11/19/java%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80/"/>
      <url>2020/11/19/java%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="获取服务器本地ip"><a href="#获取服务器本地ip" class="headerlink" title="获取服务器本地ip"></a>获取服务器本地ip</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getHostAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String hostAddress = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">      hostAddress = address.getHostAddress();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hostAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Enumeration&lt;NetworkInterface&gt; allNetInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">      InetAddress ip = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (allNetInterfaces.hasMoreElements()) &#123;</span><br><span class="line">        NetworkInterface netInterface = allNetInterfaces.nextElement();</span><br><span class="line">        <span class="keyword">if</span> (netInterface.isLoopback() || netInterface.isVirtual() || !netInterface.isUp()) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Enumeration&lt;InetAddress&gt; addresses = netInterface.getInetAddresses();</span><br><span class="line">        <span class="keyword">while</span> (addresses.hasMoreElements()) &#123;</span><br><span class="line">          ip = addresses.nextElement();</span><br><span class="line">          <span class="keyword">if</span> (ip != <span class="keyword">null</span> &amp;&amp; ip <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">            <span class="keyword">return</span> ip.getHostAddress();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;IP地址获取失败&quot;</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取http请求的ip地址"><a href="#获取http请求的ip地址" class="headerlink" title="获取http请求的ip地址"></a>获取http请求的ip地址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIpAddr</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String ipAddress = request.getHeader(<span class="string">&quot;x-forwarded-for&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getRemoteAddr();</span><br><span class="line">      <span class="keyword">if</span> (ipAddress.equals(<span class="string">&quot;127.0.0.1&quot;</span>) || ipAddress.equals(<span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//根据网卡取本机配置的IP</span></span><br><span class="line">        InetAddress inet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inet = InetAddress.getLocalHost();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ipAddress = inet.getHostAddress();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割</span></span><br><span class="line">    <span class="keyword">if</span> (ipAddress != <span class="keyword">null</span> &amp;&amp; ipAddress.length() &gt; <span class="number">15</span>) &#123; <span class="comment">//&quot;***.***.***.***&quot;.length() = 15</span></span><br><span class="line">      <span class="keyword">if</span> (ipAddress.indexOf(<span class="string">&quot;,&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipAddress = ipAddress.substring(<span class="number">0</span>, ipAddress.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ipAddress;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon自定义负载规则</title>
      <link href="2020/11/19/Ribbon%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99/"/>
      <url>2020/11/19/Ribbon%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="配置Ribbon，指定每个服务使用的配置"><a href="#配置Ribbon，指定每个服务使用的配置" class="headerlink" title="配置Ribbon，指定每个服务使用的配置"></a>配置Ribbon，指定每个服务使用的配置</h2><p>java注解方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(value = &#123;</span></span><br><span class="line"><span class="meta">    @RibbonClient(name = &quot;order-service&quot;,configuration = RibbonLoadbalancerConfiguration.class)</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">,defaultConfiguration = RibbonLoadbalancerConfiguration.class)</span></span><br></pre></td></tr></table></figure><p>也可以使用配置文件，相比java配置，优先级更高</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">order-service:</span> <span class="comment">#指定服务配置</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NIWSServerListClass:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span> <span class="comment">#指定ServerList的实现类</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#指定IRule的实现类</span></span><br><span class="line"><span class="attr">ribbon:</span> <span class="comment">#全局配置</span></span><br><span class="line"><span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">RibbonLoadbalancerConfiguration</span> <span class="comment">#指定IRule的实现类</span></span><br></pre></td></tr></table></figure><h2 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeRibbonRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">        <span class="comment">// 获取所有的服务</span></span><br><span class="line">        List&lt;Server&gt; servers = lb.getAllServers();</span><br><span class="line">        servers.forEach(server -&gt; logger.info(<span class="string">&quot;服务器端口号：&#123;&#125;&quot;</span>,server.getHostPort()));</span><br><span class="line">        String host = getIpAddress(); <span class="comment">//本机ip</span></span><br><span class="line">        <span class="keyword">return</span> servers.stream().filter(server -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> server.getHost().equals(host);</span><br><span class="line">        &#125;).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora高亮及快捷键设置</title>
      <link href="2020/11/19/typora%E9%AB%98%E4%BA%AE%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE/"/>
      <url>2020/11/19/typora%E9%AB%98%E4%BA%AE%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Typora的高亮模式默认是关闭的（需手动打开）"><a href="#1、Typora的高亮模式默认是关闭的（需手动打开）" class="headerlink" title="1、Typora的高亮模式默认是关闭的（需手动打开）"></a>1、Typora的高亮模式默认是关闭的（需手动打开）</h2><p>打开方式：文件 &gt; 偏好设置 &gt; Markdown &gt; Markdown扩展语法中把 <strong>高亮</strong> 选中 &gt; <strong>重启Typora</strong><br><img src="https://img-blog.csdnimg.cn/20200920101054257.gif#pic_left" alt="在这里插入图片描述"></p><h2 id="2、如何更改高亮配色？（高亮默认颜色是黄色-D3D40E）"><a href="#2、如何更改高亮配色？（高亮默认颜色是黄色-D3D40E）" class="headerlink" title="2、如何更改高亮配色？（高亮默认颜色是黄色#D3D40E）"></a>2、如何更改高亮配色？（高亮默认颜色是黄色#D3D40E）</h2><p>打开方式：文件 &gt; 偏好设置 &gt; 外观 &gt; 打开主题文件夹 &gt; <em>night.css</em>文件 &gt; Ctrl+F 搜索 mark &gt; 修改喜欢的 background(背景颜色) 和 color(字体颜色) 保存<br><img src="https://img-blog.csdnimg.cn/20200920104332324.gif#pic_left" alt="在这里插入图片描述"></p><h2 id="3、如何设置高亮快捷键"><a href="#3、如何设置高亮快捷键" class="headerlink" title="3、如何设置高亮快捷键"></a>3、如何设置高亮快捷键</h2><p>设置方式：文件 &gt; 偏好设置 &gt; 通用 &gt; 打开高级设置 &gt; 会看到两个<em>json</em>文件，打开其中一个 &gt; 在 “keyBinding” 中添加 <strong>“Highlight”:“Ctrl+Shift+H”</strong>&gt; 保存 &gt; 另一个json文件也在 “keyBinding” 中添加 <strong>“Highlight”:“Ctrl+Shift+H”</strong> &gt; 保存<br><img src="https://img-blog.csdnimg.cn/20200920110453114.gif#pic_left" alt="在这里插入图片描述"></p><h2 id="typora使用文档"><a href="#typora使用文档" class="headerlink" title="typora使用文档"></a>typora使用文档</h2><p><a href="https://blog.dontjudge.cn/post/%E5%9F%BA%E4%BA%8E-typora-%E7%9A%84-markdown-%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/#%E5%9F%BA%E4%BA%8E-typora-%E7%9A%84-markdown-%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99">基于 Typora 的 Markdown 文档编写</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora字体设置颜色</title>
      <link href="2020/11/19/typora%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/"/>
      <url>2020/11/19/typora%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://ispotu.blog.csdn.net/">ispotu</a></p><p>出处：<a href="https://blog.csdn.net/superit401/article/details/106344453/">https://blog.csdn.net/superit401/article/details/106344453/</a></p><p>typora没有直接设置字体颜色的功能，不能像word一样，选中字体直接设置想要的颜色。</p><p>下面第一种方法需安装软件AutoHotKey，操作还算简单；后两种方法都是偏技术的，对于非技术的小白可能有点困难。</p><h2 id="方案一：安装软件AutoHotKey（较简单）"><a href="#方案一：安装软件AutoHotKey（较简单）" class="headerlink" title="方案一：安装软件AutoHotKey（较简单）"></a>方案一：安装软件AutoHotKey（较简单）</h2><p>AutoHotKey是一款著名的windows系统快捷键设置的软件，轻便小巧。</p><p>官方下载: <a href="https://autohotkey.com/download/ahk-install.exe">https://autohotkey.com/download/ahk-install.exe</a></p><p> （1）先安装AutoHotKey</p><p>（2）打开记事本，把如下内容复制粘贴进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; Typora</span><br><span class="line">; 快捷增加字体颜色</span><br><span class="line">; SendInput &#123;Text&#125; 解决中文输入法问题</span><br><span class="line"></span><br><span class="line">#IfWinActive ahk_exe Typora.exe&#123;</span><br><span class="line">    ; Ctrl+Alt+O 橙色</span><br><span class="line">    ^!o::addFontColor(&quot;orange&quot;)</span><br><span class="line">    ; Ctrl+Alt+R 红色</span><br><span class="line">    ^!r::addFontColor(&quot;red&quot;)</span><br><span class="line">    ; Ctrl+Alt+B 浅蓝色</span><br><span class="line">    ^!b::addFontColor(&quot;cornflowerblue&quot;)</span><br><span class="line">&#125;</span><br><span class="line">; 快捷增加字体颜色</span><br><span class="line">addFontColor(color)&#123;</span><br><span class="line">    clipboard :&#x3D; &quot;&quot; ; 清空剪切板</span><br><span class="line">    Send &#123;ctrl down&#125;c&#123;ctrl up&#125; ; 复制</span><br><span class="line">    SendInput &#123;TEXT&#125;&lt;font color&#x3D;&#39;%color%&#39;&gt;</span><br><span class="line">    SendInput &#123;ctrl down&#125;v&#123;ctrl up&#125; ; 粘贴</span><br><span class="line">    If(clipboard &#x3D; &quot;&quot;)&#123;</span><br><span class="line">        SendInput &#123;TEXT&#125;&lt;&#x2F;font&gt; ; Typora 在这不会自动补充</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        SendInput &#123;TEXT&#125;&lt;&#x2F; ; Typora中自动补全标签</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）将文件保存为ahk后缀的文件，如TyporaHotKey.ahk</p><p>(4)双击运行</p><p>（5）在Typora软件里就可以使用快捷键：如按<code>Ctrl+Alt+O</code>添加橙色，Ctrl+Alt+R 红色，按<code>Ctrl+\</code>取消样式！</p><p>也可以右键 <code>MyHotkeyScript.ahk</code> 脚本文件，点击<code>Compile Script</code>编译脚本成<code>exe</code>程序，就可以不用下载<code>Autohotkey</code>在其他电脑上运行了。</p><p>上面脚本只写了橙色、红色、浅蓝三种颜色，你可以按需照例增加其他颜色或快捷方式！</p><h2 id="方案二：改html代码（懂前端技术超简单）"><a href="#方案二：改html代码（懂前端技术超简单）" class="headerlink" title="方案二：改html代码（懂前端技术超简单）"></a>方案二：改html代码（懂前端技术超简单）</h2><p>视图——开发者工具（Shift+F12），打开html代码调试模式</p><p> 按快捷键Shift+F12（可能还需要同时按住Fn）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;&quot;</span>&gt;</span>你要改色的文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照这个模板，改字体的style属性即可。</p><p>示例：</p><p>style=”color:red”</p><p>style=”color:maroon”</p><p>style=”color:fuchsia”</p><p>style=”color:brown”</p><p>style=”color:blue”</p><p>style=”color:aqua”</p><p>style=”color:green”</p><p>style=”color:orange”</p><p>style=”color:purple”</p><p>style=”color:white;background:black;”</p><p>style=”background:yellow”</p><p>style=”background:red”</p><p>style=”background:orange”</p><p>style=”color:white;background:green”</p><p>style=”color:white;background:blue”</p><p><img src="https://img-blog.csdnimg.cn/20200525225939274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyaXQ0MDE=,size_16,color_FFFFFF,t_70" alt="img"></p><h1 id="方案三：使用内联公式（复杂）"><a href="#方案三：使用内联公式（复杂）" class="headerlink" title="方案三：使用内联公式（复杂）"></a>方案三：使用内联公式（复杂）</h1><p><strong>1.开启使用内联公式</strong></p><p>文件——偏好设置（Ctrl+逗号）——Markdown——勾选“内联公式”——重启Typora</p><p><img src="https://img-blog.csdnimg.cn/20200525230147618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyaXQ0MDE=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>2.输入公式代码设置颜色</strong></p><p>输入$，按Esc键会自动在后面加上一个$，然后在这两个$之间输入公式。</p><p>如：</p><p><img src="https://img-blog.csdnimg.cn/20200525231636600.png" alt="img"></p><p>直接在typora里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;Magenta&#125;&#123;洋红色&#125; $:设置颜色为$\textcolor&#123;RedOrange&#125;&#123;橙红色&#125; $，设置字体颜色为$\textcolor&#123;Blue&#125;&#123;蓝色&#125; $。数学公式里各元素也能分别设置颜色：</span><br><span class="line">$\textcolor&#123;red&#125;&#123;\int_a^b&#125;\textcolor&#123;blue&#125;&#123;f(x)&#125;\textcolor&#123;green&#125;&#123;dx&#125;\textcolor&#123;brown&#125;&#123;&#x3D;c&#125;$</span><br></pre></td></tr></table></figure><p>文本颜色设置公式：</p><p><font color="red"><strong>$\textcolor{red}{这里输入你要改变颜色的文字} $</strong></font></p><h3 id="颜色公式代码大全："><a href="#颜色公式代码大全：" class="headerlink" title="颜色公式代码大全："></a>颜色公式代码大全：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;GreenYellow&#125;&#123;GreenYellow&#125; $</span><br><span class="line">$\textcolor&#123;Yellow&#125;&#123;Yellow&#125;$</span><br><span class="line">$\textcolor&#123;Goldenrod&#125;&#123;Goldenrod&#125; $</span><br><span class="line">$\textcolor&#123;Dandelion&#125;&#123;Dandelion&#125;$</span><br><span class="line">$\textcolor&#123;Apricot&#125;&#123;Apricot&#125; $</span><br><span class="line">$\textcolor&#123;Peach&#125;&#123;Peach&#125;$</span><br><span class="line">$\textcolor&#123;Melon&#125;&#123;Melon&#125; $</span><br><span class="line">$\textcolor&#123;YellowOrange&#125;&#123;YellowOrange&#125;$</span><br><span class="line">$\textcolor&#123;Orange&#125;&#123;Orange&#125; $</span><br><span class="line">$\textcolor&#123;BurntOrange&#125;&#123;BurntOrange&#125;$</span><br><span class="line">$\textcolor&#123;Bittersweet&#125;&#123;Bittersweet&#125;$</span><br><span class="line">$\textcolor&#123;RedOrange&#125;&#123;RedOrange&#125; $</span><br><span class="line">$\textcolor&#123;Mahogany&#125;&#123;Mahogany&#125;$</span><br><span class="line">$\textcolor&#123;Maroon&#125;&#123;Maroon&#125; $</span><br><span class="line">$\textcolor&#123;BrickRed&#125;&#123;BrickRed&#125;$</span><br><span class="line">$\textcolor&#123;Red&#125;&#123;Red&#125; $</span><br><span class="line">$\textcolor&#123;OrangeRed&#125;&#123;OrangeRed&#125;$</span><br><span class="line">$\textcolor&#123;RubineRed&#125;&#123;RubineRed&#125;$</span><br><span class="line">$\textcolor&#123;WildStrawberry&#125;&#123;WildStrawberry&#125;$</span><br><span class="line">$\textcolor&#123;Salmon&#125;&#123;Salmon&#125;$</span><br><span class="line">$\textcolor&#123;CarnationPink&#125;&#123;CarnationPink&#125;$</span><br><span class="line">$\textcolor&#123;Magenta&#125;&#123;Magenta&#125; $</span><br><span class="line">$\textcolor&#123;VioletRed&#125;&#123;VioletRed&#125;$</span><br><span class="line">$\textcolor&#123;Rhodamine&#125;&#123;Rhodamine&#125; $</span><br><span class="line">$\textcolor&#123;Mulberry&#125;&#123;Mulberry&#125;$</span><br><span class="line">$\textcolor&#123;RedViolet&#125;&#123;RedViolet&#125; $</span><br><span class="line">$\textcolor&#123;Fuchsia&#125;&#123;Fuchsia&#125;$</span><br><span class="line">$\textcolor&#123;Lavender&#125;&#123;Lavender&#125; $</span><br><span class="line">$\textcolor&#123;Thistle&#125;&#123;Thistle&#125;$</span><br><span class="line">$\textcolor&#123;Orchid&#125;&#123;Orchid&#125; $</span><br><span class="line">$\textcolor&#123;DarkOrchid&#125;&#123;DarkOrchid&#125;$</span><br><span class="line">$\textcolor&#123;Purple&#125;&#123;Purple&#125; $</span><br><span class="line">$\textcolor&#123;Plum&#125;&#123;Plum&#125;$</span><br><span class="line">$\textcolor&#123;Violet&#125;&#123;Violet&#125; $</span><br><span class="line">$\textcolor&#123;RoyalPurple&#125;&#123;RoyalPurple&#125;$</span><br><span class="line">$\textcolor&#123;BlueViolet&#125;&#123;BlueViolet&#125;$</span><br><span class="line">$\textcolor&#123;Periwinkle&#125;&#123;Periwinkle&#125;$</span><br><span class="line">$\textcolor&#123;CadetBlue&#125;&#123;CadetBlue&#125;$</span><br><span class="line">$\textcolor&#123;CornflowerBlue&#125;&#123;CornflowerBlue&#125;$</span><br><span class="line">$\textcolor&#123;MidnightBlue&#125;&#123;MidnightBlue&#125;$</span><br><span class="line">$\textcolor&#123;NavyBlue&#125;&#123;NavyBlue&#125; $</span><br><span class="line">$\textcolor&#123;RoyalBlue&#125;&#123;RoyalBlue&#125;$</span><br><span class="line">$\textcolor&#123;Blue&#125;&#123;Blue&#125; $</span><br><span class="line">$\textcolor&#123;Cerulean&#125;&#123;Cerulean&#125;$</span><br><span class="line">$\textcolor&#123;Cyan&#125;&#123;Cyan&#125; $</span><br><span class="line">$\textcolor&#123;ProcessBlue&#125;&#123;ProcessBlue&#125;$</span><br><span class="line">$\textcolor&#123;SkyBlue&#125;&#123;SkyBlue&#125; $</span><br><span class="line">$\textcolor&#123;Turquoise&#125;&#123;Turquoise&#125;$</span><br><span class="line">$\textcolor&#123;TealBlue&#125;&#123;TealBlue&#125; $</span><br><span class="line">$\textcolor&#123;Aquamarine&#125;&#123;Aquamarine&#125;$</span><br><span class="line">$\textcolor&#123;BlueGreen&#125;&#123;BlueGreen&#125; $</span><br><span class="line">$\textcolor&#123;Emerald&#125;&#123;Emerald&#125;$</span><br><span class="line">$\textcolor&#123;JungleGreen&#125;&#123;JungleGreen&#125;$</span><br><span class="line">$\textcolor&#123;SeaGreen&#125;&#123;SeaGreen&#125; $</span><br><span class="line">$\textcolor&#123;Green&#125;&#123;Green&#125;$</span><br><span class="line">$\textcolor&#123;ForestGreen&#125;&#123;ForestGreen&#125;$</span><br><span class="line">$\textcolor&#123;PineGreen&#125;&#123;PineGreen&#125; $</span><br><span class="line">$\textcolor&#123;LimeGreen&#125;&#123;LimeGreen&#125;$</span><br><span class="line">$\textcolor&#123;YellowGreen&#125;&#123;YellowGreen&#125;$</span><br><span class="line">$\textcolor&#123;SpringGreen&#125;&#123;SpringGreen&#125;$</span><br><span class="line">$\textcolor&#123;OliveGreen&#125;&#123;OliveGreen&#125;$</span><br><span class="line">$\textcolor&#123;RawSienna&#125;&#123;RawSienna&#125; $</span><br><span class="line">$\textcolor&#123;Sepia&#125;&#123;Sepia&#125;$</span><br><span class="line">$\textcolor&#123;Brown&#125;&#123;Brown&#125; $</span><br><span class="line">$\textcolor&#123;Tan&#125;&#123;Tan&#125;$</span><br><span class="line">$\textcolor&#123;Gray&#125;&#123;Gray&#125; $</span><br><span class="line">$\textcolor&#123;Black&#125;&#123;Black&#125;$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用next主题</title>
      <link href="2020/11/17/hexo%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98/"/>
      <url>2020/11/17/hexo%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="主题next"><a href="#主题next" class="headerlink" title="主题next"></a>主题next</h2><p><strong>下载next主题</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p><strong>根据要求修改主题下_config.yml配置</strong></p><p><a href="https://theme-next.js.org/docs/theme-settings/">next文档</a></p><h2 id="更复杂的自定义优化可以参考如下文章"><a href="#更复杂的自定义优化可以参考如下文章" class="headerlink" title="更复杂的自定义优化可以参考如下文章"></a>更复杂的自定义优化可以参考如下文章</h2><p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">Hexo博客优化之Next主题美化</a></p><p><a href="https://theme-next.js.org/docs/tag-plugins/mermaid.html">可以生成图形</a></p><p><a href="https://www.cnblogs.com/whiremapple/p/12419097.html">Hexo博客主题安装和优化（一）</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql进阶操作</title>
      <link href="2020/11/17/mysql%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/17/mysql%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="转储操作"><a href="#转储操作" class="headerlink" title="转储操作"></a>转储操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE table t_a (SELECT * from o_order limit 10);</span><br><span class="line">INSERT into t_a SELECT *,5 FROM o_order limit 10;</span><br></pre></td></tr></table></figure><p><strong>区别</strong></p><ol><li>第一个sql执行的时候，表t_a不能存在</li><li>第二个sql执行时，表必须存在，可以设置指定常量字段即二个表字段有差异</li></ol><h2 id="插入操作（可忽略或更新已存在）"><a href="#插入操作（可忽略或更新已存在）" class="headerlink" title="插入操作（可忽略或更新已存在）"></a>插入操作（可忽略或更新已存在）</h2><p><strong>1. insert into</strong>表示插入数据，数据库会检查主键（PrimaryKey）或者unique索引，如果出现重复会报错；</p><p><strong>2. insert ignore into</strong> table(name)  select  name from table2; 根据主键（PrimaryKey）或者unique索引判断，如果已存在则忽略数据，否则插入数据</p><p><strong>3. replace into</strong>表示插入替换数据，需求表中有PrimaryKey，或者unique索引的话，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样；</p><p>REPLACE语句会返回一个数，来指示受影响的行的数目。该数是被删除和被插入的行数的和。如果对于一个单行REPLACE该数为1，则一行被插入，同时没有行被删除。<br>如果该数大于1，则在新行被插入前，有一个或多个旧行被删除。如果表包含多个唯一索引，并且新行复制了在不同的唯一索引中的不同旧行的值，则有可能是一个单一行替换了多个旧行</p><p><strong>4. insert into … ON DUPLICATE KEY UPDATE</strong></p><p><strong>如果你插入的记录导致一个UNIQUE索引或者primary key(主键)出现重复，那么就会认为该条记录存在，则执行update语句而不是insert语句，反之，则执行insert语句而不是更新语句</strong></p><p>如果行作为新记录被插入，则受影响行的值为1；如果原有的记录被更新，则受影响行的值为2，如果更新的数据和已有的数据一模一样，则受影响的行数是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table testtb(</span><br><span class="line">  id int not null primary key,</span><br><span class="line">  name varchar(50),</span><br><span class="line">  age int</span><br><span class="line">);</span><br><span class="line">insert into testtb(id,name,age)values(1,&quot;bb&quot;,13);</span><br><span class="line">select * from testtb;</span><br><span class="line">insert ignore into testtb(id,name,age)values(1,&quot;aa&quot;,13);</span><br><span class="line">select * from testtb;&#x2F;&#x2F;仍是1，“bb”,13，因为id是主键，出现主键重复但使用了ignore则错误被忽略</span><br><span class="line">replace into testtb(id,name,age)values(1,&quot;aa&quot;,12);</span><br><span class="line">select * from testtb; &#x2F;&#x2F;数据变为1,&quot;aa&quot;,12</span><br><span class="line">insert into testtb(id, name, age) values (1,&#39;hui&#39;,30) ON DUPLICATE KEY UPDATE age &#x3D; age + 50; </span><br><span class="line">select * from testtb; &#x2F;&#x2F;数据变成1,&quot;aa&quot;,62</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本操作</title>
      <link href="2020/11/17/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/17/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h2><p>是一个代码审查管理工具，可以进行代码走读，审核入库，基于Git</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>开发人员和管理人员只需操作gerrit 就能完成所有的代码管理，提高开发和上线效率</p><h2 id="用户组分类"><a href="#用户组分类" class="headerlink" title="用户组分类"></a>用户组分类</h2><ul><li>backend-developers</li><li>backend-leaders</li></ul><blockquote><p>backend-developers组用户权限：<br>1, master分支代码查看，push, review +1 -2, abandon 自己的review。<br>2，自己定义分支全部控制权限</p></blockquote><blockquote><p>backend-leaders组用户权限：<br>1 ,master分支代码查看，push, review +2 -2, abandon , submit,<br>2, release 分支代码查看，push,  review +2 , -2, abandon, push merge, push without review<br>3，自己定义分支全部控制权限</p></blockquote><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><ul><li>master分支</li><li>release分支</li><li>个人分支或者长期功能开发分支</li></ul><ol><li>master分支主要作为代码review, 代码开发主分支</li><li>release分支只对leaders可见，里面包含敏感的配置文件信息，release分支同时作为一个长期稳定的上线版本分支，每一次上线后都需要打一个tag</li><li>一般开发任务不需要在gerrit上创建自己的分支，除非有长期的协同大功能开发。</li></ol><h3 id="开发人员前期环境准备"><a href="#开发人员前期环境准备" class="headerlink" title="开发人员前期环境准备"></a>开发人员前期环境准备</h3><blockquote><p>这里假定大家对git 常用命令 已经熟悉，这里只做gerrit部分的设置步骤</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">假定developer有了gerrit账号并设置了免密ssh,登录gerrit ，</span><br><span class="line"></span><br><span class="line">1, 找到Projects-&gt;List-&gt;BKD_quixmart2 , 复制 项目clone命令：</span><br><span class="line">&gt; git clone ssh:&#x2F;&#x2F;xxxx@192.168.16.81:29418&#x2F;BKD_quixmart2 &amp;&amp; scp -p -P 29418 xxxx@192.168.16.81:hooks&#x2F;commit-msg BKD_quixmart2&#x2F;.git&#x2F;hooks&#x2F;</span><br><span class="line">&gt; cd BKD_quixmart2</span><br><span class="line">&gt; git remote update</span><br><span class="line"></span><br><span class="line">clone下来的项目普通开发人员只能看到一个master分支，leaders可以看到master 和 relase分支.</span><br><span class="line"></span><br><span class="line">2, 设置Alas</span><br><span class="line">在~&#x2F;.gitconfig文件中添加：</span><br><span class="line">[alias]</span><br><span class="line">push-release &#x3D; push origin HEAD:refs&#x2F;for&#x2F;release</span><br><span class="line">push-review &#x3D; push origin HEAD:refs&#x2F;for&#x2F;master</span><br><span class="line">unpushed &#x3D; lo --branches --not --remotes --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative</span><br><span class="line">lg &#x3D; log --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative</span><br><span class="line">ca &#x3D; commit -a</span><br><span class="line">ci &#x3D; commit</span><br><span class="line">st &#x3D; status</span><br><span class="line">co &#x3D; checkout</span><br><span class="line">br &#x3D; branch </span><br></pre></td></tr></table></figure><h3 id="commit-message-格式"><a href="#commit-message-格式" class="headerlink" title="commit message 格式"></a>commit message 格式</h3><p>所有commit 格式都应该如下：</p><p>QUIX2-12: quixmart2.0 后台系统设备管理，设备监控开发</p><p>Change-Id: I6be1be65a4d9839555a7c27a217cdd063d1ad99b</p><h3 id="开发人员代码review步骤"><a href="#开发人员代码review步骤" class="headerlink" title="开发人员代码review步骤"></a>开发人员代码review步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">开发人员：</span><br><span class="line">&gt;git remote update</span><br><span class="line">&gt;git co master</span><br><span class="line">&gt;git fetch &amp;&amp; git rebase master     (不要用git pull)</span><br><span class="line">&gt;git checkout -b bugfix-QUIX2-12</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx1.java</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx2.java</span><br><span class="line">&gt;git commit -m &quot;QUIX2-12: quixmart2.0 后台系统设备管理，设备监控开发&quot;</span><br><span class="line">&gt;git push-review     （会自动提到gerrit的master分支）</span><br><span class="line">如果有修改内容</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx2.java</span><br><span class="line">&gt;git commit --amend</span><br><span class="line">&gt;git push-review</span><br><span class="line"></span><br><span class="line">到gerrit web 界面要求相关开发进行代码review,也可以自己-2，这样可以不被submit. review完成后leader可以进行submit</span><br><span class="line"></span><br><span class="line">如果是紧急hotfix, 在开发人员 master gerrit submit成功后，leader需要将这个commit 在gerrit上cherry-pick到release 分支并完成上线</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="稳定master代码同步到release分支"><a href="#稳定master代码同步到release分支" class="headerlink" title="稳定master代码同步到release分支"></a>稳定master代码同步到release分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;git co master</span><br><span class="line">&gt;git fetch &amp;&amp; git rebase</span><br><span class="line">&gt;git co release</span><br><span class="line">&gt;git merge master</span><br><span class="line">&gt;git push-release</span><br><span class="line">添加相关人员代码review,然后submit到gitlab仓库</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>禁止用  ‘git add .’   ， 必须用’git add src/xxx/xxx.xxx’</li><li>要修改新的代码前先更新master分支，然后通过master分支checkout 一个其他分支</li><li>尽量不要在本地的master上直接改代码，每次在改代码之前先更新本地master分支，然后  git checkout -b featrure-QUIX2-xxx, 在本地的feature-QUIX2-xxx 改完后再merge 到master 分支，如果在feature-QUIX2-xxx 分支有多次commit, merge 时如果想把所有commit 变成一个commit, 用git merge –squash feature-QUIX2-xxx , 否则正常merge 用 git merge –no-ff -m “merge with no-ff” feature-QUIX2-xxx ，或者直接在当前分支用git push-review 会自动推到gerrit 的master分支</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>git st 查看当前git 仓库状态</li><li>git lg 查看commit  (经常用，结合git reset 来回切换历史commit)</li><li>git unpushed 查看哪些还没有push到gitlab仓库,(用之前应该更新代码)</li><li>git fetch &amp;&amp; git rebase  master 更新代码及分支信息</li><li>git reset –hard origin 还原成远端git库最新代码</li><li>git reset –hard xxx 还原到指定commit </li><li>git branch</li><li>git clone</li></ul><h3 id="本地目录到暂存区操作"><a href="#本地目录到暂存区操作" class="headerlink" title="本地目录到暂存区操作"></a>本地目录到暂存区操作</h3><ul><li>git restore file|.   将不在暂存区的文件撤销更改</li><li>git restore –staged 将文件从暂存区撤出，但不会撤销文件的更改</li><li>git add 命令可将该本地区下文件添加到暂存区</li></ul><h3 id="暂存区到本地版本库操作"><a href="#暂存区到本地版本库操作" class="headerlink" title="暂存区到本地版本库操作"></a>暂存区到本地版本库操作</h3><ul><li>git commit 主要是将暂存区里的改动给提交到本地的版本库</li><li>git commit –amend 继续提交</li></ul><h3 id="本地版本库到远程库操作-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt"><a href="#本地版本库到远程库操作-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt" class="headerlink" title="本地版本库到远程库操作(git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;)"></a>本地版本库到远程库操作(git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;)</h3><ul><li>git push origin HEAD:refs/for/release</li><li>git push origin HEAD:refs/for/master</li><li>refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要</li></ul><h3 id="远程库到本地版本库操作"><a href="#远程库到本地版本库操作" class="headerlink" title="远程库到本地版本库操作"></a>远程库到本地版本库操作</h3><ul><li><p>git revert  commit-id-a  归还，复原，回退，这个操作是会改变分支记录的，因为产生了新的提交。git revert 是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西</p></li><li><p>git reset –hard origin 还原成远端git库最新代码，之后的日志记录被删除</p></li><li><p>git reset –hard xxx 还原到指定commit</p></li><li><p>git reset –soft 被回退的那些版本的修改会被放在暂存区，可以再次提交</p></li><li><p>git reset –mixed 默认选项，被回退的那些版本的修改会放在工作目录，可以先加到暂存区，然后再提交。</p></li><li><p>git cherry-pick</p></li><li><p>git checkout</p></li></ul><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><ul><li>git reset HEAD^ –soft         –soft 表示保留当前commit，重新commit</li><li>git reset HEAD^ –hard       –hard 表示丢弃当前add，重新add、commit</li><li>git reset –hard HEAD~x解决，x表示的就是在这之前已经有多少次的提交，这句命令的意思就是直接回退到x 个commit之前</li></ul><h2 id="git-fork"><a href="#git-fork" class="headerlink" title="git fork"></a>git fork</h2><p><strong>git remote -v</strong> 先clone项目到本地，此时查看项目的远程信息<br><strong>git remote add upstream</strong>  [fork的远程地址]   添加远程地址<br><strong>git pull|fetch upstream master</strong>  从fork远程更新<br><strong>git merge upstream/master</strong>  合并到本地master分支<br><strong>git push origin master</strong>  上传到自己git上</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin异常处理</title>
      <link href="2020/11/17/Fegin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2020/11/17/Fegin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/xiaominmin">xiaomin0322</a></p><p>出处：<a href="https://my.oschina.net/xiaominmin/blog/2986631">https://my.oschina.net/xiaominmin/blog/2986631</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近在项目开发中，使用 Feign 调用服务，当触发熔断机制时，遇到了以下问题：</p><ul><li>异常信息形如：<code>TestService#addRecord(ParamVO) failed and no fallback available.</code>；</li><li>获取不到服务提供方抛出的原始异常信息；</li><li>实现某些业务方法不进入熔断，直接往外抛出异常；</li></ul><p>接下来将一一解决上述问题。</p><p>对于<code>failed and no fallback available.</code>这种异常信息，是因为项目开启了熔断：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">feign.hystrix.enabled</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><p>当调用服务时抛出了异常，却没有定义<code>fallback</code>方法，就会抛出上述异常。由此引出了第一个解决方式。</p><h3 id="FeignClient加上fallback方法，并获取异常信息"><a href="#FeignClient加上fallback方法，并获取异常信息" class="headerlink" title="@FeignClient加上fallback方法，并获取异常信息"></a><code>@FeignClient</code>加上<code>fallback</code>方法，并获取异常信息</h3><p>为<code>@FeignClient</code>修饰的接口加上<code>fallback</code>方法有两种方式，由于要获取异常信息，所以使用<code>fallbackFactory</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;serviceId&quot;, fallbackFactory = TestServiceFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">Result <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>@FeignClient</code>注解中指定<code>fallbackFactory</code>，上面例子中是<code>TestServiceFallback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceFallback</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">TestService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(TestServiceFallback.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERR_MSG = <span class="string">&quot;Test接口暂时不可用: &quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        String msg = throwable == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : throwable.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(msg)) &#123;</span><br><span class="line">            LOG.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ResultBuilder.unsuccess(ERR_MSG + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现<code>FallbackFactory</code>,可以在<code>create</code>方法中获取到服务抛出的异常。但是请注意，这里的异常是被<code>Feign</code>封装过的异常，不能直接在异常信息中看出原始方法抛出的异常。这时得到的异常信息形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">status 500 reading TestService#addRecord(ParamVO); content:</span><br><span class="line">&#123;<span class="string">&quot;success&quot;</span>:<span class="keyword">false</span>,<span class="string">&quot;resultCode&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;/ by zero&quot;</span>,<span class="string">&quot;model&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;models&quot;</span>:[],<span class="string">&quot;pageInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;timelineInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;extra&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;validationMessages&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;valid&quot;</span>:<span class="keyword">false</span>&#125;</span><br></pre></td></tr></table></figure><p>说明一下，本例子中，服务提供者的接口返回信息会统一封装在自定义类<code>Result</code>中，内容就是上述的<code>content</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;success&quot;</span>:<span class="keyword">false</span>,<span class="string">&quot;resultCode&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;/ by zero&quot;</span>,<span class="string">&quot;model&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;models&quot;</span>:[],<span class="string">&quot;pageInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;timelineInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;extra&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;validationMessages&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;valid&quot;</span>:<span class="keyword">false</span>&#125;</span><br></pre></td></tr></table></figure><p>因此，异常信息我希望是<code>message</code>的内容：<code>/ by zero</code>，这样打日志时能够方便识别异常。</p><h3 id="保留原始异常信息"><a href="#保留原始异常信息" class="headerlink" title="保留原始异常信息"></a>保留原始异常信息</h3><p>当调用服务时，如果服务返回的状态码不是200，就会进入到<code>Feign</code>的<code>ErrorDecoder</code>中，因此如果我们要解析异常信息，就要重写<code>ErrorDecoder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> feign.Util;</span><br><span class="line"><span class="keyword">import</span> feign.codec.ErrorDecoder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: CipherCui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 保留 feign 服务异常信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 1:29 2018/6/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepErrMsgConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorDecoder <span class="title">errorDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserErrorDecoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserErrorDecoder</span> <span class="keyword">implements</span> <span class="title">ErrorDecoder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Exception <span class="title">decode</span><span class="params">(String methodKey, Response response)</span> </span>&#123;</span><br><span class="line">            Exception exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取原始的返回内容</span></span><br><span class="line">                String json = Util.toString(response.body().asReader());</span><br><span class="line">                exception = <span class="keyword">new</span> RuntimeException(json);</span><br><span class="line">                <span class="comment">// 将返回内容反序列化为Result，这里应根据自身项目作修改</span></span><br><span class="line">                Result result = JsonMapper.nonEmptyMapper().fromJson(json, Result.class);</span><br><span class="line">                <span class="comment">// 业务异常抛出简单的 RuntimeException，保留原来错误信息</span></span><br><span class="line">                <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">                    exception = <span class="keyword">new</span> RuntimeException(result.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                logger.error(ex.getMessage(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个例子，原理是根据<code>response.body()</code>反序列化为自定义的<code>Result</code>类，提取出里面的<code>message</code>信息，然后抛出<code>RuntimeException</code>，这样当进入到熔断方法中时，获取到的异常就是我们处理过的<code>RuntimeException</code>。</p><p>注意上面的例子并不是通用的，但原理是相通的，大家要结合自身的项目作相应的修改。</p><p>要使上面代码发挥作用，还需要在<code>@FeignClient</code>注解中指定<code>configuration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;serviceId&quot;, fallbackFactory = TestServiceFallback.class, configuration = &#123;KeepErrMsgConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不进入熔断，直接抛出异常"><a href="#不进入熔断，直接抛出异常" class="headerlink" title="不进入熔断，直接抛出异常"></a>不进入熔断，直接抛出异常</h3><p>有时我们并不希望方法进入熔断逻辑，只是把异常原样往外抛。这种情况我们只需要捉住两个点：<strong>不进入熔断</strong>、<strong>原样</strong>。</p><p>原样就是获取原始的异常，上面已经介绍过了，而不进入熔断，需要把异常封装成<code>HystrixBadRequestException</code>，对于<code>HystrixBadRequestException</code>，<code>Feign</code>会直接抛出，不进入熔断方法。</p><p>因此我们只需要在上述<code>KeepErrMsgConfiguration</code>的基础上作一点修改即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: CipherCui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: feign 服务异常不进入熔断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 1:29 2018/6/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotBreakerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorDecoder <span class="title">errorDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserErrorDecoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserErrorDecoder</span> <span class="keyword">implements</span> <span class="title">ErrorDecoder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Exception <span class="title">decode</span><span class="params">(String methodKey, Response response)</span> </span>&#123;</span><br><span class="line">            Exception exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String json = Util.toString(response.body().asReader());</span><br><span class="line">                exception = <span class="keyword">new</span> RuntimeException(json);</span><br><span class="line">                Result result = JsonMapper.nonEmptyMapper().fromJson(json, Result.class);</span><br><span class="line">                <span class="comment">// 业务异常包装成 HystrixBadRequestException，不进入熔断逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">                    exception = <span class="keyword">new</span> HystrixBadRequestException(result.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                logger.error(ex.getMessage(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了更好的达到熔断效果，我们应该为每个接口指定<code>fallback</code>方法。而根据自身的业务特点，可以灵活的配置上述的<code>KeepErrMsgConfiguration</code>和<code>NotBreakerConfiguration</code>，或自己编写<code>Configuration</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fegin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin与Hystrix及Ribbon关系</title>
      <link href="2020/11/17/Fegin%E4%B8%8EHystrix%E5%8F%8ARibbon%E5%85%B3%E7%B3%BB/"/>
      <url>2020/11/17/Fegin%E4%B8%8EHystrix%E5%8F%8ARibbon%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/crazymakercircle/">疯狂创客圈</a><br>出处：<a href="https://www.cnblogs.com/crazymakercircle/p/11664812.html">https://www.cnblogs.com/crazymakercircle/p/11664812.html</a></p><h3 id="Springcloud-高并发-配置-简介"><a href="#Springcloud-高并发-配置-简介" class="headerlink" title="Springcloud 高并发 配置 简介"></a>Springcloud 高并发 配置 简介</h3><p>在微服务架构的应用中， Feign、Hystrix，Ribbon三者都是必不可少的，可以说已经成为铁三角。</p><p><strong>疯狂创客圈</strong>（笔者尼恩创建的高并发研习社群）中，有不少小伙伴问到尼恩，关于Feign、Hystrix，Ribbon三者之间的关系，以及三者的超时配置。截止目前，全网没有篇文章介绍清楚的，故，尼恩特写一篇详细一点的文章，剖析一下。</p><h3 id="Feign介绍"><a href="#Feign介绍" class="headerlink" title="Feign介绍"></a>Feign介绍</h3><p>Feign是一款Java语言编写的HttpClient绑定器，在Spring Cloud微服务中用于实现微服务之间的声明式调用。Feign 可以定义请求到其他服务的接口，用于微服务间的调用，不用自己再写http请求，在客户端实现，调用此接口就像远程调用其他服务一样，当请求出错时可以调用接口的实现类来返回</p><p>Feign是一个声明式的web service客户端，它使得编写web service客户端更为容易。创建接口，为接口添加注解，即可使用Feign。Feign可以使用Feign注解或者JAX-RS注解，还支持热插拔的编码器和解码器。Spring Cloud为Feign添加了Spring MVC的注解支持，并整合了Ribbon和Eureka来为使用Feign时提供负载均衡。</p><p>feign源码的github地址：</p><p><a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><h3 id="Ribbon介绍"><a href="#Ribbon介绍" class="headerlink" title="Ribbon介绍"></a>Ribbon介绍</h3><p>Ribbon 作为负载均衡，在客户端实现，服务段可以启动两个端口不同但servername一样的服务</p><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。简单地说，Ribbon是一个客户端负载均衡器。</p><p>Ribbon工作时分为两步：第一步先选择 Eureka Server, 它优先选择在同一个Zone且负载较少的Server；第二步再根据用户指定的策略，在从Server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略，例如轮询、随机、根据响应时间加权等。</p><p>ribbon源码的github地址：</p><p><a href="https://github.com/Netflix/ribbon">https://github.com/Netflix/ribbon</a></p><h3 id="Hystrix介绍"><a href="#Hystrix介绍" class="headerlink" title="Hystrix介绍"></a>Hystrix介绍</h3><p>Hystrix作为熔断流量控制，在客户端实现，在方法上注解，当请求出错时可以调用注解中的方法返回</p><p>Hystrix熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。</p><p>Hystrix源码的github地址：</p><p><a href="https://github.com/Netflix/hystrix">https://github.com/Netflix/hystrix</a></p><h3 id="重点：-三者之间的关系图"><a href="#重点：-三者之间的关系图" class="headerlink" title="重点： 三者之间的关系图"></a>重点： 三者之间的关系图</h3><p>如果微服务项目加上了spring-cloud-starter-netflix-hystrix依赖，那么，feign会通过代理模式， 自动将所有的方法用 hystrix 进行包装。</p><p>在Spring Cloud微服务体系下，微服务之间的互相调用可以通过Feign进行声明式调用，在这个服务调用过程中Feign会通过Ribbon从服务注册中心获取目标微服务的服务器地址列表，之后在网络请求的过程中Ribbon就会将请求以负载均衡的方式打到微服务的不同实例上，从而实现Spring Cloud微服务架构中最为关键的功能即服务发现及客户端负载均衡调用。</p><p>另一方面微服务在互相调用的过程中，为了防止某个微服务的故障消耗掉整个系统所有微服务的连接资源，所以在实施微服务调用的过程中我们会要求在调用方实施针对被调用微服务的熔断逻辑。而要实现这个逻辑场景在Spring Cloud微服务框架下我们是通过Hystrix这个框架来实现的。</p><p>调用方会针对被调用微服务设置调用超时时间，一旦超时就会进入熔断逻辑，而这个故障指标信息也会返回给Hystrix组件，Hystrix组件会根据熔断情况判断被调微服务的故障情况从而打开熔断器，之后所有针对该微服务的请求就会直接进入熔断逻辑，直到被调微服务故障恢复，Hystrix断路器关闭为止。</p><p>三者之间的关系图，大致如下：</p><p><a href="https://img-blog.csdnimg.cn/20191012221343851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20191012221343851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p><h3 id="Feign典型配置说明"><a href="#Feign典型配置说明" class="headerlink" title="Feign典型配置说明"></a>Feign典型配置说明</h3><p>Feign自身可以支持多种HttpClient工具包，例如OkHttp及Apache HttpClient，针对Apache HttpClient的典型配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment">#替换掉JDK默认HttpURLConnection实现的 Http Client</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">       <span class="comment">#连接超时时间</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">       <span class="comment">#读取超时时间</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="Hystrix配置说明"><a href="#Hystrix配置说明" class="headerlink" title="Hystrix配置说明"></a>Hystrix配置说明</h3><p>在Spring Cloud微服务体系中Hystrix主要被用于实现实现微服务之间网络调用故障的熔断、过载保护及资源隔离等功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">propagate:</span></span><br><span class="line">    <span class="attr">request-attribute:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="comment">#全局默认配置</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="comment">#线程隔离相关</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">timeout:</span></span><br><span class="line">          <span class="comment">#是否给方法执行设置超时时间，默认为true。一般我们不要改。</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="comment">#配置请求隔离的方式，这里是默认的线程池方式。还有一种信号量的方式semaphore，使用比较少。</span></span><br><span class="line">          <span class="attr">strategy:</span> <span class="string">threadPool</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="comment">#方式执行的超时时间，默认为1000毫秒，在实际场景中需要根据情况设置</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">10000</span></span><br><span class="line">            <span class="comment">#发生超时时是否中断方法的执行，默认值为true。不要改。</span></span><br><span class="line">            <span class="attr">interruptOnTimeout:</span> <span class="literal">true</span></span><br><span class="line">            <span class="comment">#是否在方法执行被取消时中断方法，默认值为false。没有实际意义，默认就好！</span></span><br><span class="line">            <span class="attr">interruptOnCancel:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">circuitBreaker:</span>   <span class="comment">#熔断器相关配置</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#是否启动熔断器，默认为true，false表示不要引入Hystrix。</span></span><br><span class="line">    <span class="attr">requestVolumeThreshold:</span> <span class="number">20</span>     <span class="comment">#启用熔断器功能窗口时间内的最小请求数，假设我们设置的窗口时间为10秒，</span></span><br><span class="line">    <span class="attr">sleepWindowInMilliseconds:</span> <span class="number">5000</span>    <span class="comment">#所以此配置的作用是指定熔断器打开后多长时间内允许一次请求尝试执行，官方默认配置为5秒。</span></span><br><span class="line">    <span class="attr">errorThresholdPercentage:</span> <span class="number">50</span>   <span class="comment">#窗口时间内超过50%的请求失败后就会打开熔断器将后续请求快速失败掉,默认配置为50</span></span><br></pre></td></tr></table></figure><h3 id="Ribbon配置说明"><a href="#Ribbon配置说明" class="headerlink" title="Ribbon配置说明"></a>Ribbon配置说明</h3><p>Ribbon在Spring Cloud中对于支持微服之间的通信发挥着非常关键的作用，其主要功能包括客户端负载均衡器及用于中间层通信的客户端。在基于Feign的微服务通信中无论是否开启Hystrix，Ribbon都是必不可少的，Ribbon的配置参数主要如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#说明：同一台实例的最大自动重试次数，默认为1次，不包括首次</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment">#说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment">#说明：是否所有的操作都重试，默认为true</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒</span></span><br><span class="line">  <span class="attr">ServerListRefreshInterval:</span> <span class="number">2000</span></span><br><span class="line">  <span class="comment">#说明：使用Apache HttpClient连接超时时间，单位为毫秒</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">3000</span></span><br><span class="line">  <span class="comment">#说明：使用Apache HttpClient读取的超时时间，单位为毫秒</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>如上图所示，在Spring Cloud中使用Feign进行微服务调用分为两层：<strong>Hystrix的调用和Ribbon的调用，Feign自身的配置会被覆盖</strong>。</p><p>而如果<strong>开启了Hystrix，那么Ribbon的超时时间配置与Hystrix的超时时间配置则存在依赖关系</strong>，因为涉及到Ribbon的重试机制，所以一般情况下都是Ribbon的超时时间小于Hystrix的超时时间，否则会出现以下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">20</span>,<span class="number">208</span>   <span class="number">111231</span> [http-nio-<span class="number">8084</span>-exec-<span class="number">2</span>] WARN    o.s.c.n.z.f.r.s.AbstractRibbonCommand - The Hystrix timeout of <span class="number">10000</span>ms   <span class="keyword">for</span> the command operation is set lower than the combination of the Ribbon   read and connect timeout, <span class="number">24000</span>ms. </span><br></pre></td></tr></table></figure><h3 id="Ribbon和Hystrix的超时时间配置的关系"><a href="#Ribbon和Hystrix的超时时间配置的关系" class="headerlink" title="Ribbon和Hystrix的超时时间配置的关系"></a>Ribbon和Hystrix的超时时间配置的关系</h3><p><strong>那么Ribbon和Hystrix的超时时间配置的关系具体是什么呢？如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hystrix的超时时间=Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout)</span><br></pre></td></tr></table></figure><p><strong>而Ribbon的重试次数的计算方式为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ribbon重试次数(包含首次)= <span class="number">1</span> + ribbon.MaxAutoRetries  +  ribbon.MaxAutoRetriesNextServer  +  (ribbon.MaxAutoRetries * ribbon.MaxAutoRetriesNextServer)</span><br></pre></td></tr></table></figure><p>以上图中的Ribbon配置为例子，Ribbon的重试次数=1+(1+1+1)=4，所以Hystrix的超时配置应该&gt;=4*(3000+3000)=24000毫秒。在Ribbon超时但Hystrix没有超时的情况下，Ribbon便会采取重试机制；而重试期间如果时间超过了Hystrix的超时配置则会立即被熔断（fallback）。</p><p>如果不配置Ribbon的重试次数，则Ribbon默认会重试一次，加上第一次调用Ribbon，总的的重试次数为2次，以上述配置参数为例，Hystrix超时时间配置为2*6000=12000，由于很多情况下，大家一般不会主动配置Ribbon的重试次数，所以这里需要注意下！强调下，以上超时配置的值只是示范，超时配置有点大不太合适实际的线上场景，大家根据实际情况设置即可！</p><p>说明下，<strong>如果不启用Hystrix，Feign的超时时间则是Ribbon的超时时间，Feign自身的配置也会被覆盖</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> Fegin </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin</title>
      <link href="2020/11/17/Fegin/"/>
      <url>2020/11/17/Fegin/</url>
      
        <content type="html"><![CDATA[<h2 id="Fegin客户端"><a href="#Fegin客户端" class="headerlink" title="Fegin客户端"></a>Fegin客户端</h2><p><strong>GET：</strong></p><ol><li>客户端对象不加@RequesetParam,控制类使用对象接收，时间格式会出现转换失败【string转date异常】</li><li>客户端对象不增加@RequesetParam，控制类使用@RequesetParam对象接收，参数miss【orderSource=TAKEGO&amp;logicDelete=0&amp;pageSize=20&amp;startTime=2020-11-04T16:00:00.000+0000&amp;<br>  endTime=2020-11-05T15:59:59.059+0000&amp;pageNum=1 】</li><li>客户端对象增加@RequesetParam,控制类使用对象接收，【consumerOrderSearchVO=ConsumerOrderSearchVO%28startTime%3DThu%20Nov%2005%2000%3A00%3A00%20CST%202020%2C%20endTime%3DThu%20Nov%2005%2023%3A59%3A59%20CST%202020%2C%20orderSource%3DTAKEGO%2C%20logicDelete%3D0%29 】</li><li>客户端对象增加@RequesetParam，控制类也使用@RequesetParam对象接收，异常【Cannot convert value of type ‘java.lang.String’ to required type ‘io.deepblueai.order.api.vo.ConsumerOrderSearchVO’】</li><li>客户端对象使用@RequestBody,控制类使用@RequestBody，【Required request body is missing】</li></ol><p><strong>POST:</strong> </p><p>​    使用@RequestBody</p><p><strong>List 数组</strong></p><pre><code>1. @RequestParam(&quot;ids&quot;); 2. 使用json</code></pre><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>@RequesetParam(name=”vo”) 把参数转换成了vo=””格式,{对象传递不应该增加此注解}，用于当key名称不对应时指定key名称，或者指定value是否为空，默认不为空</p><h2 id="Fegin使用GET方法，Body请求异常"><a href="#Fegin使用GET方法，Body请求异常" class="headerlink" title="Fegin使用GET方法，Body请求异常"></a>Fegin使用GET方法，Body请求异常</h2><p>HttpClientFeignLoadBalancedConfiguration&gt;OkHttpFeignLoadBalancedConfiguration&gt;DefaultFeignLoadBalancedConfiguration,对应的底层http工具：httpclient&gt;okhttp&gt;HttpURLConnection</p><p>根据http协议定义是支持@RequestBody+ RequestMethod.GET的，那么具体就得看工具包实现的不同的，查看源码发现<strong>okhttp和HttpURLConnection都不支持（报错），只有httpclient支持。（默认走HttpURLConnection会报错）</strong></p><p>我们知道只有httpclient支持@RequestBody+ RequestMethod.GET，所以我们必须满足条件走HttpClientFeignLoadBalancedConfiguration才行 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p> 依赖包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>10.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fegin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archaius配置中心客户端</title>
      <link href="2020/11/17/Archaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2020/11/17/Archaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Archaius"><a href="#Archaius" class="headerlink" title="Archaius"></a>Archaius</h2><p>Netflix只是开源了其配置中心（Archaius变色龙）的客户端部分，没有开源配套的服务器端。Archaius其实是配置源实现无关的，可以对接各种配置中心作为数据源。</p><h2 id="Archaius在Netflix的用例场景"><a href="#Archaius在Netflix的用例场景" class="headerlink" title="Archaius在Netflix的用例场景"></a>Archaius在Netflix的用例场景</h2><ul><li>根据请求上下文开启或关闭某项功能。</li><li>某个页面缺省显示10个商品，在某些情况下，可以通过Archaius调整配置，只显示5个商品。</li><li>动态调整Hystrix熔断器的行为。</li><li>调整服务调用客户端的连接和请求超时参数。</li><li>如果某个线上服务产生出错告警，可以动态调整日志输出级别(粒度可以细到包或者组件级别)，这样可以通过详细日志排查问题。问题定位以后，再将日志输出级别恢复到默认级别。</li><li>对于多区域或者多国家部署的应用，通过动态配置，可以根据不同区域和国家开启不同的功能。</li><li>可以根据用户的实际访问模式动态调整一些基础中间件的配置，例如缓存的存活时间TTL(Time To Live)。</li><li>数据库访问客户端的连接池配置，可以对不同服务配不同的值。例如，一个请求频率RPS(Request Per Second)小的服务，可以配置较小的连接数，而一个请求频率大的服务，可以配置较大的连接数。</li><li>运行期配置的变更可以在不同维度生效，例如集群中的单个实例维度，多区域部署下的某个区域维度，某个服务栈维度，或者某个应用集群维度。</li><li>功能开关(Feature Flag)发布，有些功能虽然上线，但是并不马上启用，而是通过配置开关动态启用，这样可以根据情况灵活开启或者关闭某项线上功能。</li><li>金丝雀发布(Canary Release)，新功能上线时，让新老集群同时并存一段时间，通过配置将到老集群的流量逐步动态调整到新集群，如果监控显示无异常，则完成新集群的上线，如异常，则快速切回老集群。</li></ul><h2 id="Archaius的特性和设计"><a href="#Archaius的特性和设计" class="headerlink" title="Archaius的特性和设计"></a>Archaius的特性和设计</h2><p>Archaius实际上是对Apache Common Configuration Library的一个封装和扩展，提供了一组基于Java的配置API，主要的特性包括：</p><ul><li>配置可动态调整。</li><li>配置支持类型(Int, Long, Boolean等)。</li><li>高性能和线程安全。</li><li>提供一个拉(pulling)配置的框架，可以从配置源动态拉取变更的配置。</li><li>支持回调(callback)机制，在配置变更时自动调用。</li><li>支持JMX MBean，可以通过JConsole查看配置和修改配置。</li></ul><p>下图是Archaius的总体设计：</p><p><img src="/2020/11/17/Archaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><p>Achaius的核心是一个称为**组合配置(Composite Configuration)**的概念，简单可以理解为一个分层级的配置，层级有优先级，高优先级的层级的配置会覆盖低优先级的配置。每一个层级可以从某个配置源获取配置，例如本地配置文件，JDBC数据源，远程REST API等。配置源还可以在运行时动态拉取变更，例如在上图中，持久化数据库配置(Persisted DB Configuration)是指将配置存在关系数据库中，相应的配置源会定期从数据库拉取变更)。配置的最终值由顶级配置决定，例如，如果多个层级都含有某个配置项，那么应用最终见到的值是配置层级中最顶层的值。配置分层的顺序是可以调整的。</p><h2 id="分级配置案例"><a href="#分级配置案例" class="headerlink" title="分级配置案例"></a>分级配置案例</h2><p>假设你开发了一个叫myapp的应用，在本地开发环境，一般你希望用本地配置，不依赖于远程的配置中心，这个时候你只需为应用写一个本地配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myapp.properties</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这个配置文件里头包含myapp的所有缺省配置。</p><p>当你的应用开发完成，需要分别部署到测试TEST, UAT和生产PROD环境，如果你希望在不同的环境重载某些缺省值，那么你可以为不同环境分别添加本地配置文件，在相关文件中重载缺省值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myapp-test.properties</span><br><span class="line">myapp-uat.properties</span><br><span class="line">myapp-prod.properties</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>例如，在<code>myapp.properties</code>中<code>timeout</code>配置值是<code>500</code>，在<code>myapp-prod.properties</code>中<code>timeout</code>配置值是<code>200</code>，那么应用在生产环境中将使用重载值<code>timeout=200</code>，其它没有重载则使用<code>myapp.properties</code>中的缺省值。</p><p>在Archaius中，可以通过设置<code>archaius.deployment.environment</code>启动参数，来激活不同环境的配置。</p><p>如果你还希望应用上线后，可以通过配置中心动态调整配置值，那么你可以将Achaius和某个配置中心(比如Apollo)进行对接，对接后配置中心中的配置具有最高优先级，其中的配置可以覆盖应用本地配置文件中的配置。例如，应用上线后你发现<code>timeout=200</code>设置太小了，想调大到<code>timeout=1000</code>，可以通过配置中心一键搞定。</p><h2 id="Archaius和Apollo配置中心集成"><a href="#Archaius和Apollo配置中心集成" class="headerlink" title="Archaius和Apollo配置中心集成"></a>Archaius和Apollo配置中心集成</h2><p>Archaius是一款非常优秀的生产级配置客户端组件，比较可惜的是Netflix没有开源它的配置中心的服务器端，幸好业界已经有Apollo这样优秀的配置中心开源产品。Archaius本身是配置源无关的，它提供的拉(pulling)框架可以支持对接各种数据源，而Apollo本身也正好提供基于HTTP REST的配置拉取接口，使得Archaius和Apollo的对接非常简单。</p><p>另外，当你想要使用某些Netflix的组件，比如Zuul网关，它原生是支持Archaius进行动态配置的，如果你又想要使用Apollo配置中心支持集中式动态配置，这个时候你用Apollo客户端去改造Zuul的话，工作量不小。其实不需要这么麻烦，这三者可以简单完美实现集成，如下图所示：</p><p><img src="/2020/11/17/Archaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/%E9%9B%86%E6%88%90%E5%9B%BE.png"></p><p>集成要点：</p><ul><li>通过设置<code>archaius.configurationSource.additionalUrls</code>启动参数，设置为Apollo的配置文件拉取端点，激活Archaius的远程配置数据源。</li><li>Apollo的配置文件拉取端点为：<code>&#123;config_server_url&#125;/configfiles/&#123;appId&#125;/&#123;clusterName&#125;/&#123;namespaceName&#125;</code>，其中：<code>config_server_url</code>是配置中心地址，<code>appId</code>是应用(例如Zuul)在Apollo中的唯一标识，<code>clusterName</code>是应用在Apollo中的集群名，一般用缺省<code>default</code>，<code>namespaceName</code>是应用在Apollo中的名字空间，一般用缺省<code>application</code>。</li><li>注意，对于不同的环境(TEST，UAT，PROD等)，Apollo配置中心的地址一般不同</li><li>Archaius动态拉取配置的周期缺省是60秒，可以调整。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>根据不同上下文动态调整应用的行为逻辑，是现代互联网应用的刚需，配置中心应运而生，它是微服务架构必不可少的组件。</li><li>Archaius是Netflix开源的生产级配置中心客户端组件，它的亮点是支持多维度、分层级的和动态的配置。</li><li>Archaius可以和Apollo配置中可以简单无缝集成，让很多Netflix的开源组件(Zuul，Hystrix，Ribbon等)可以简单接入Apollo。波波2018年在极客时间上的课程《微服务架构和实践160讲》，7月份推出了第3模块：《微服务网关Zuul架构和实践》，其中会通过实验详细分析Archaius和Apollo的集成，通过Apollo+Archaius实现Zuul网关的动态配置，欢迎大家关注。</li><li>关于Archaius的更多技术细节，可以参考其在github上的站点[附录1]，另外拍拍贷框架团队的技术专家<strong>尹作龙</strong>也写了一篇文章《微服务动态配置组件netflix archaius》[附录2]，对Archaius的实现细节、使用案例以及如何与Spring Boot集成进行了深入细致的剖析，欢迎大家学习。</li></ol><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>Archaius 包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等等功能。</p><h2 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h2><p>Archaius 支持配置源包括：文件、URLs、JDBC 以及 Amazon DynamoDB</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a property whose value is type long and use 1000 as the default </span></span><br><span class="line">  <span class="comment">// if the property is not defined</span></span><br><span class="line">  DynamicLongProperty timeToWait = </span><br><span class="line">      DynamicPropertyFactory.getInstance().getLongProperty(<span class="string">&quot;lock.waitTime&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ReentrantLock lock = ...;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  lock.tryLock(timeToWait.get(), TimeUnit.MILLISECONDS); <span class="comment">// timeToWait.get() returns up-to-date value of the property</span></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li><a href="https://github.com/netflix/archaius">Netflix Archaius</a></li><li><a href="http://techblog.ppdai.com/2018/05/08/20180508/">微服务动态配置组件netflix archaius</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> Archaius </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置中心对比</title>
      <link href="2020/11/17/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/"/>
      <url>2020/11/17/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式配置中心技术"><a href="#分布式配置中心技术" class="headerlink" title="分布式配置中心技术"></a>分布式配置中心技术</h1><p>配置中心分为二部分，Server服务端及Client客户端。服务端提供数据配置存储；客户端和应用集成，通过通信协议与服务端进行交互，获取服务端数据。</p><h2 id="主流分布式配置中心"><a href="#主流分布式配置中心" class="headerlink" title="主流分布式配置中心"></a>主流分布式配置中心</h2><p>现在比较流行的分布式配置中心如下：</p><ul><li><strong>Nacos</strong> 阿里开源的配置中心，也可以做DNS和RPC的服务发现</li><li><strong>spring cloud config</strong>(借助其它存储服务实现服务端如git)</li><li><strong>Apollo</strong> 携程开源的配置管理中心，具备规范的权限、流程治理等特性</li><li><strong>Disconf</strong> 百度开源的配置管理中心，<strong>目前已经不维护了</strong></li><li><strong>Archaius</strong> Netflix未开源的配置中，其它组件(例如Zuul, Hystrix, Eureka, Ribbon等)都依赖于Archaius</li></ul><h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><p><img src="/2020/11/17/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%941-1605244589166.jpeg"></p><p><img src="/2020/11/17/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%942.jpeg"></p><p><strong>说明：</strong></p><p>压测环境：Nacos和Apollo使用同样的数据库（32C128G）部署Server服务的机器使用的8C16G配置的容器，磁盘是100G SSD。</p><p>Spring Cloud Config使用2.0.0.M9版本，Apollo使用1.2.0 release版本，Nacos使用0.5版本。</p><p>Spring Cloud Config 依赖git，使用局限性较大。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题</title>
      <link href="2020/11/17/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>2020/11/17/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="http://atecher.com/">Atecher</a></p><p>出处：<a href="http://atecher.com/2018/04/11/Java-Algorithms-Problem/">http://atecher.com/2018/04/11/Java-Algorithms-Problem/</a></p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</p><p>1.程序分析：这个是典型的<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波那契数列</a>，兔子的规律为数列1,1,2,3,5,8,13,21….</p><p>具体分析如下：</p><blockquote><p>f(1) = 1(第1个月有一对兔子）<br>f(2) = 1(第2个月还是一对兔子）<br>f(3) = 2(原来有一对兔子，第3个开始，每个月生一对兔子）<br>f(4) = 3(原来有两对兔子，有一对可以生育）<br>f(5) = 5(原来有3对兔子，第3个月出生的那对兔子也可以生育了，那么现在有两对兔子可以生育）<br>f(6) = 8(原来有5对兔子，第4个月出生的那对兔子也可以生育了，那么现在有3对兔子可以生育）<br>…………..<br>由以上可以看出，第n个月兔子的对数为<br>f(n) = f(n - 1) + f(n - 2);<br>f(n-1)是上个月的兔子数量，是原来有的。<br>f(n-2)是可以生育的兔子数，即多出来的数量。第n-2个月开始后的第3个月是第n个月，此时第n-2个月时的兔子都可以生育了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">            System.out.println(f(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>||x == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> f(x - <span class="number">1</span>) + f(x - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断101-200之间有多少个素数，并输出所有素数"><a href="#判断101-200之间有多少个素数，并输出所有素数" class="headerlink" title="判断101-200之间有多少个素数，并输出所有素数"></a>判断101-200之间有多少个素数，并输出所有素数</h2><p>1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出所有的“水仙花数”"><a href="#打印出所有的“水仙花数”" class="headerlink" title="打印出所有的“水仙花数”"></a>打印出所有的“水仙花数”</h2><p>所谓水仙花数是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 水仙花数 ，因为153=1的三次方＋5的三次方＋3的三次方。</p><p>1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        math mymath = <span class="keyword">new</span> math();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (mymath.shuixianhua(i) == <span class="keyword">true</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shuixianhua</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        i = x/<span class="number">100</span>;</span><br><span class="line">        j = (x % <span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">        k = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == i*i*i + j*j*j + k*k*k)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一个正整数分解质因数。例如：输入90-打印出90-233-5。"><a href="#将一个正整数分解质因数。例如：输入90-打印出90-233-5。" class="headerlink" title="将一个正整数分解质因数。例如：输入90,打印出90=233*5。"></a>将一个正整数分解质因数。例如：输入90,打印出90=2<em>3</em>3*5。</h2><p>1.程序分析：对n进行分解质因数，应先找到一个最小的质数i，然后按下述步骤完成：<br>(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。<br>(2)如果n &gt; i，但n能被i整除，则应打印出i的值，并用n除以i的商,作为新的正整数你,重复执行第一步。<br>(3)如果n不能被i整除，则用i+1作为i的值,重复执行第一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeFactorization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeFactorization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factorization</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                <span class="keyword">if</span>(n!=i)&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                fenjie(n/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入N的值：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        System.out.print( <span class="string">&quot;分解质因数：&quot;</span> + N +<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> PrimeFactorization().factorization(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用条件运算符的嵌套来完成此题：学习成绩-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"><a href="#利用条件运算符的嵌套来完成此题：学习成绩-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。" class="headerlink" title="利用条件运算符的嵌套来完成此题：学习成绩=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"></a>利用条件运算符的嵌套来完成此题：学习成绩=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。</h2><p>1.程序分析：(a&gt;b)?a:b这是条件运算符的基本例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcademicRecord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入N的值：&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        System.out.println(N &gt;= <span class="number">90</span> ?<span class="string">&quot;A&quot;</span>: (N &gt;= <span class="number">60</span> ? <span class="string">&quot;B&quot;</span>:<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入两个正整数m和n，求其最大公约数和最小公倍数。"><a href="#输入两个正整数m和n，求其最大公约数和最小公倍数。" class="headerlink" title="输入两个正整数m和n，求其最大公约数和最小公倍数。"></a>输入两个正整数m和n，求其最大公约数和最小公倍数。</h2><p>1.程序分析：利用辗除法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,m,n;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个正整数：&quot;</span>);</span><br><span class="line">        a=in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;再输入一个正整数：&quot;</span>);</span><br><span class="line">        b=in.nextInt();</span><br><span class="line">        commonDivisor use=<span class="keyword">new</span> commonDivisor();</span><br><span class="line">        m=use.commonDivisor(a,b);</span><br><span class="line">        n=a*b/m;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大公约数：&quot;</span>+m);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小公倍数：&quot;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">commonDivisor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commonDivisor</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=x;</span><br><span class="line">            x=y;</span><br><span class="line">            y=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k=x%y;</span><br><span class="line">                x=y;</span><br><span class="line">                y=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"><a href="#输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。" class="headerlink" title="输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"></a>输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</h2><p>1.程序分析：利用for循环语句,if条件语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串;&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str=in.nextLine();</span><br><span class="line">        <span class="keyword">char</span>[] ch=str.toCharArray();</span><br><span class="line">        count use=<span class="keyword">new</span> count();</span><br><span class="line">        use.count(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">count</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digital,character,blank,other;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">char</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                digital++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((arr[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;z&#x27;</span>)||(arr[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;Z&#x27;</span>))&#123;</span><br><span class="line">                character++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                blank++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                other++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数字个数：&quot;</span>+digital);</span><br><span class="line">        System.out.println(<span class="string">&quot;英文字母个数：&quot;</span>+character);</span><br><span class="line">        System.out.println(<span class="string">&quot;空格个数：&quot;</span>+blank);</span><br><span class="line">        System.out.println(<span class="string">&quot;其他字符个数：&quot;</span>+other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。"><a href="#求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。" class="headerlink" title="求s = a + aa + aaa + aaaa + aa…a的值，其中a是一个数字。"></a>求s = a + aa + aaa + aaaa + aa…a的值，其中a是一个数字。</h2><p>例如2 + 22 + 222 + 2222 + 22222(此时共有5个数相加)，几个数相加有键盘控制。</p><p>1.程序分析：关键是计算出每一项的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(请输入a的值);</span><br><span class="line">        int a &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(请输入n个数);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        int s &#x3D; 0,t&#x3D;0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            t +&#x3D; a;</span><br><span class="line">            a &#x3D; a*10;</span><br><span class="line">            s +&#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个数如果恰好等于它的因子之和，这个数就称为”完数”。"><a href="#一个数如果恰好等于它的因子之和，这个数就称为”完数”。" class="headerlink" title="一个数如果恰好等于它的因子之和，这个数就称为”完数”。"></a>一个数如果恰好等于它的因子之和，这个数就称为”完数”。</h2><p>例如6=1＋2＋3。编程找出1000以内的所有完数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int s;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">            s &#x3D; 0;</span><br><span class="line">            for (int j &#x3D; 1; j &lt; i; j++)</span><br><span class="line">                if (i % j &#x3D;&#x3D; 0)</span><br><span class="line">                    s &#x3D; s + j;</span><br><span class="line">            if (s &#x3D;&#x3D; i)</span><br><span class="line">                System.out.print(i + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo09&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i,j,sum;</span><br><span class="line">        for(i&#x3D;1;i&lt;1000;i++)&#123;</span><br><span class="line">            sum &#x3D; 0;</span><br><span class="line">            for(j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)&#123;</span><br><span class="line">                if(i%j&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    sum+&#x3D;j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum&#x3D;&#x3D;i)&#123;</span><br><span class="line">                System.out.print(i+&quot; its factors are:   &quot;);</span><br><span class="line">                for(j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)&#123;</span><br><span class="line">                    if(i%j&#x3D;&#x3D;0)</span><br><span class="line">                        System.out.print(j+&quot;, &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？"><a href="#一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？" class="headerlink" title="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？"></a>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double s &#x3D; 0;</span><br><span class="line">        double h &#x3D; 100;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;</span><br><span class="line">            s +&#x3D; h;</span><br><span class="line">            h &#x3D; h&#x2F;2;</span><br><span class="line">            s +&#x3D; h;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;经过路程：&quot;+s);</span><br><span class="line">        System.out.println(&quot;反弹高度：&quot;+h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h2><p>1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 4; i++)</span><br><span class="line">          for (int j &#x3D; 1; j &lt;&#x3D; 4; j++)</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; 4; k++)</span><br><span class="line">              if (i !&#x3D; j &amp;&amp; j !&#x3D; k &amp;&amp; i !&#x3D; k) &#123;</span><br><span class="line">            count +&#x3D; 1;</span><br><span class="line">            System.out.println(i*100 + j*10 + k);</span><br><span class="line">              &#125;</span><br><span class="line">        System.out.println(&quot;共&quot; + count + &quot;个三位数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="企业发放的奖金根据利润提成。"><a href="#企业发放的奖金根据利润提成。" class="headerlink" title="企业发放的奖金根据利润提成。"></a>企业发放的奖金根据利润提成。</h2><p>利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润lirun，求应发放奖金总数sum？</p><p>1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double sum;</span><br><span class="line">        System.out.println(&quot;输入当月利润：(万元)&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        double lirun &#x3D; in.nextDouble();</span><br><span class="line">        if (lirun &lt;&#x3D; 10) &#123;</span><br><span class="line">            sum &#x3D; lirun * 0.1;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 20) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + (lirun - 10) * 0.075;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 40) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + (lirun - 20) * 0.05;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 60) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + (lirun - 40) * 0.03;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 100) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + 10*0.03 + (lirun - 60) * 0.015;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + 10*0.03 + 10*0.015 + (lirun - 100) * 0.01;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;应发的奖金是：&quot;+sum+&quot;(万元)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"><a href="#一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？" class="headerlink" title="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"></a>一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？</h2><p>1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上168后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo13 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int x&#x3D;1;x&lt;100000;x++)&#123;</span><br><span class="line">          if(Math.sqrt(x+100)%1&#x3D;&#x3D;0)</span><br><span class="line">          if(Math.sqrt(x+100+168)%1&#x3D;&#x3D;0)</span><br><span class="line">            System.out.println(x+&quot;加上100后是一个完全平方数，加上168又是一个完全平方数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入某年某月某日，判断这一天是这一年的第几天？"><a href="#输入某年某月某日，判断这一天是这一年的第几天？" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天？"></a>输入某年某月某日，判断这一天是这一年的第几天？</h2><p>1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本月的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入年,月,日：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int year &#x3D; in.nextInt();</span><br><span class="line">        int month &#x3D; in.nextInt();</span><br><span class="line">        int day &#x3D; in.nextInt();</span><br><span class="line">        Calendar cal &#x3D; Calendar.getInstance();</span><br><span class="line">        cal.set(year, month - 1, day);</span><br><span class="line">        int sum &#x3D; cal.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(&quot;这一天是这一年的第&quot; + sum +&quot;天&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int year,month,day,sum&#x3D;0;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入年：&quot;);</span><br><span class="line">        year&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入月：&quot;);</span><br><span class="line">        month&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入日：&quot;);</span><br><span class="line">        day&#x3D;in.nextInt();</span><br><span class="line"></span><br><span class="line">        switch(month)&#123;</span><br><span class="line">        case 1:</span><br><span class="line">            sum&#x3D;0;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            sum&#x3D;31;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            sum&#x3D;59;</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            sum&#x3D;90;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">            sum&#x3D;120;</span><br><span class="line">            break;</span><br><span class="line">        case 6:</span><br><span class="line">            sum&#x3D;151;</span><br><span class="line">            break;</span><br><span class="line">        case 7:</span><br><span class="line">            sum&#x3D;181;</span><br><span class="line">            break;</span><br><span class="line">        case 8:</span><br><span class="line">            sum&#x3D;212;</span><br><span class="line">            break;</span><br><span class="line">        case 9:</span><br><span class="line">            sum&#x3D;243;</span><br><span class="line">            break;</span><br><span class="line">        case 10:</span><br><span class="line">            sum&#x3D;273;</span><br><span class="line">            break;</span><br><span class="line">        case 11:</span><br><span class="line">            sum&#x3D;304;</span><br><span class="line">            break;</span><br><span class="line">        case 12:</span><br><span class="line">            sum&#x3D;334;</span><br><span class="line">            break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;wrong input!&quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum&#x3D;sum+day;</span><br><span class="line">        boolean leap;</span><br><span class="line">        if(year%400&#x3D;&#x3D;0||(year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0))&#123;</span><br><span class="line">            leap&#x3D;true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            leap&#x3D;false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(leap&amp;&amp;month&gt;2)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;It is the &quot;+sum+&quot;th day.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;请输入年 月 日：&quot;);</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        int year&#x3D;in.nextInt();</span><br><span class="line">        int month&#x3D;in.nextInt();</span><br><span class="line">        int day&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;是该年的第&quot;+count(year,month,day)+&quot;天&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int count(int year,int month,int day)&#123;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        int days&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;month;i++)&#123;</span><br><span class="line">            switch(i)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">            case 3:</span><br><span class="line">            case 5:</span><br><span class="line">            case 7:</span><br><span class="line">            case 8:</span><br><span class="line">            case 10:</span><br><span class="line">            case 12:</span><br><span class="line">                days&#x3D;31;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">            case 6:</span><br><span class="line">            case 9:</span><br><span class="line">            case 11:</span><br><span class="line">                days&#x3D;30;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                if(year%400&#x3D;&#x3D;0||year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)&#123;</span><br><span class="line">                    days&#x3D;29;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    days&#x3D;28;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+&#x3D;days;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+&#x3D;day;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入三个整数x-y-z，请把这三个数由小到大输出。"><a href="#输入三个整数x-y-z，请把这三个数由小到大输出。" class="headerlink" title="输入三个整数x,y,z，请把这三个数由小到大输出。"></a>输入三个整数x,y,z，请把这三个数由小到大输出。</h2><p>1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt;y则将x与y的值进行交换，然后再用x与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(&quot;请输入三个数:&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] arr &#x3D; new int[3];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x &gt; y) &#123; int t &#x3D; x; x &#x3D; y; y &#x3D; t; &#125; if(x &gt; z) &#123; int t &#x3D; x; x &#x3D; z; z &#x3D; t; &#125; if(y &gt; z) &#123; int t &#x3D; y; y &#x3D; z; z &#x3D; t; &#125;</span><br></pre></td></tr></table></figure><h2 id="输出9-9口诀乘法表。"><a href="#输出9-9口诀乘法表。" class="headerlink" title="输出9*9口诀乘法表。"></a>输出9*9口诀乘法表。</h2><p>1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。<br>出现重复的乘积（全矩形）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; 9; j++)</span><br><span class="line">                System.out.print(i + &quot;*&quot; + j + &quot;&#x3D;&quot; + (i*j) + &quot;\\t&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不现重复的乘积(下三角)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; i; j++)</span><br><span class="line">                System.out.print(i + &quot;*&quot; + j + &quot;&#x3D;&quot; + (i*j) + &quot;\\t&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴子吃桃问题"><a href="#猴子吃桃问题" class="headerlink" title="猴子吃桃问题"></a>猴子吃桃问题</h2><p>猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。<br>1.程序分析：采取逆向思维的方法，从后往前推断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo17 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int sum &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 9; i++) &#123;</span><br><span class="line">            sum &#x3D; (sum + 1) * 2;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第一天共摘&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乒乓球比赛"><a href="#乒乓球比赛" class="headerlink" title="乒乓球比赛"></a>乒乓球比赛</h2><p>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Demo18 &#123;</span><br><span class="line">    static char[] m &#x3D; &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;;</span><br><span class="line">    static char[] n &#x3D; &#123; &#39;x&#39;, &#39;y&#39;, &#39;z&#39; &#125;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n.length; j++) &#123;</span><br><span class="line">                if (m[i] &#x3D;&#x3D; &#39;a&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;x&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if (m[i] &#x3D;&#x3D; &#39;a&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;y&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if ((m[i] &#x3D;&#x3D; &#39;c&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;x&#39;)</span><br><span class="line">                        || (m[i] &#x3D;&#x3D; &#39;c&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;z&#39;)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if ((m[i] &#x3D;&#x3D; &#39;b&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;z&#39;)</span><br><span class="line">                        || (m[i] &#x3D;&#x3D; &#39;b&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;y&#39;)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else</span><br><span class="line">                    System.out.println(m[i] + &quot; vs &quot; + n[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Demo18 &#123;</span><br><span class="line">    public String a, b, c;</span><br><span class="line">    public Demo18(String a, String b, String c) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">        this.b &#x3D; b;</span><br><span class="line">        this.c &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo18 arr_a &#x3D; new Demo18(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">        String[] b &#x3D; &#123; &quot;x&quot;, &quot;y&quot;, &quot;z&quot; &#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">                 Demo18 arr_b &#x3D; new Demo18(b[i], b[j], b[k]);</span><br><span class="line">                    if (!arr_b.a.equals(arr_b.b) &amp; !arr_b.b.equals(arr_b.c)</span><br><span class="line">                            &amp; !arr_b.c.equals(arr_b.a) &amp; !arr_b.a.equals(&quot;x&quot;)</span><br><span class="line">                            &amp; !arr_b.c.equals(&quot;x&quot;) &amp; !arr_b.c.equals(&quot;z&quot;)) &#123;</span><br><span class="line">                        System.out.println(arr_a.a + &quot;--&quot; + arr_b.a);</span><br><span class="line">                        System.out.println(arr_a.b + &quot;--&quot; + arr_b.b);</span><br><span class="line">                        System.out.println(arr_a.c + &quot;--&quot; + arr_b.c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出如下图案（三角形-菱形）"><a href="#打印出如下图案（三角形-菱形）" class="headerlink" title="打印出如下图案（三角形\菱形）"></a>打印出如下图案（三角形\菱形）</h2><p>1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重for循环，第一层控制行，第二层控制列。</p><p><strong>三角形：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">***</span><br><span class="line">******</span><br><span class="line">********</span><br><span class="line">******</span><br><span class="line">***</span><br><span class="line">*</span><br><span class="line">public class Demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        for ( i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">            for ( j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        for ( i &#x3D; 3; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">            for ( j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>菱形：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   *</span><br><span class="line">  ***</span><br><span class="line"> *****</span><br><span class="line">*******</span><br><span class="line"> *****</span><br><span class="line">  ***</span><br><span class="line">   *</span><br><span class="line">public class Demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        for (i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; 4 - i; k++)</span><br><span class="line">                System.out.print( &quot; &quot; );</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 3; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; 4 - i; k++)</span><br><span class="line">                System.out.print( &quot; &quot; );</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。"><a href="#有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。" class="headerlink" title="有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。"></a>有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。</h2><p>1.程序分析：请抓住分子与分母的变化规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo20 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float fm &#x3D; 1.0f;</span><br><span class="line">        float fz &#x3D; 1.0f;</span><br><span class="line">        float temp;</span><br><span class="line">        float sum &#x3D; 0f;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            temp &#x3D; fm;</span><br><span class="line">            fm &#x3D; fz;</span><br><span class="line">            fz &#x3D; fz + temp;</span><br><span class="line">            System.out.println((int) fz + &quot;&#x2F;&quot; + (int) fm);</span><br><span class="line">            sum +&#x3D; fz &#x2F; fm;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求1-2-3-…-20-的和"><a href="#求1-2-3-…-20-的和" class="headerlink" title="求1+2!+3!+…+20!的和"></a>求1+2!+3!+…+20!的和</h2><p>1.程序分析：此程序只是把累加变成了累乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo21 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long sum &#x3D; 0;</span><br><span class="line">        long fac &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 20; i++) &#123;</span><br><span class="line">            fac &#x3D; fac * i;</span><br><span class="line">            sum +&#x3D; fac;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用递归方法求5"><a href="#利用递归方法求5" class="headerlink" title="利用递归方法求5!"></a>利用递归方法求5!</h2><p>1.程序分析：递归公式：f(n)=f(n-1)*4!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo22 &#123;</span><br><span class="line">    public static long fac(int n) &#123;</span><br><span class="line">        long value &#x3D; 0;</span><br><span class="line">        if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            value &#x3D; 1;</span><br><span class="line">        &#125; else if (n &gt; 1) &#123;</span><br><span class="line">            value &#x3D; n * fac(n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入一个数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(n + &quot;的阶乘为：&quot; + fac(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算年龄"><a href="#计算年龄" class="headerlink" title="计算年龄"></a>计算年龄</h2><p>有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？</p><p>1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10岁），再往回推。</p><p>直接求解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n &#x3D; 10;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">            n &#x3D; n + 2;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第五个人&quot; + n + &quot;岁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归求解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo23 &#123;</span><br><span class="line">    public static int getAge(int n) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return 2 + getAge(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;第五个的年龄为&quot; + getAge(5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"><a href="#给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。" class="headerlink" title="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"></a>给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。</h2><p>本题原方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo24 use &#x3D; new Demo24();</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        long a &#x3D; in.nextLong();</span><br><span class="line">        if (a &lt; 0 || a &gt;&#x3D; 100000) &#123;</span><br><span class="line">            System.out.println(&quot;Error Input, please run this program Again!&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a &gt;&#x3D; 0 &amp;&amp; a &lt;&#x3D; 9) &#123;</span><br><span class="line">            System.out.println(a + &quot;是一位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;  + a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 10 &amp;&amp; a &lt;&#x3D; 99) &#123;</span><br><span class="line">            System.out.println(a + &quot;是二位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 100 &amp;&amp; a &lt;&#x3D; 999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是三位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 1000 &amp;&amp; a &lt;&#x3D; 9999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是四位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 10000 &amp;&amp; a &lt;&#x3D; 99999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是五位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void converse(long l) &#123;</span><br><span class="line">        String s &#x3D; Long.toString(l);</span><br><span class="line">        char[] ch &#x3D; s.toCharArray();</span><br><span class="line">        for (int i &#x3D; ch.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.print(ch[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人版方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        if (str.matches(&quot;\\\\d+&quot;)) &#123; &#x2F;&#x2F;正则表达式</span><br><span class="line">            System.out.println(&quot;输入的是&quot; + str.length() + &quot;位数&quot;);</span><br><span class="line">            StringBuffer buf &#x3D; new StringBuffer(str);</span><br><span class="line">            System.out.println(buf.reverse());&#x2F;&#x2F;字符串反转</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"><a href="#一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。" class="headerlink" title="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"></a>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</h2><p>原方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Palindrom &#123;</span><br><span class="line">    static int[] a &#x3D; new int[5];</span><br><span class="line">    static int[] b &#x3D; new int[5];</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        boolean is &#x3D; false;</span><br><span class="line">        System.out.println(&quot;Please input：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        long l &#x3D; in.nextLong();</span><br><span class="line">        if (l &gt; 99999 || l &lt; 10000) &#123;</span><br><span class="line">            System.out.println(&quot;Input error, please input again!&quot;);</span><br><span class="line">            l &#x3D; in.nextLong();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 4; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            a[i] &#x3D; (int) (l &#x2F; (long) Math.pow(10, i));</span><br><span class="line">            l &#x3D; (l % (long) Math.pow(10, i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 0; i &lt; 5; i++, j++) &#123;</span><br><span class="line">            b[j] &#x3D; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 4; i &lt; 5; i++, j--) &#123;</span><br><span class="line">            if (a[i] !&#x3D; b[j]) &#123;</span><br><span class="line">                is &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                is &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (is &#x3D;&#x3D; false) &#123;</span><br><span class="line">            System.out.println(&quot;is not a Palindrom!&quot;);</span><br><span class="line">        &#125; else if (is &#x3D;&#x3D; true) &#123;</span><br><span class="line">            System.out.println(&quot;is a Palindrom!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Palindrom &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        int l &#x3D; Integer.parseInt(str);&#x2F;&#x2F;转换成整数</span><br><span class="line">        if (l &lt; 10000 || l &gt; 99999) &#123;</span><br><span class="line">            System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean is&#x3D;false;</span><br><span class="line">        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">        for(int i&#x3D;0;i&lt;ch.length&#x2F;2;i++)&#123;</span><br><span class="line">            if(ch[i]!&#x3D;ch[ch.length-i-1])&#123;</span><br><span class="line">                is&#x3D;false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                is&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(is)&#123;</span><br><span class="line">            System.out.println(&quot;这是一个回文!&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;不是一个回文!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。"><a href="#请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。" class="headerlink" title="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。"></a>请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。</h2><p>1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo26 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char weekSecond;&#x2F;&#x2F;保存第二字母</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);&#x2F;&#x2F;接收用户输入</span><br><span class="line">        System.out.println(&quot;请输入星期的第一个字母：&quot;);</span><br><span class="line">        String letter &#x3D; in.next();</span><br><span class="line">        if (letter.length() &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;判断用户控制台输入字符串长度是否是一个字母</span><br><span class="line">            char weekFirst &#x3D; letter.charAt(0);&#x2F;&#x2F;取第一个字符</span><br><span class="line">            switch (weekFirst) &#123;</span><br><span class="line">            case &#39;m&#39;:</span><br><span class="line">            case &#39;M&#39;:</span><br><span class="line">                System.out.println(&quot;星期一(Monday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;t&#39;:</span><br><span class="line">            case &#39;T&#39;:</span><br><span class="line">                System.out.print(&quot;由于星期二(Tuesday)与星期四(Thursday)均以字母T开头，故需输入第二个字母才能正确判断：&quot;);</span><br><span class="line">                letter &#x3D; in.next();</span><br><span class="line">                if (letter.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    weekSecond &#x3D; letter.charAt(0);</span><br><span class="line">                    if (weekSecond &#x3D;&#x3D; &#39;U&#39; || weekSecond &#x3D;&#x3D; &#39;u&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期二(Tuesday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else if (weekSecond &#x3D;&#x3D; &#39;H&#39; || weekSecond &#x3D;&#x3D; &#39;h&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期四(Thursday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;Error!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case &#39;w&#39;:</span><br><span class="line">            case &#39;W&#39;:</span><br><span class="line">                System.out.println(&quot;星期三(Wednesday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;f&#39;:</span><br><span class="line">            case &#39;F&#39;:</span><br><span class="line">                System.out.println(&quot;星期五(Friday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;s&#39;:</span><br><span class="line">            case &#39;S&#39;:</span><br><span class="line">                System.out.print(&quot;由于星期六(Saturday)与星期日(Sunday)均以字母S开头，故需输入第二个字母才能正确判断：&quot;);</span><br><span class="line">                letter &#x3D; in.next();</span><br><span class="line">                if (letter.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    weekSecond &#x3D; letter.charAt(0);</span><br><span class="line">                    if (weekSecond &#x3D;&#x3D; &#39;A&#39; || weekSecond &#x3D;&#x3D; &#39;a&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期六(Saturday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else if (weekSecond &#x3D;&#x3D; &#39;U&#39; || weekSecond &#x3D;&#x3D; &#39;u&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期日(Sunday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;Error!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;输入错误，不能识别的星期值第一个字母，程序结束！&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求100之内的素数"><a href="#求100之内的素数" class="headerlink" title="求100之内的素数"></a>求100之内的素数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo27 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int sum, i;</span><br><span class="line">        for (sum &#x3D; 2; sum &lt;&#x3D; 100; sum++) &#123;</span><br><span class="line">            for (i &#x3D; 2; i &lt;&#x3D; sum &#x2F; 2; i++) &#123;</span><br><span class="line">                if (sum % i &#x3D;&#x3D; 0)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt; sum &#x2F; 2)</span><br><span class="line">                System.out.println(sum + &quot;是素数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo27&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        int w&#x3D;1;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;100;i++)&#123;</span><br><span class="line">            for(int j&#x3D;2;j&lt;i;j++)&#123;</span><br><span class="line">                w&#x3D;i%j;</span><br><span class="line">                if(w&#x3D;&#x3D;0)break;</span><br><span class="line">                &#125;</span><br><span class="line">            if(w!&#x3D;0)</span><br><span class="line">                System.out.println(i+&quot;是素数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对10个数进行排序。"><a href="#对10个数进行排序。" class="headerlink" title="对10个数进行排序。"></a>对10个数进行排序。</h2><p>1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，下次类推，即用第二个元素与后8个进行比较，并进行交换。<br>本例代码为生成随机10个数排序，并输入1个数，插入重排序输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo28 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] &#x3D; new int[11];</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; r.nextInt(100) + 1; &#x2F;&#x2F;得到10个100以内的整数</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] +&quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;\nPlease Input a int number:&quot; );</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        arr[10] &#x3D; in.nextInt();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] +&quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo28 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入10个数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] arr &#x3D; new int[10];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原数组为：&quot;);</span><br><span class="line">        for (int x : arr) &#123;&#x2F;&#x2F;foreach遍历</span><br><span class="line">            System.out.print( x + &quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;排序后为：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求一个3-3矩阵主对角线元素之和"><a href="#求一个3-3矩阵主对角线元素之和" class="headerlink" title="求一个3*3矩阵主对角线元素之和"></a>求一个3*3矩阵主对角线元素之和</h2><p>1.程序分析：利用双重for循环控制输入二维数组，再将a[i][i]累加后输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo29 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double sum &#x3D; 0;</span><br><span class="line">        int array[][] &#x3D; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 7, 8 &#125; &#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)</span><br><span class="line">                    sum &#x3D; sum + array[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主负对角线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        for(j&#x3D;0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           if(i&#x3D;&#x3D;j) sum1+&#x3D;a[i][j];</span><br><span class="line">           if(i+j&#x3D;&#x3D;n-1) sum2+&#x3D;a[i][j];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>##有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。</p><p>1.程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，插入后此元素之后的数，依次后移一个位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">public class Demo30 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        int arr[] &#x3D; new int[12];</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)</span><br><span class="line">            arr[i] &#x3D; r.nextInt(1000);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)</span><br><span class="line">            System.out.print(arr[i] + &quot;\\t&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 9; i++)</span><br><span class="line">            for (int k &#x3D; i + 1; k &lt;&#x3D; 10; k++)</span><br><span class="line">                if (arr[i] &gt; arr[k]) &#123;</span><br><span class="line">                    temp &#x3D; arr[i];</span><br><span class="line">                    arr[i] &#x3D; arr[k];</span><br><span class="line">                    arr[k] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 10; k++)</span><br><span class="line">            System.out.print(arr[k] + &quot;\\t&quot;);</span><br><span class="line">        arr[11] &#x3D; r.nextInt(1000);</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 10; k++)</span><br><span class="line">            if (arr[k] &gt; arr[11]) &#123;</span><br><span class="line">                temp &#x3D; arr[11];</span><br><span class="line">                for (int j &#x3D; 11; j &gt;&#x3D; k + 1; j--)</span><br><span class="line">                    arr[j] &#x3D; arr[j - 1];</span><br><span class="line">                    arr[k] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 11; k++)</span><br><span class="line">            System.out.print(arr[k] + &quot;\\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一个数组逆序输出"><a href="#将一个数组逆序输出" class="headerlink" title="将一个数组逆序输出"></a>将一个数组逆序输出</h2><p>程序分析：用第一个与最后一个交换。</p><p>用逆序循环控制变量输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo31 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 &#125;;</span><br><span class="line">        for (int i &#x3D; a.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取一个整数a从右端开始的第4～7位数字。"><a href="#取一个整数a从右端开始的第4～7位数字。" class="headerlink" title="取一个整数a从右端开始的第4～7位数字。"></a>取一个整数a从右端开始的第4～7位数字。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo32 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个7位以上的正整数：&quot;);</span><br><span class="line">        long l &#x3D; in.nextLong();</span><br><span class="line">        String str &#x3D; Long.toString(l);</span><br><span class="line">        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">        int j&#x3D;ch.length;</span><br><span class="line">        if (j&lt;7)&#123;System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;截取从右端开始的4～7位是：&quot;+ch[j-7]+ch[j-6]+ch[j-5]+ch[j-4]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo32&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a &#x3D; 0;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        long b &#x3D; s.nextLong();</span><br><span class="line">        a &#x3D; (int) (b % 10000000 &#x2F; 1000);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出杨辉三角形（要求打印出10行如下图）"><a href="#打印出杨辉三角形（要求打印出10行如下图）" class="headerlink" title="打印出杨辉三角形（要求打印出10行如下图）"></a>打印出杨辉三角形（要求打印出10行如下图）</h2><p>1.程序分析：<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo33 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        int a[][];</span><br><span class="line">        int n &#x3D; 10;</span><br><span class="line">        a &#x3D; new int[n][n];</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            a[i][i] &#x3D; 1;</span><br><span class="line">            a[i][0] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 2; i &lt; n; i++) &#123;</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; i - 1; j++) &#123;</span><br><span class="line">                a[i][j] &#x3D; a[i - 1][j - 1] + a[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt;&#x3D; i; j++) &#123;</span><br><span class="line">                System.out.printf(a[i][j] + &quot;\\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入3个数a-b-c，按大小顺序输出。"><a href="#输入3个数a-b-c，按大小顺序输出。" class="headerlink" title="输入3个数a,b,c，按大小顺序输出。"></a>输入3个数a,b,c，按大小顺序输出。</h2><p>（也可互相比较交换排序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Demo34 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arrays &#x3D; &#123; 800, 56, 500 &#125;;</span><br><span class="line">        Arrays.sort(arrays);</span><br><span class="line">        for (int n &#x3D; 0; n &lt; arrays.length; n++)</span><br><span class="line">            System.out.println(arrays[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x &gt; y) &#123; int t &#x3D; x; x &#x3D; y; y &#x3D; t; &#125; if(x &gt; z) &#123; int t &#x3D; x; x &#x3D; z; z &#x3D; t; &#125; if(y &gt; z) &#123; int t &#x3D; y; y &#x3D; z; z &#x3D; t; &#125;</span><br></pre></td></tr></table></figure><h2 id="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。"><a href="#输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。" class="headerlink" title="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。"></a>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo35 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i, min&#x3D;0, max&#x3D;0, n, temp1, temp2;</span><br><span class="line">        int a[];</span><br><span class="line">        System.out.println(&quot;定义数组的长度:&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        n &#x3D; in.nextInt();</span><br><span class="line">        a &#x3D; new int[n];</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(&quot;输入第&quot; + (i + 1) + &quot;个数据:&quot;);</span><br><span class="line">            a[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            if (a[i] &gt; a[max])</span><br><span class="line">                max &#x3D; i;</span><br><span class="line">            if (a[i] &lt; a[min])</span><br><span class="line">                min &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp1 &#x3D; a[0];</span><br><span class="line">        a[0] &#x3D; a[max];</span><br><span class="line">        a[max] &#x3D; temp1;</span><br><span class="line"></span><br><span class="line">        temp2 &#x3D; a[min];</span><br><span class="line"></span><br><span class="line">        if (min !&#x3D; 0) &#123; &#x2F;&#x2F; 如果最小值不是a[0]，执行下面</span><br><span class="line">            a[min] &#x3D; a[n - 1];</span><br><span class="line">            a[n - 1] &#x3D; temp2;</span><br><span class="line">        &#125; else &#123;  &#x2F;&#x2F;如果最小值是a[0],执行下面</span><br><span class="line">            a[max] &#x3D; a[n - 1];</span><br><span class="line">            a[n - 1] &#x3D; temp1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数"><a href="#有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数" class="headerlink" title="有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数"></a>有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo36 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入数字个数n：&quot;);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入后移位数m：&quot;);</span><br><span class="line">        int m &#x3D; in.nextInt();</span><br><span class="line">        LinkedList&lt;Integer&gt; list &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个数:&quot;);</span><br><span class="line">            list.add(in.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原数据排序为：&quot;);</span><br><span class="line">        for (int t : list) &#123;</span><br><span class="line">            System.out.print(t + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;Integer&gt; temp1 &#x3D; list.subList(list.size() - m, list.size());</span><br><span class="line">        List&lt;Integer&gt; temp2 &#x3D; list.subList(0, list.size() - m);</span><br><span class="line">        temp2.addAll(0, temp1);</span><br><span class="line">        System.out.println(&quot;移动后排序为;&quot;);</span><br><span class="line">        for (int t : temp2) &#123;</span><br><span class="line">            System.out.print(t + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo36&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请定义数组的长度：&quot;);</span><br><span class="line">        int n&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;请输入移动的位数：&quot;);</span><br><span class="line">        int m&#x3D;in.nextInt();</span><br><span class="line">        int [] arr&#x3D;new int [n];</span><br><span class="line">        int [] brr&#x3D;new int [n];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个数：&quot;);</span><br><span class="line">            arr[i]&#x3D;in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序前：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            brr[i]&#x3D;arr[n-m+i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n-m;i++)&#123;</span><br><span class="line">            arr[m+i]&#x3D;arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i]&#x3D;brr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序后：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。</p><p>（约瑟夫环问题，百度百科有时间复杂度最简单的数学方法）</p><p>原例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输人数n：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        boolean[] arr &#x3D; new boolean[n];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; true; &#x2F;&#x2F;下标为TRUE时说明还在圈里</span><br><span class="line">        &#125;</span><br><span class="line">        int leftCount &#x3D; n;</span><br><span class="line">        int countNum &#x3D; 0;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (leftCount &gt; 1) &#123;</span><br><span class="line">            if (arr[index] &#x3D;&#x3D; true) &#123; &#x2F;&#x2F;当在圈里时</span><br><span class="line">                countNum++;  &#x2F;&#x2F;报数递加</span><br><span class="line">                if (countNum &#x3D;&#x3D; 3) &#123; &#x2F;&#x2F;报数为3时</span><br><span class="line">                    countNum &#x3D; 0; &#x2F;&#x2F;从零开始继续报数</span><br><span class="line">                    arr[index] &#x3D; false; &#x2F;&#x2F;此人退出圈子</span><br><span class="line">                    leftCount--; &#x2F;&#x2F;剩余人数减一</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++; &#x2F;&#x2F;每报一次数，下标加一</span><br><span class="line">            if (index &#x3D;&#x3D; n) &#123; &#x2F;&#x2F;是循环数数，当下标大于n时，说明已经数了一圈，</span><br><span class="line">                index &#x3D; 0; &#x2F;&#x2F;将下标设为零重新开始。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (arr[i] &#x3D;&#x3D; true) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入人数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] a &#x3D; new int[in.nextInt()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int left &#x3D; a.length;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        while (left &gt; 1) &#123;</span><br><span class="line">            if (a[j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (num &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                a[j] &#x3D; 0;</span><br><span class="line">                num &#x3D; 0;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            if (j &#x3D;&#x3D; a.length) &#123;</span><br><span class="line">                j &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                System.out.println(&quot;最后留下的人是&quot;+ (i + 1) + &quot;号&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; l &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        System.out.println(&quot;请输入人数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int len &#x3D; in.nextInt();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            l.add(i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; sum !&#x3D; len - 1;) &#123;</span><br><span class="line">            if (l.get(i) !&#x3D; 0) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                l.remove(i);</span><br><span class="line">                l.add(i, 0);</span><br><span class="line">                temp &#x3D; 0;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            if (i &#x3D;&#x3D; l.size()) &#123;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int t : l) &#123;</span><br><span class="line">            if (t !&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(&quot;最后留下的人是&quot; + t + &quot;号&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。"><a href="#写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。" class="headerlink" title="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。"></a>写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo38 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String mys &#x3D; in.next();</span><br><span class="line">        System.out.println(str_len(mys));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int str_len(String x) &#123;</span><br><span class="line">        return x.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo38 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String mys &#x3D; in.next();</span><br><span class="line">        System.out.println(mys.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写一个函数，输入n为偶数时，调用函数求1-2-1-4-…-1-n-当输入n为奇数时，调用函数1-1-1-3-…-1-n"><a href="#编写一个函数，输入n为偶数时，调用函数求1-2-1-4-…-1-n-当输入n为奇数时，调用函数1-1-1-3-…-1-n" class="headerlink" title="编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n"></a>编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo39 &#123;</span><br><span class="line">    public static double ouShu(int n) &#123;</span><br><span class="line">        double result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; n; i &#x3D; i + 2) &#123;</span><br><span class="line">            result +&#x3D;  1 &#x2F; (double) i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public static double jiShu(int n) &#123;</span><br><span class="line">        double result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i &#x3D; i + 2) &#123;</span><br><span class="line">            result +&#x3D; 1 &#x2F; (double) i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入n的值：&quot;);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        if (n % 2 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;偶数，1&#x2F;2+1&#x2F;4+...+1&#x2F;n</span><br><span class="line">            System.out.println(ouShu(n));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;奇数，1&#x2F;1+1&#x2F;3+...+1&#x2F;n</span><br><span class="line">            System.out.println(jiShu(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><p>（利用容器类中的sort方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo40 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(&quot;010102&quot;);</span><br><span class="line">        list.add(&quot;010003&quot;);</span><br><span class="line">        list.add(&quot;010201&quot;);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Demo40 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请定义字符串的个数：&quot;);</span><br><span class="line">        int n&#x3D;in.nextInt();</span><br><span class="line">        String[] str&#x3D;new String[n];</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.length;i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;字符串：&quot;);</span><br><span class="line">            str[i]&#x3D;in.next();</span><br><span class="line">        &#125;</span><br><span class="line">        strSort(n,str);</span><br><span class="line">        System.out.println(&quot;字符串排序后：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.length;i++)&#123;</span><br><span class="line">            System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void strSort(int n,String[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++) &#123;</span><br><span class="line">            for(int j&#x3D;i+1; j&lt;n; j++) &#123;</span><br><span class="line">                if(compare(arr[i], arr[j]) &#x3D;&#x3D; false) &#123;</span><br><span class="line">                    String temp &#x3D; arr[i]; arr[i] &#x3D; arr[j]; arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static boolean compare(String s1, String s2) &#123;</span><br><span class="line">        boolean result &#x3D; true;</span><br><span class="line">        for(int i&#x3D;0; i&lt;s1.length() &amp;&amp; i&lt;s2.length(); i++) &#123;</span><br><span class="line">            if(s1.charAt(i) &gt; s2.charAt(i)) &#123;</span><br><span class="line">                result &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if(s1.charAt(i) &lt;s2.charAt(i)) &#123;</span><br><span class="line">                result &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(s1.length() &lt; s2.length()) &#123;</span><br><span class="line">                    result &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴子分桃"><a href="#猴子分桃" class="headerlink" title="猴子分桃"></a>猴子分桃</h2><p>海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？</p><p>本题源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Demo41 &#123;</span><br><span class="line">    static int ts &#x3D; 0;&#x2F;&#x2F; 桃子总数</span><br><span class="line">    int fs &#x3D; 1;&#x2F;&#x2F; 记录分的次数</span><br><span class="line">    static int hs &#x3D; 5;&#x2F;&#x2F; 猴子数</span><br><span class="line">    int tsscope &#x3D; 5000;&#x2F;&#x2F; 桃子数的取值范围，太大容易溢出。</span><br><span class="line">    public int fT(int t) &#123;</span><br><span class="line">        if (t &#x3D;&#x3D; tsscope) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当桃子数到了最大的取值范围时取消递归</span><br><span class="line">            System.out.println(&quot;结束&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ((t - 1) % hs &#x3D;&#x3D; 0 &amp;&amp; fs &lt;&#x3D; hs) &#123;</span><br><span class="line">                if (fs &#x3D;&#x3D; hs) &#123;</span><br><span class="line">                    System.out.println(&quot;桃子数&#x3D;&quot; + ts + &quot;时满足分桃条件&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                fs +&#x3D; 1;</span><br><span class="line">                return fT((t - 1) &#x2F; 5 * 4);&#x2F;&#x2F; 返回猴子拿走一份后的剩下的总数</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 没满足条件</span><br><span class="line">                fs &#x3D; 1;&#x2F;&#x2F; 分的次数重置为1</span><br><span class="line">                return fT(ts +&#x3D; 1);&#x2F;&#x2F; 桃子数加+1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Demo41().fT(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo41 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 6;; i++) &#123;&#x2F;&#x2F; 最少6个分最后一次</span><br><span class="line">            sum &#x3D; i;&#x2F;&#x2F; 桃子数</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 5; j++) &#123;&#x2F;&#x2F; 分的次数循环</span><br><span class="line">                if ((sum - 1) % 5 &#x3D;&#x3D; 0 &amp;&amp; j &lt; 5) &#123;&#x2F;&#x2F; 如果扔一个后能均分5份，继续分</span><br><span class="line">                    sum &#x3D; (sum - 1) &#x2F; 5 * 4;&#x2F;&#x2F; 每分一次剩余桃子数</span><br><span class="line">                    if (j &#x3D;&#x3D; 4) &#123;&#x2F;&#x2F; 如果已分5次，且仍能除尽，输出，退出程序</span><br><span class="line">                        System.out.println(i);</span><br><span class="line">                        System.exit(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="809-800-9-1。其中-代表的两位数-8-的结果为两位数，9-的结果为3位数。求-代表的两位数，及809-后的结果。"><a href="#809-800-9-1。其中-代表的两位数-8-的结果为两位数，9-的结果为3位数。求-代表的两位数，及809-后的结果。" class="headerlink" title="809*??=800*??+9*??+1。其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。"></a>809*??=800*??+9*??+1。其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。</h2><p>（本题为无解，去掉1有解）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo42 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 10; i &lt; 100; i++) &#123;</span><br><span class="line">            if (809 * i &#x3D;&#x3D; (800 * i + 9 * i + 1) &amp;&amp; 8 * i &gt;&#x3D; 10 &amp;&amp; 8 * i &lt; 100</span><br><span class="line">                    &amp;&amp; 9 * i &gt;&#x3D; 100 &amp;&amp; 9 * i &lt; 1000) &#123;</span><br><span class="line">                System.out.println(&quot;?? &#x3D;&quot; + i);</span><br><span class="line">                System.out.println(&quot;809*??&#x3D;&quot;+ 809 * i);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求0—7所能组成的奇数个数"><a href="#求0—7所能组成的奇数个数" class="headerlink" title="求0—7所能组成的奇数个数"></a>求0—7所能组成的奇数个数</h2><p>暴力算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static boolean isJiShu(int n) &#123;</span><br><span class="line">        if (n % 2 !&#x3D; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean fun(char c) &#123;</span><br><span class="line">        if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;7&#39;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        String s;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">            s &#x3D; &quot;&quot; + i;</span><br><span class="line">            boolean flag &#x3D; true;</span><br><span class="line">            char[] c &#x3D; s.toCharArray();</span><br><span class="line">            for (int j &#x3D; 0; j &lt; c.length; j++) &#123;</span><br><span class="line">                if (!fun(c[j])) &#123;</span><br><span class="line">                    flag &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag &amp;&amp; isJiShu(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            s &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;共&quot; + count + &quot;个。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 因为是奇数，所以个位只能是1，3，5，7共4种，前面可随便排列</span><br><span class="line">        int count &#x3D; 4;&#x2F;&#x2F; 个位的4种</span><br><span class="line">        &#x2F;&#x2F; 2位时，十位有8种，个位4种，8×4</span><br><span class="line">        &#x2F;&#x2F; 3位时，8×8×4……</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 8; i++) &#123;</span><br><span class="line">            count &#x3D; 8 * count;</span><br><span class="line">            System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;组成1位数是4个。</span><br><span class="line">&#x2F;&#x2F;组成2位数是7*4个。</span><br><span class="line">&#x2F;&#x2F;组成3位数是7*8*4个。</span><br><span class="line">&#x2F;&#x2F;组成4位数是7*8*8*4个。</span><br><span class="line"></span><br><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        int sum&#x3D;4;</span><br><span class="line">        int j;</span><br><span class="line">        System.out.println(&quot;组成1位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        sum&#x3D;sum*7;</span><br><span class="line">        System.out.println(&quot;组成2位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        for(j&#x3D;3;j&lt;&#x3D;9;j++)&#123;</span><br><span class="line">            sum&#x3D;sum*8;</span><br><span class="line">            System.out.println(&quot;组成&quot;+j+&quot;位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个偶数总能表示为两个素数之和"><a href="#一个偶数总能表示为两个素数之和" class="headerlink" title="一个偶数总能表示为两个素数之和"></a>一个偶数总能表示为两个素数之和</h2><p>哥德巴赫猜想是想证明对任何大于6的自然数n之内的所有偶数可以表示为两个素数之和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo44 &#123;</span><br><span class="line">    public static boolean isSuShu(int x) &#123;</span><br><span class="line">        if (x &#x3D;&#x3D; 0 || x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; Math.sqrt(x); i++) &#123;</span><br><span class="line">            if (x % i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 求了下100以内的情况</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i &#x3D; i + 2)&#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;&#x3D; (i + 1) &#x2F; 2; j++)&#123;</span><br><span class="line">                if (isSuShu(j) &amp;&amp; isSuShu(i - j))&#123;</span><br><span class="line">                    System.out.println(i + &quot;&#x3D;&quot; + j + &quot;+&quot; + (i - j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Demo44&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for (int i&#x3D;6;i&lt;&#x3D;100 ;i+&#x3D;2 )&#123;</span><br><span class="line">            for (int j&#x3D;2;j&lt;100 ;j++ )&#123;</span><br><span class="line">                if(!isPrime(j)||!isPrime(i-j)||j&gt;&#x3D;i)</span><br><span class="line">                continue;</span><br><span class="line">                System.out.println(i+&quot;&#x3D;&quot;+j+&quot;+&quot;+(i-j));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isPrime(int n)&#123;</span><br><span class="line">        for (int i&#x3D;2;i&lt;n ;i++ )&#123;</span><br><span class="line">            if(n%i&#x3D;&#x3D;0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断几个9能被一个素数整除"><a href="#判断几个9能被一个素数整除" class="headerlink" title="判断几个9能被一个素数整除"></a>判断几个9能被一个素数整除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class Demo45&#123;</span><br><span class="line">    public static boolean isSuShu(int x)&#123;</span><br><span class="line">        if (x &#x3D;&#x3D; 0|| x &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; Math.sqrt(x); i++)&#123;</span><br><span class="line">            if (x % i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] a &#x3D; new int[100];</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 长度100的素数数组</span><br><span class="line">        while (n &lt; 100) &#123;</span><br><span class="line">            if (isSuShu(num)) &#123;</span><br><span class="line">                a[n] &#x3D; num;</span><br><span class="line">                n++;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* for (int t : a) &#123;</span><br><span class="line">         System.out.println(t);</span><br><span class="line">         &#125;*&#x2F;</span><br><span class="line">        String s &#x3D; &quot;9&quot;;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (s.length() &lt; 9) &#123;</span><br><span class="line">            if (new Integer(s).intValue() % a[index] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(s + &quot;%&quot; + a[index] + &quot;&#x3D;0&quot;);</span><br><span class="line">                if (index &lt; 100 - 1) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    index &#x3D; 0;</span><br><span class="line">                    s &#x3D; s + &quot;9&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; System.exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (index &lt; 100 - 1) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    index &#x3D; 0;</span><br><span class="line">                    s &#x3D; s + &quot;9&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）"><a href="#判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）" class="headerlink" title="判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）"></a>判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo45 &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个整数：&quot;);</span><br><span class="line">        int num &#x3D; in.nextInt();</span><br><span class="line">        int tmp &#x3D; num;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0 ; tmp%9 &#x3D;&#x3D; 0 ;)&#123;</span><br><span class="line">            tmp &#x3D; tmp&#x2F;9;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num+&quot; 能够被 &quot;+count+&quot; 个9 整除。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个字符串连接程序"><a href="#两个字符串连接程序" class="headerlink" title="两个字符串连接程序"></a>两个字符串连接程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo46 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入第一个字符串：&quot;);</span><br><span class="line">        String s1 &#x3D; in.next();</span><br><span class="line">        System.out.println(&quot;输入第一个字符串：&quot;);</span><br><span class="line">        String s2 &#x3D; in.next();</span><br><span class="line">        System.out.println(&quot;连接后：n&quot; + s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo46 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String str1 &#x3D; in.nextLine();</span><br><span class="line">        System.out.print(&quot;请再输入一个字符串：&quot;);</span><br><span class="line">        String str2 &#x3D; in.nextLine();</span><br><span class="line">        String str &#x3D; str1+str2;</span><br><span class="line">        System.out.println(&quot;连接后的字符串是：&quot;+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的-号"><a href="#读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的-号" class="headerlink" title="读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的*号"></a>读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的*号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo47 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int n&#x3D;1,num;</span><br><span class="line">        while(n&lt;&#x3D;7)&#123;</span><br><span class="line">            do&#123;</span><br><span class="line">                System.out.print(&quot;请输入一个1--50 之间的整数：&quot;);</span><br><span class="line">                num&#x3D; s.nextInt();</span><br><span class="line">            &#125;while(num&lt;1||num&gt;50);</span><br><span class="line">            for(int i&#x3D;1;i&lt;&#x3D;num;i++)</span><br><span class="line">            &#123;System.out.print(&quot;*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo47 &#123;</span><br><span class="line">    public static void print(int n) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(&quot;*&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 7; i++) &#123;</span><br><span class="line">            int temp &#x3D; in.nextInt();</span><br><span class="line">            print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"><a href="#某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。" class="headerlink" title="某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"></a>某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo48&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个4位数字：&quot;);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        if (!((str).matches(&quot;\\d&#123;4&#125;&quot;))) &#123;</span><br><span class="line">            System.out.println(&quot;输入的不是4位数字！&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        char[] c &#x3D; str.toCharArray();</span><br><span class="line">        int[] a &#x3D; new int[4];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] &#x3D; ((int) (c[i] - &#39;0&#39;) + 5) % 10;</span><br><span class="line">        &#125;</span><br><span class="line">        int t;</span><br><span class="line">        t &#x3D; a[0];</span><br><span class="line">        a[0] &#x3D; a[3];</span><br><span class="line">        a[3] &#x3D; t;</span><br><span class="line">        t &#x3D; a[1];</span><br><span class="line">        a[1] &#x3D; a[2];</span><br><span class="line">        a[2] &#x3D; t;</span><br><span class="line">        System.out.println(&quot;结果是：&quot; + a[0] + a[1] + a[2] + a[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo48 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int num&#x3D;0,temp;</span><br><span class="line">        do&#123;</span><br><span class="line">            System.out.print(&quot;请输入一个4位正整数：&quot;);</span><br><span class="line">            num &#x3D; s.nextInt();</span><br><span class="line">        &#125;while (num&lt;1000||num&gt;9999);</span><br><span class="line">        int a[]&#x3D;new int[4];</span><br><span class="line">        a[0] &#x3D; num&#x2F;1000; &#x2F;&#x2F;取千位的数字</span><br><span class="line">        a[1] &#x3D; (num&#x2F;100)%10; &#x2F;&#x2F;取百位的数字</span><br><span class="line">        a[2] &#x3D; (num&#x2F;10)%10; &#x2F;&#x2F;取十位的数字</span><br><span class="line">        a[3] &#x3D; num%10; &#x2F;&#x2F;取个位的数字</span><br><span class="line">        for(int j&#x3D;0;j&lt;4;j++) &#123;</span><br><span class="line">            a[j]+&#x3D;5; a[j]%&#x3D;10;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;&#x3D;1;j++) &#123;</span><br><span class="line">            temp &#x3D; a[j]; a[j] &#x3D; a[3-j]; a[3-j] &#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;加密后的数字为：&quot;);</span><br><span class="line">        for(int j&#x3D;0;j&lt;4;j++) System.out.print(a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符串中子串出现的次数"><a href="#计算字符串中子串出现的次数" class="headerlink" title="计算字符串中子串出现的次数"></a>计算字符串中子串出现的次数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo49 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入主串：&quot;);</span><br><span class="line">        String str1 &#x3D; in.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入子串：&quot;);</span><br><span class="line">        String str2 &#x3D; in.nextLine();</span><br><span class="line">        &#x2F;&#x2F; 生成子串长度的N个字符串数组</span><br><span class="line">        String[] sa &#x3D; new String[str1.length() - str2.length() + 1];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sa.length; i++) &#123;</span><br><span class="line">            sa[i] &#x3D; str1.substring(i, i + str2.length());</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 子串与N个拆开的子串比对</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sa.length; i++) &#123;</span><br><span class="line">            if (sa[i].equals(str2)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 成功配对，计数器+1；</span><br><span class="line">                sum++;</span><br><span class="line">                &#x2F;&#x2F; 因为不计算重叠的子串，所以跳过配对之后的部分拆分子串</span><br><span class="line">                i &#x3D; i + str2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;主串中共包含&quot; + sum + &quot;个字串&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文"><a href="#有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文" class="headerlink" title="有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文"></a>有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">class Student &#123;</span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line">    private String name &#x3D; &quot;&quot;;</span><br><span class="line">    private double[] a &#x3D; new double[3];</span><br><span class="line">    public double getAve() &#123;</span><br><span class="line">        return (a[0] + a[1] + a[2]) &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(int number, String name, double[] a) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.number &#x3D; number;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;学号：&quot; + this.number + &quot;\t姓名：&quot; + this.name + &quot;\r\n各科成绩：\r\n&quot; + a[0] + &quot;\\t&quot; + a[1] + &quot;\\t&quot; + a[2] + &quot;\r\n平均成绩：\r\n&quot;+ this.getAve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo50 &#123;</span><br><span class="line">    public static Student input() &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入学号：&quot;);</span><br><span class="line">        int num &#x3D; s.nextInt();</span><br><span class="line">        System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">        String name &#x3D; s.next();</span><br><span class="line">        System.out.println(&quot;请分别输入3门成绩：&quot;);</span><br><span class="line">        double[] a &#x3D; new double[3];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            a[i] &#x3D; s.nextDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        return new Student(num, name, a);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Student[] st &#x3D; new Student[2];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; st.length; i++) &#123;</span><br><span class="line">            st[i] &#x3D; input();</span><br><span class="line">        &#125;</span><br><span class="line">        File f &#x3D; new File(&quot;d:&quot; + File.separator + &quot;123.txt&quot;);</span><br><span class="line">        FileWriter output &#x3D; new FileWriter(f);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; st.length; i++) &#123;</span><br><span class="line">            output.write(st[i].toString() + &quot;\r\n&quot;);</span><br><span class="line">            output.write(&quot;\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon扩展点</title>
      <link href="2020/11/16/Ribbon%E6%89%A9%E5%B1%95%E7%82%B9/"/>
      <url>2020/11/16/Ribbon%E6%89%A9%E5%B1%95%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="7个核心接口"><a href="#7个核心接口" class="headerlink" title="7个核心接口"></a>7个核心接口</h2><table><thead><tr><th>接口</th><th>简述</th><th>默认实现</th></tr></thead><tbody><tr><td>IClientConfig</td><td>定义ribbon中管理配置的接口</td><td>DefaultClientConfigImpl</td></tr><tr><td>IRule</td><td>定义ribbon中负载均衡策略的接口</td><td>ZoneAvoidanceRule</td></tr><tr><td>IPing</td><td>定义定期ping服务，检查可用性的接口</td><td>DummyPing</td></tr><tr><td>ServerList<Server></Server></td><td>定义获取服务列表方法的接口</td><td>ConfigurationBasedServerList</td></tr><tr><td>ServerListFilter<Server></Server></td><td>定义特定场景下，获取服务列表的方法接口</td><td>ZonePreferenceServerListFilter</td></tr><tr><td>ILoadBalancer</td><td>定义负载均衡选择服务的核心方法接口</td><td>ZoneAwareLoadBalancer</td></tr><tr><td>ServerListUpdater</td><td>为DynamicServerListLoadBalancer定义动态更新服务列表的接口</td><td>PollingServerListUpdater</td></tr></tbody></table><p>Ribbon的加载策略是懒加载，即第一次请求的时候才加载对应上下文，正是这个原因，很多时候第一次调用显得很慢，甚至会超时，所以，可以通过指定ribbon具体服务名称来开启饿加载，即在工程启动的时候，加载所有的配置上下文。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: client-a, client-b, client-c</span><br></pre></td></tr></table></figure><p>ribbon在1.2.0版本以后，<font color="red"><strong>可以使用配置文件来定制ribbon客户端，这种优先级最高</strong></font>，高于使用@RibbonClient注解指定配置。</p><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td><clientName>.ribbon.NFLoadBalancerClassName</clientName></td><td>指定ILoadBalancer的实现类</td></tr><tr><td><clientName>.ribbon.NFLoadBalancerRuleClassName</clientName></td><td>指定IRule的实现类</td></tr><tr><td><clientName>.ribbon.NFLoadBalancerPingClassName</clientName></td><td>指定IPing的实现类</td></tr><tr><td><clinetName>.ribbon.NIWSServerListClassName</clinetName></td><td>指定ServerList的实现类</td></tr><tr><td><clientName>.ribbon.NIWSServerListFilterClassName</clientName></td><td>指定ServerListFilter的实现类</td></tr></tbody></table><p>可以使用ribbon的自带实现类，也可以使用我们自定义的接口实现类，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NIWSServerListClass:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span> <span class="comment">#指定ServerList的实现类</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#指定IRule的实现类</span></span><br></pre></td></tr></table></figure><p>默认情况下，ribbon客户端会从eureka注册中心获取服务注册列表，然后做负载均衡策略，但是如果想要ribbon客户端脱离eureka使用，可以为ribbon客户端指定服务的地址，如下操作：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">ribbon.eureka.enabled</span>=<span class="string">false #一定要关闭ribbon中的eureka功能</span></span><br><span class="line"><span class="meta">client.ribbon.listOfServers</span>=<span class="string">http://localhost:7070,http://localhost:7171 #指定服务地址</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon负载均衡</title>
      <link href="2020/11/16/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2020/11/16/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="ribbon负载均衡策略"><a href="#ribbon负载均衡策略" class="headerlink" title="ribbon负载均衡策略"></a>ribbon负载均衡策略</h2><p>ribbon有7种负载均衡策略可供选择：</p><table><thead><tr><th>策略类</th><th>命名</th><th>描述</th></tr></thead><tbody><tr><td>RandomRule</td><td>随机策略</td><td>随机选择server</td></tr><tr><td>RoundRobinRule</td><td>轮询策略</td><td>按照顺序选择server（ribbon默认策略）</td></tr><tr><td>RetryRule</td><td>重试策略</td><td>在一个配置时间段内，当选择server不成功，则一直尝试选择一个可用的server</td></tr><tr><td>BestAvailableRule</td><td>最低并发策略</td><td>逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server</td></tr><tr><td>AvailabilityFilteringRule</td><td>可用过滤策略</td><td>过滤掉一直失败并被标记为circuit tripped的server，过滤掉那些高并发链接的server（active connections超过配置的阈值）</td></tr><tr><td>ResponseTimeWeightedRule</td><td>响应时间加权重策略</td><td>根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间</td></tr><tr><td>ZoneAvoidanceRule</td><td>区域权重策略</td><td>综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server</td></tr></tbody></table><a id="more"></a><h2 id="配置策略"><a href="#配置策略" class="headerlink" title="配置策略"></a>配置策略</h2><ul><li><p>使用java注解配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(value = &#123;</span></span><br><span class="line"><span class="meta">    @RibbonClient(name = &quot;order-service&quot;, configuration = RoundRobinRule.class)</span></span><br><span class="line"><span class="meta">&#125;, defaultConfiguration = NativeRibbonRule.class)</span></span><br></pre></td></tr></table></figure></li><li><p>使用配置文件方式配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#针对client-a服务使用随机策略</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="重试及超时配置"><a href="#重试及超时配置" class="headerlink" title="重试及超时配置"></a>重试及超时配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment">#对第一次请求的服务的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment">#要重试的下一个服务的最大数量（不包括第一个服务）</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#说明：这里配置的ConnectTimeout和ReadTimeout是当HTTP客户端使用的是HttpClient才生效，这个时间最终会被设置到HttpClient中。</span></span><br><span class="line"><span class="comment">#在设置的时候需要结合hystrix的超时时间来综合考虑，针对使用的场景，设置太小会导致很多请求失败，设置太大会导致熔断控制变差。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github上创建hexo博客</title>
      <link href="2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装node.js </p></li><li><p>安装hexo。npm install -g hexo-cli</p></li><li><p>hexo项目初始化。hexo init &lt;新建文件夹的名称&gt;</p></li><li><p>如果是从git上下载下来的hexo项目，安装依赖包。npm install –force</p></li><li><p>创建文章。 hexo new post fileName</p></li><li><p>发布文章。hexo d (修改配置文件，安装npm install hexo-deployer-git –save)</p></li><li><p>启动。hexo s</p></li><li><p>编译。hexo g</p></li></ol><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><strong>安装插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/luckyfeing/luckyfeing.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">&#x27;发布文章&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="图片使用"><a href="#图片使用" class="headerlink" title="图片使用"></a>图片使用</h2><ul><li>图床，如七牛云，阿里云，可以借助<a href="http://markdown.xiaoshujiang.com/">小书匠在线markdown工具</a>,可以配置图片上传图床如github。</li><li>相对路径图片，选择<strong>相对路径图片解决方案</strong>，借助Typora配置</li><li>base64图片，在线编码</li></ul><p><strong>安装插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p><strong>修改插件js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">config.post_asset_folder</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>Typora配置图片设置</strong></p><p>可以配置本地图片（相对路径），也可以配置图片上传，借助PicGo工具，配置图片上传</p><p><img src="/2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/Typora%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E8%AE%BE%E7%BD%AE.jpg"></p><h2 id="创建tags"><a href="#创建tags" class="headerlink" title="创建tags"></a>创建tags</h2><p><strong>创建页面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p><strong>修改新文件内容</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tagcloud</span><br><span class="line">date: 2017-06-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>新增文章添加标签tags</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016-03-16 08:12:43</span><br><span class="line">tags:</span><br><span class="line">categories: 前端</span><br><span class="line">--- </span><br></pre></td></tr></table></figure><h2 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h2><p><strong>创建页面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p><strong>修改新文件内容</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>新增文章添加分类categories</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016-03-16 08:12:43</span><br><span class="line">tags:</span><br><span class="line">categories: 前端</span><br><span class="line">--- </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo简单命令</title>
      <link href="2020/11/13/hexo%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
      <url>2020/11/13/hexo%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
