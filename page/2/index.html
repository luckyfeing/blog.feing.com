<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="学习还是需要记录">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="学习还是需要记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="灰(｢･ω･)｢嘿灰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">灰(｢･ω･)｢嘿灰</p>
  <div class="site-description" itemprop="description">学习还是需要记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/mysql%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/mysql%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">mysql之存储引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-22 16:03:14 / Modified: 16:28:23" itemprop="dateCreated datePublished" datetime="2020-12-22T16:03:14+08:00">2020-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>MySQL 有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</span><br></pre></td></tr></table></figure>

<p>MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎：</p>
<ul>
<li><p><strong>MyISAM</strong>管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。</p>
</li>
<li><p><strong>MEMORY</strong>存储引擎提供”内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中。</p>
<p>注释：MEMORY存储引擎正式地被确定为HEAP引擎。</p>
</li>
<li><p><strong>InnoDB</strong>和BDB存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎。</p>
</li>
<li><p><strong>EXAMPLE</strong>存储引擎是一个”存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。</p>
</li>
<li><p><strong>NDB Cluster</strong>是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows。</p>
</li>
<li><p><strong>ARCHIVE</strong>存储引擎被用来无索引地，非常小地覆盖存储的大量数据。</p>
</li>
<li><p><strong>CSV</strong>存储引擎把数据以逗号分隔的格式存储在文本文件中。</p>
</li>
<li><p><strong>BLACKHOLE</strong>存储引擎接受但不存储数据，并且检索总是返回一个空集。</p>
</li>
<li><p><strong>FEDERATED</strong>存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动器或客户端连接方法连接到另外的数据源。</p>
</li>
</ul>
<h2 id="比较常用的是-MyISAM-和-InnoBD"><a href="#比较常用的是-MyISAM-和-InnoBD" class="headerlink" title="比较常用的是 MyISAM 和 InnoBD"></a>比较常用的是 MyISAM 和 InnoBD</h2><table>
<thead>
<tr>
<th></th>
<th><strong>MyISAM</strong></th>
<th><strong>InnoDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>构成上的区别：</strong></td>
<td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。  <br>     .frm文件存储表定义。   <br>     数据文件的扩展名为.MYD (MYData)。    <br>     索引文件的扩展名是.MYI (MYIndex)。</td>
<td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td>
</tr>
<tr>
<td><strong>事务处理上方面:</strong></td>
<td>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持</td>
<td>InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能</td>
</tr>
<tr>
<td><strong>SELECT  UPDATE,INSERT，Delete操作</strong></td>
<td>如果执行大量的SELECT，MyISAM是更好的选择</td>
<td><strong>1.**如果你的数据执行大量的</strong>INSERT<strong>或</strong>UPDATE<strong>，出于性能方面的考虑，应该使用InnoDB表   **2.DELETE  FROM table</strong>时，InnoDB不会重新建立表，而是一行一行的删除。   <strong>3.LOAD  TABLE FROM MASTER</strong>操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用</td>
</tr>
<tr>
<td><strong>对AUTO_INCREMENT的操作</strong></td>
<td>每表一个AUTO_INCREMEN列的内部处理。   <strong>MyISAM为INSERT和UPDATE操作自动更新这一列</strong>。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。   AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置   对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引   更好和更快的auto_increment处理</td>
<td>如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。   自动增长计数器仅被存储在主内存中，而不是存在磁盘上   关于该计算器的算法实现，请参考   <strong>AUTO_INCREMENT列在InnoDB里如何工作</strong></td>
</tr>
<tr>
<td><strong>表的具体行数</strong></td>
<td>select count(<em>) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(</em>)语句包含  where条件时，两种表的操作是一样的</td>
<td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行</td>
</tr>
<tr>
<td><strong>锁</strong></td>
<td>表锁</td>
<td>提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in   SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%”</td>
</tr>
</tbody></table>
<h2 id="MySQL-存储引擎-MyISAM-与-InnoDB-如何选择？"><a href="#MySQL-存储引擎-MyISAM-与-InnoDB-如何选择？" class="headerlink" title="MySQL 存储引擎 MyISAM 与 InnoDB 如何选择？"></a>MySQL 存储引擎 MyISAM 与 InnoDB 如何选择？</h2><p>虽然 MySQL 里的存储引擎不只是 MyISAM 与 InnoDB 这两个，但常用的就是它俩了。可能有站长并未注意过 MySQL 的存储引擎，其实存储引擎也是数据库设计里的一大重要点，那么博客系统应该使用哪种存储引擎呢？</p>
<p>下面我们分别来看两种存储引擎的区别。</p>
<ul>
<li>一、InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</li>
<li>二、MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</li>
<li>三、InnoDB支持外键，MyISAM不支持</li>
<li>四、MyISAM是默认引擎，InnoDB需要指定</li>
<li>五、InnoDB不支持FULLTEXT类型的索引</li>
<li>六、InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表</li>
<li>七、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引</li>
<li>八、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表</li>
<li>九、InnoDB支持行锁（某些情况下还是锁整表，如 <strong>update table set a=1 where user like ‘%lee%’</strong></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/MQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/MQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">MQTT之基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-22 15:01:12 / Modified: 17:41:05" itemprop="dateCreated datePublished" datetime="2020-12-22T15:01:12+08:00">2020-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>出处：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/mqtt-intro.html">MQTT 入门介绍</a></p>
<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>
<p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<p><img src="/2020/12/22/MQTT%E4%B9%8B%E5%9F%BA%E7%A1%80/mqtt-fidge-2.svg" alt="img"></p>
<hr>
<h2 id="二、设计规范"><a href="#二、设计规范" class="headerlink" title="二、设计规范"></a>二、设计规范</h2><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p>
<ul>
<li>（1）精简，不添加可有可无的功能；</li>
<li>（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</li>
<li>（3）允许用户动态创建主题，零运维成本；</li>
<li>（4）把传输量降到最低以提高传输效率；</li>
<li>（5）把低带宽、高延迟、不稳定的网络等因素考虑在内；</li>
<li>（6）支持连续的会话控制；</li>
<li>（7）理解客户端计算能力可能很低；</li>
<li>（8）提供服务质量管理；</li>
<li>（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li>
</ul>
<hr>
<h2 id="三、主要特性"><a href="#三、主要特性" class="headerlink" title="三、主要特性"></a>三、主要特性</h2><p>MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p>
<ul>
<li><p>（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</p>
<p>这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</p>
</li>
<li><p>（2）对负载内容屏蔽的消息传输。</p>
</li>
<li><p>（3）使用TCP/IP提供网络连接。</p>
<p>主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</p>
</li>
<li><p>（4）有三种消息发布服务质量：</p>
<p>“至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p>
<p>“至少一次”，确保消息到达，但消息重复可能会发生。</p>
<p>“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</p>
</li>
<li><p>（5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。</p>
<p>这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</p>
</li>
<li><p>（6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。</p>
<p>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</p>
<p>Testament：遗嘱机制，功能类似于Last Will。</p>
</li>
</ul>
<hr>
<h2 id="四、MQTT协议原理"><a href="#四、MQTT协议原理" class="headerlink" title="四、MQTT协议原理"></a>四、MQTT协议原理</h2><h3 id="4-1-MQTT协议实现方式"><a href="#4-1-MQTT协议实现方式" class="headerlink" title="4.1 MQTT协议实现方式"></a>4.1 MQTT协议实现方式</h3><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p>
<ul>
<li>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li>
<li>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li>
</ul>
<h3 id="4-2-网络传输与应用消息"><a href="#4-2-网络传输与应用消息" class="headerlink" title="4.2 网络传输与应用消息"></a>4.2 网络传输与应用消息</h3><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p>
<p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p>
<h3 id="4-3-MQTT客户端"><a href="#4-3-MQTT客户端" class="headerlink" title="4.3 MQTT客户端"></a>4.3 MQTT客户端</h3><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p>
<ul>
<li>（1）发布其他客户端可能会订阅的信息；</li>
<li>（2）订阅其它客户端发布的消息；</li>
<li>（3）退订或删除应用程序的消息；</li>
<li>（4）断开与服务器连接。</li>
</ul>
<h3 id="4-4-MQTT服务器"><a href="#4-4-MQTT服务器" class="headerlink" title="4.4 MQTT服务器"></a>4.4 MQTT服务器</h3><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p>
<ul>
<li>（1）接受来自客户的网络连接；</li>
<li>（2）接受客户发布的应用信息；</li>
<li>（3）处理来自客户端的订阅和退订请求；</li>
<li>（4）向订阅的客户转发应用程序消息。</li>
</ul>
<h3 id="4-5-MQTT协议中的订阅、主题、会话"><a href="#4-5-MQTT协议中的订阅、主题、会话" class="headerlink" title="4.5 MQTT协议中的订阅、主题、会话"></a>4.5 MQTT协议中的订阅、主题、会话</h3><p><strong>一、订阅（Subscription）</strong></p>
<p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p>
<p><strong>二、会话（Session）</strong></p>
<p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p>
<p><strong>三、主题名（Topic Name）</strong></p>
<p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p>
<p><strong>四、主题筛选器（Topic Filter）</strong></p>
<p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p>
<p><strong>五、负载（Payload）</strong></p>
<p>消息订阅者所具体接收的内容。</p>
<h3 id="4-6-MQTT协议中的方法"><a href="#4-6-MQTT协议中的方法" class="headerlink" title="4.6 MQTT协议中的方法"></a>4.6 MQTT协议中的方法</h3><p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p>
<ul>
<li>（1）Connect。等待与服务器建立连接。</li>
<li>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li>
<li>（3）Subscribe。等待完成订阅。</li>
<li>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li>
<li>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li>
</ul>
<hr>
<h2 id="五、MQTT协议数据包结构"><a href="#五、MQTT协议数据包结构" class="headerlink" title="五、MQTT协议数据包结构"></a>五、MQTT协议数据包结构</h2><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p>
<ul>
<li>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</li>
<li>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</li>
<li>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</li>
</ul>
<h3 id="5-1-MQTT固定头"><a href="#5-1-MQTT固定头" class="headerlink" title="5.1 MQTT固定头"></a>5.1 MQTT固定头</h3><p>固定头存在于所有MQTT数据包中，其结构如下：</p>
<p><strong>5.1.1 MQTT数据包类型</strong></p>
<p>位置：Byte 1中bits 7-4。</p>
<p>相于一个4位的无符号值，类型、取值及描述如下：</p>
<p><strong>5.1.2 标识位</strong></p>
<p>位置：Byte 1中bits 3-0。</p>
<p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p>
<p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p>
<p>（2）QoS：发布消息的服务质量，即：保证消息传递的次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ø00：最多一次，即：&lt;&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø01：至少一次，即：&gt;&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø10：一次，即：&#x3D;1</span><br><span class="line"></span><br><span class="line">Ø11：预留</span><br></pre></td></tr></table></figure>

<p>（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。 5.1.3 剩余长度（Remaining Length）</p>
<p>地址：Byte 2。</p>
<p>固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0</p>
<h3 id="5-2-MQTT可变头"><a href="#5-2-MQTT可变头" class="headerlink" title="5.2 MQTT可变头"></a>5.2 MQTT可变头</h3><p>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p>
<p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p>
<h3 id="5-3-Payload消息体"><a href="#5-3-Payload消息体" class="headerlink" title="5.3 Payload消息体"></a>5.3 Payload消息体</h3><p>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：</p>
<ul>
<li>（1）CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</li>
<li>（2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</li>
<li>（3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</li>
<li>（4）UNSUBSCRIBE，消息体内容是要订阅的主题。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">分布式事务之Seata简单使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-22 13:33:18 / Modified: 13:38:59" itemprop="dateCreated datePublished" datetime="2020-12-22T13:33:18+08:00">2020-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：程序员内点事<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6899645923024355336">https://juejin.cn/post/6899645923024355336</a></p>
<h2 id="分布式事务由来"><a href="#分布式事务由来" class="headerlink" title="分布式事务由来"></a>分布式事务由来</h2><p>当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1ec31a8cda8745c9bf7793b7bd092616~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="分库分表、SOA"><a href="#分库分表、SOA" class="headerlink" title="分库分表、SOA"></a>分库分表、SOA</h3><p>可随着业务量的不断增长，单体架构渐渐扛不住巨大的流量，此时就需要对数据库、表做 <code>分库分表</code>处理，将应用 <code>SOA</code> 服务化拆分。也就产生了订单中心、用户中心、库存中心等，由此带来的问题就是业务间相互隔离，每个业务都维护着自己的数据库，数据的交换只能进行 <code>RPC</code> 调用。</p>
<p>当用户再次下单时，需同时对订单库 <code>order</code>、库存库 <code>storage</code>、用户库 <code>account</code> 进行操作，可此时我们只能保证自己本地的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7d920f9dedcf454faa0b9313bd17df43~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h2 id="Seata-优势"><a href="#Seata-优势" class="headerlink" title="Seata 优势"></a>Seata 优势</h2><p>实现分布式事务的方案比较多，常见的比如基于 <code>XA</code> 协议的 <code>2PC</code>、<code>3PC</code>，基于业务层的 <code>TCC</code>，还有应用消息队列 + 消息表实现的最终一致性方案，还有今天要说的 <code>Seata</code> 中间件，下边看看各个方案的优缺点。</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a><code>2PC</code></h3><p>基于 XA 协议实现的分布式事务，XA 协议中分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如 Oracle、MYSQL 这些数据库都实现了 XA 接口，而事务管理器则作为一个全局的调度者。</p>
<p>两阶段提交（<code>2PC</code>），对业务侵⼊很小，它最⼤的优势就是对使⽤⽅透明，用户可以像使⽤本地事务⼀样使⽤基于 XA 协议的分布式事务，能够严格保障事务 ACID 特性。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/5d98e869a3d14c9da4ff308899222309~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>可 <code>2PC</code>的缺点也是显而易见，它是一个强一致性的同步阻塞协议，事务执⾏过程中需要将所需资源全部锁定，也就是俗称的 <code>刚性事务</code>。所以它比较适⽤于执⾏时间确定的短事务，整体性能比较差。</p>
<p>一旦事务协调者宕机或者发生网络抖动，会让参与者一直处于锁定资源的状态或者只有一部分参与者提交成功，导致数据的不一致。因此，在⾼并发性能⾄上的场景中，基于 XA 协议的分布式事务并不是最佳选择。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/a34f0af5f47a4ea686dae570643a019e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a><code>3PC</code></h3><p>三段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一种改进版本 ，为解决两阶段提交协议的阻塞问题，上边提到两段提交，当协调者崩溃时，参与者不能做出最后的选择，就会一直保持阻塞锁定资源。</p>
<p><code>2PC</code> 中只有协调者有超时机制，<code>3PC</code> 在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。而且在第一阶段和第二阶段中又插入了一个准备阶段（如下图，看着有点啰嗦），保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/08a0d09a1f684ac89d058ed599c5cb93~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>虽然 <code>3PC</code> 用超时机制，解决了协调者故障后参与者的阻塞问题，但与此同时却多了一次网络通信，性能上反而变得更差，也不太推荐。</p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>所谓的 <code>TCC</code> 编程模式，也是两阶段提交的一个变种，不同的是 <code>TCC</code> 为在业务层编写代码实现的两阶段提交。<code>TCC</code> 分别指 <code>Try</code>、<code>Confirm</code>、<code>Cancel</code> ，一个业务操作要对应的写这三个方法。</p>
<p>以下单扣库存为例，<code>Try</code> 阶段去占库存，<code>Confirm</code> 阶段则实际扣库存，如果库存扣减失败 <code>Cancel</code> 阶段进行回滚，释放库存。</p>
<p>TCC 不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则 <code>Cancel</code> 来进行回滚补偿，这也就是常说的补偿性事务。</p>
<p>原本一个方法，现在却需要三个方法来支持，可以看到 TCC 对业务的侵入性很强，而且这种模式并不能很好地被复用，会导致开发量激增。还要考虑到网络波动等原因，为保证请求一定送达都会有重试机制，所以考虑到接口的幂等性。</p>
<h3 id="消息事务（最终一致性）"><a href="#消息事务（最终一致性）" class="headerlink" title="消息事务（最终一致性）"></a>消息事务（最终一致性）</h3><p>消息事务其实就是基于消息中间件的两阶段提交，将本地事务和发消息放在同一个事务里，保证本地操作和发送消息同时成功。 下单扣库存原理图：</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/55a8781c22844f1794a3edaadac37765~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li>订单系统向 <code>MQ</code> 发送一条预备扣减库存消息，<code>MQ</code> 保存预备消息并返回成功 <code>ACK</code></li>
<li>接收到预备消息执行成功 <code>ACK</code>，订单系统执行本地下单操作，为防止消息发送成功而本地事务失败，订单系统会实现 <code>MQ</code> 的回调接口，其内不断的检查本地事务是否执行成功，如果失败则 <code>rollback</code> 回滚预备消息；成功则对消息进行最终 <code>commit</code> 提交。</li>
<li>库存系统消费扣减库存消息，执行本地事务，如果扣减失败，消息会重新投，一旦超出重试次数，则本地表持久化失败消息，并启动定时任务做补偿。</li>
</ul>
<p>基于消息中间件的两阶段提交方案，通常用在高并发场景下使用，牺牲数据的强一致性换取性能的大幅提升，不过实现这种方式的成本和复杂度是比较高的，还要看实际业务情况。</p>
<h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p><code>Seata</code> 也是从两段提交演变而来的一种分布式事务解决方案，提供了 <code>AT</code>、<code>TCC</code>、<code>SAGA</code> 和 <code>XA</code> 等事务模式，这里重点介绍 <code>AT</code>模式。</p>
<p>既然 <code>Seata</code> 是两段提交，那我们看看它在每个阶段都做了点啥？下边我们还以下单扣库存、扣余额举例。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/f84a66ad84ea4db0bb3970d4a430a8df~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>先介绍 <code>Seata</code> 分布式事务的几种角色：</p>
<ul>
<li><code>Transaction Coordinator(TC)</code>:  全局事务协调者，用来协调全局事务和各个分支事务（不同服务）的状态， 驱动全局事务和各个分支事务的回滚或提交。</li>
<li><code>Transaction Manager™ </code>:  事务管理者，业务层中用来开启/提交/回滚一个整体事务（在调用服务的方法中用注解开启事务）。</li>
<li><code>Resource Manager(RM)</code>:  资源管理者，一般指业务数据库代表了一个分支事务（<code>Branch Transaction</code>），管理分支事务与 <code>TC</code> 进行协调注册分支事务并且汇报分支事务的状态，驱动分支事务的提交或回滚。</li>
</ul>
<blockquote>
<p>Seata 实现分布式事务，设计了一个关键角色 <code>UNDO_LOG</code> （回滚日志记录表），我们在每个应用分布式事务的业务库中创建这张表，这个表的核心作用就是，将业务数据在更新前后的数据镜像组织成回滚日志，备份在 <code>UNDO_LOG</code> 表中，以便业务异常能随时回滚。</p>
</blockquote>
<h3 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h3><p>比如：下边我们更新 <code>user</code> 表的 <code>name</code> 字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;小富最帅&#x27;</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;程序员内点事&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先 Seata 的 <code>JDBC</code> 数据源代理通过对业务 SQL 解析，提取 SQL 的元数据，也就是得到 SQL 的类型（<code>UPDATE</code>），表（<code>user</code>），条件（<code>where name = &#39;程序员内点事&#39;</code>）等相关的信息。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c78f6b5488ac4602acd18e3c9a978d5b~tplv-k3u1fbpfcp-zoom-1.image" alt="第一个阶段的流程图"></p>
<p>先查询数据前镜像，根据解析得到的条件信息，生成查询语句，定位一条数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;程序员内点事&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/c195e1ddd8fb4621a9b8ea35077f35ec~tplv-k3u1fbpfcp-zoom-1.image" alt="数据前镜像"></p>
<p>紧接着执行业务 SQL，根据前镜像数据主键查询出后镜像数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1b4c7bad77e9441a89e47f530ef505cb~tplv-k3u1fbpfcp-zoom-1.image" alt="数据后镜像"></p>
<p>把业务数据在更新前后的数据镜像组织成回滚日志，将业务数据的更新和回滚日志在同一个本地事务中提交，分别插入到业务表和 <code>UNDO_LOG</code> 表中。</p>
<p>回滚记录数据格式如下：包括 <code>afterImage</code> 前镜像、<code>beforeImage</code> 后镜像、 <code>branchId</code> 分支事务ID、<code>xid</code> 全局事务ID</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;branchId&quot;</span>:<span class="number">641789253</span>,</span><br><span class="line">    <span class="attr">&quot;xid&quot;</span>:<span class="string">&quot;xid:xxx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;undoItems&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;afterImage&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;rows&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;fields&quot;</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>:<span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>:<span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;tableName&quot;</span>:<span class="string">&quot;product&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;beforeImage&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;rows&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;fields&quot;</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>:<span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>:<span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;tableName&quot;</span>:<span class="string">&quot;product&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;sqlType&quot;</span>:<span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以保证，任何提交的业务数据的更新一定有相应的回滚日志。</p>
<blockquote>
<p>在本地事务提交前，各分支事务需向 <code>全局事务协调者</code> TC 注册分支 ( <code>Branch Id</code>) ，为要修改的记录申请 <strong>全局锁</strong> ，要为这条数据加锁，利用 <code>SELECT FOR UPDATE</code> 语句。而如果一直拿不到锁那就需要回滚本地事务。TM 开启事务后会生成全局唯一的 <code>XID</code>，会在各个调用的服务间进行传递。</p>
</blockquote>
<p>有了这样的机制，本地事务分支（<code>Branch Transaction</code>）便可以在全局事务的第一阶段提交，并马上释放本地事务锁定的资源。相比于传统的 <code>XA</code> 事务在第二阶段释放资源，<code>Seata</code> 降低了锁范围提高效率，即使第二阶段发生异常需要回滚，也可以快速 从<code>UNDO_LOG</code> 表中找到对应回滚数据并反解析成 SQL 来达到回滚补偿。</p>
<p>最后本地事务提交，业务数据的更新和前面生成的 UNDO LOG 数据一并提交，并将本地事务提交的结果上报给全局事务协调者 TC。</p>
<h3 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h3><p>第二阶段是根据各分支的决议做提交或回滚：</p>
<p>如果决议是全局提交，此时各分支事务已提交并成功，这时 <code>全局事务协调者（TC）</code> 会向分支发送第二阶段的请求。收到 TC 的分支提交请求，该请求会被放入一个异步任务队列中，并马上返回提交成功结果给 TC。异步队列中会异步和批量地根据 <code>Branch ID</code> 查找并删除相应 <code>UNDO LOG</code> 回滚记录。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/592fc4836e8a4f9a9c4c1de690ba166d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>如果决议是全局回滚，过程比全局提交麻烦一点，<code>RM</code> 服务方收到 <code>TC</code> 全局协调者发来的回滚请求，通过 <code>XID</code> 和 <code>Branch ID</code> 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。</p>
<blockquote>
<p>注意：这里删除回滚日志记录操作，一定是在本地业务事务执行之后</p>
</blockquote>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1c40b2c8a80b45acae157850f58cac79~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>上边说了几种分布式事务各自的优缺点，下边实践一下分布式事务中间 Seata 感受一下。</p>
<h2 id="Seata-实践"><a href="#Seata-实践" class="headerlink" title="Seata 实践"></a>Seata 实践</h2><p>Seata 是一个需独立部署的中间件，所以先搭 Seata Server，这里以最新的 <code>seata-server-1.4.0</code> 版本为例，下载地址：<code>https://seata.io/en-us/blog/download.html</code></p>
<p>解压后的文件我们只需要关心 <code>\seata\conf</code> 目录下的 <code>file.conf</code> 和  <code>registry.conf</code> 文件。</p>
<h3 id="Seata-Server"><a href="#Seata-Server" class="headerlink" title="Seata Server"></a>Seata Server</h3><h3 id="file-conf"><a href="#file-conf" class="headerlink" title="file.conf"></a>file.conf</h3><p><code>file.conf</code> 文件用于配置持久化事务日志的模式，目前提供 <code>file</code>、<code>db</code>、<code>redis</code> 三种方式。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/136f615cd12e4e21a0c8ac8c41f6f2a2~tplv-k3u1fbpfcp-zoom-1.image" alt="file.conf 文件配置"></p>
<p><strong>注意</strong>：在选择 <code>db</code> 方式后，需要在对应数据库创建 <code>globalTable</code>（持久化全局事务）、<code>branchTable</code>（持久化各提交分支的事务）、 <code>lockTable</code>（持久化各分支锁定资源事务）三张表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="comment">-- 持久化全局事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`xid`</span>                       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>            <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`status`</span>                    <span class="built_in">TINYINT</span>      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`application_id`</span>            <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_name`</span>          <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    <span class="string">`timeout`</span>                   <span class="built_in">INT</span>,</span><br><span class="line">    <span class="string">`begin_time`</span>                <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`application_data`</span>          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>                DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>              DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="comment">-- 持久化各提交分支的事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`branch_id`</span>         <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>               <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>    <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`resource_id`</span>       <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`branch_type`</span>       <span class="built_in">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="string">`status`</span>            <span class="built_in">TINYINT</span>,</span><br><span class="line">    <span class="string">`client_id`</span>         <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    <span class="string">`application_data`</span>  <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>        DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="string">`gmt_modified`</span>      DATETIME(<span class="number">6</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="comment">-- 持久化每个分支锁表事务</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`row_key`</span>        <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>            <span class="built_in">VARCHAR</span>(<span class="number">96</span>),</span><br><span class="line">    <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>      <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`resource_id`</span>    <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`table_name`</span>     <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`pk`</span>             <span class="built_in">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>     DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>   DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_key`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_branch_id`</span> (<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br></pre></td></tr></table></figure>

<h3 id="registry-conf"><a href="#registry-conf" class="headerlink" title="registry.conf"></a>registry.conf</h3><p><code>registry.conf</code> 文件设置 注册中心 和 配置中心：</p>
<p>目前注册中心支持 <code>nacos</code> 、<code>eureka</code>、<code>redis</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code>、<code>sofa</code> 七种，这里我使用的 <code>eureka</code>作为注册中心 ； 配置中心支持 <code>nacos</code> 、<code>apollo</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code> 五种方式。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/2119d406e05e42268ac3536fa64866dc~tplv-k3u1fbpfcp-zoom-1.image" alt="registry.conf 文件配置"></p>
<p>配置完以后在 <code>\seata\bin</code> 目录下启动 <code>seata-server</code> 即可，到这 <code>Seata</code> 的服务端就搭建好了。</p>
<h3 id="Seata-Client"><a href="#Seata-Client" class="headerlink" title="Seata Client"></a>Seata Client</h3><p><code>Seata Server</code> 环境搭建完，接下来我们新建三个服务 <code>order-server</code>（下单服务）、<code>storage-server</code>（扣减库存服务）、<code>account-server</code>（账户金额服务），分别服务注册到 <code>eureka</code>。</p>
<p>每个服务的大体核心配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">storage-server</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">alibaba:</span></span><br><span class="line">            <span class="attr">seata:</span></span><br><span class="line">                <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://47.93.6.1:3306/seat-storage</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka 注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">serviceUrl:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:8761/eureka/</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="number">47.93</span><span class="number">.6</span><span class="number">.5</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>业务大致流程：用户发起下单请求，本地 order 订单服务创建订单记录，并通过 <code>RPC</code> 远程调用 <code>storage</code> 扣减库存服务和 <code>account</code> 扣账户余额服务，只有三个服务同时执行成功，才是一个完整的下单流程。如果某个服执行失败，则其他服务全部回滚。</p>
<p>Seata 对业务代码的侵入性非常小，代码中使用只需用 <code>@GlobalTransactional</code> 注解开启一个全局事务即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@GlobalTransactional(name = &quot;create-order&quot;, rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String xid = RootContext.getXID();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;交易开始&quot;</span>);</span><br><span class="line">    <span class="comment">//本地方法</span></span><br><span class="line">    orderDao.create(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程方法 扣减库存</span></span><br><span class="line">    storageApi.decrease(order.getProductId(), order.getCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程方法 扣减账户余额</span></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;扣减账户开始order中&quot;</span>);</span><br><span class="line">    accountApi.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;扣减账户结束order中&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;交易结束&quot;</span>);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;全局事务 xid： &#123;&#125;&quot;</span>, xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前边说过 Seata AT 模式实现分布式事务，必须在相关的业务库中创建 <code>undo_log</code> 表来存数据回滚日志，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`undo_log`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span>            <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;increment id&#x27;</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>     <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`xid`</span>           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`context`</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    <span class="string">`rollback_info`</span> LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    <span class="string">`log_status`</span>    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    <span class="string">`log_created`</span>   DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    <span class="string">`log_modified`</span>  DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>, <span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> =<span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这环境搭建的工作就完事了，完整案例会在后边贴出 <code>GitHub</code> 地址，就不在这占用篇幅了。</p>
</blockquote>
<h2 id="测试-Seata"><a href="#测试-Seata" class="headerlink" title="测试 Seata"></a>测试 Seata</h2><p>项目中的服务调用过程如下图：</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/40a44673f4c84450b2a29154accf7b1c~tplv-k3u1fbpfcp-zoom-1.image" alt="服务调用过程"></p>
<p>启动各个服务后，我们直接请求下单接口看看效果，只要 <code>order</code> 订单表创建记录成功，<code>storage</code> 库存表 <code>used</code> 字段数量递增、<code>account</code> 余额表 <code>used</code> 字段数量递增则表示下单流程成功。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d091e25fac5346dc92d1875df942e6de~tplv-k3u1fbpfcp-zoom-1.image" alt="原始数据"></p>
<p>请求后正向流程是没问题的，数据和预想的一样</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/9048853aec764d86a116473450270347~tplv-k3u1fbpfcp-zoom-1.image" alt="下单数据"></p>
<p>而且发现 <code>TM</code> 事务管理者 <code>order-server</code> 服务的控制台也打印出了两阶段提交的日志</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d13de839fd2a4db2af5f5e535d13e41a~tplv-k3u1fbpfcp-zoom-1.image" alt="控制台两次提交"></p>
<p>那么再看看如果其中一个服务异常，会不会正常回滚呢？在 <code>account-server</code> 服务中模拟超时异常，看能否实现全局事务回滚。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/d5d73832fae544828d2bc33d67cd160b~tplv-k3u1fbpfcp-zoom-1.image" alt="全局事务回滚"></p>
<p>发现数据全没执行成功，说明全局事务回滚也成功了</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7307262d393244f890211618ec315630~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>那看一下 <code>undo_log</code> 回滚记录表的变化情况，由于 <code>Seata</code> 删除回滚日志的速度很快，所以要想在表中看见回滚日志，必须要在某一个服务上打断点才看的更明显。</p>
<p><img src="/2020/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/6b06cf8edcfe4bd997e57206b578a3e0~tplv-k3u1fbpfcp-zoom-1.image" alt="回滚记录"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上边简单介绍了 <code>2PC</code>、<code>3PC</code>、<code>TCC</code>、<code>MQ</code>、<code>Seata</code> 这五种分布式事务解决方案，还详细的实践了 <code>Seata</code> 中间件。但不管我们选哪一种方案，在项目中应用都要谨慎再谨慎，除特定的数据强一致性场景外，能不用尽量就不要用，因为无论它们性能如何优越，一旦项目套上分布式事务，整体效率会几倍的下降，在高并发情况下弊端尤为明显。</p>
<blockquote>
<p>本案例 github 地址：<a target="_blank" rel="noopener" href="https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-seata-transaction">https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-seata-transaction</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Zookeeper之简单使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-22 11:00:42 / Modified: 17:53:59" itemprop="dateCreated datePublished" datetime="2020-12-22T11:00:42+08:00">2020-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、初识-zookeeper"><a href="#一、初识-zookeeper" class="headerlink" title="一、初识 zookeeper"></a>一、初识 zookeeper</h2><p><code>Zookeeper</code> 它作为<code>Hadoop</code>项目中的一个开源子项目，是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务。</p>
<h3 id="1、zookeeper数据模型"><a href="#1、zookeeper数据模型" class="headerlink" title="1、zookeeper数据模型"></a>1、zookeeper数据模型</h3><p><code>zookeeper</code> 维护了一个类似文件系统的数据结构，每个子目录（/微信、/微信/公众号）都被称作为 <code>znode</code> 即节点。和文件系统一样，我们可以很轻松的对 <code>znode</code> 节点进行增加、删除等操作，而且还可以在一个<code>znode</code>下增加、删除<code>子znode</code>，区别在于文件系统的是，<code>znode</code>可以存储数据（严格说是必须存放数据，默认是个空字符）。</p>
<p>由于<code>zookeeper</code>是目录节点结构，在获取和创建节点时，必须要以<code>“/”</code> 开头，否则在获取节点时会报错 <code>Path must start with / character</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">13</span>] get test</span><br><span class="line">Command failed: java.lang.IllegalArgumentException: Path must start <span class="keyword">with</span> / character</span><br></pre></td></tr></table></figure>

<p>根节点名必须为<code>“/XXX”</code>，创建子节点时必须要带上根节点目录<code>“/XXX/CCC”</code>、<code>“/XXX/AAA”</code>。</p>
<p>例如：想要获取下图 <code>程序员内点事</code> 节点必须拼接完整的路径 <code>get /微信/公众号/程序员内点事</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /微信/公众号/程序员内点事</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/ee94371033334df0adaa31ccc7933ef4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><code>znode</code>被用来存储 <code>byte级</code> 或 <code>kb级</code> 的数据，可存储的最大数据量是<code>1MB</code>（<strong>请注意</strong>：一个节点的数据量不仅包含它自身存储数据，它的所有子节点的名字也要折算成Byte数计入，因此<code>znode</code>的子节点数也不是无限的）虽然可以手动的修改节点存储量大小，但一般情况下并不推荐这样做。</p>
<h3 id="2、znode节点属性"><a href="#2、znode节点属性" class="headerlink" title="2、znode节点属性"></a>2、znode节点属性</h3><p>一个<code>znode</code>节点不仅可以存储数据，还有一些其他特别的属性。接下来我们创建一个<code>/test</code>节点分析一下它各个属性的含义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] get /<span class="built_in">test</span></span><br><span class="line">456</span><br><span class="line">cZxid = 0x59ac //</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59ad</span><br><span class="line">mtime = Mon Mar 30 15:22:25 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 0  </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>节点属性</th>
<th>注解</th>
</tr>
</thead>
<tbody><tr>
<td>cZxid</td>
<td>该数据节点被创建时的事务Id</td>
</tr>
<tr>
<td>mZxid</td>
<td>该数据节点被修改时最新的事物Id</td>
</tr>
<tr>
<td>pZxid</td>
<td>当前节点的父级节点事务Id</td>
</tr>
<tr>
<td>ctime</td>
<td>该数据节点创建时间</td>
</tr>
<tr>
<td>mtime</td>
<td>该数据节点最后修改时间</td>
</tr>
<tr>
<td>dataVersion</td>
<td>当前节点版本号（每修改一次值+1递增）</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点版本号（子节点修改次数，每修改一次值+1递增）</td>
</tr>
<tr>
<td>aclVersion</td>
<td>当前节点acl版本号（节点被修改acl权限，每修改一次值+1递增）</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>临时节点标示，当前节点如果是临时节点，则存储的创建者的会话id（sessionId），如果不是，那么值=0</td>
</tr>
<tr>
<td>dataLength</td>
<td>当前节点所存储的数据长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>当前节点下子节点的个数</td>
</tr>
</tbody></table>
<p>我们看到一个<code>znode</code>节点的属性比较多，但比较主要的属性还是<code>zxid</code>、<code>version</code>、<code>acl</code> 这三个。</p>
<hr>
<p><strong>Zxid：</strong></p>
<p><code>znode</code>节点状态改变会导致该节点收到一个<code>zxid</code>格式的时间戳，这个时间戳是全局有序的，znode节点的建立或者更新都会产生一个新的。如果<code>zxid1</code>的值 &lt; <code>zxid2</code>的值，那么说明<code>zxid2</code>发生的改变在<code>zxid1</code>之后。每个znode节点都有3个<code>zxid</code>属性，<code>cZxid</code>（节点创建时间）、<code>mZxid</code>（该节点修改时间，与子节点无关）、<code>pZxid</code>（该节点或者该节点的子节点的最后一次创建或者修改时间，孙子节点无关）。</p>
<p><code>zxid</code>属性主要应用于<code>zookeeper</code>的集群，这个后边介绍集群时详细说。</p>
<p><strong>Version：</strong></p>
<p><code>znode</code>属性中一共有三个版本号<code>dataversion</code>（数据版本号）、<code>cversion</code>（子节点版本号）、<code>aclversion</code>（节点所拥有的ACL权限版本号）。</p>
<p><code>znode</code>中的数据可以有多个版本，如果某一个节点下存有多个数据版本，那么查询这个节点数据就需要带上版本号。每当我们对<code>znode</code>节点数据修改后，该节点的<code>dataversion</code>版本号会递增。当客户端请求该<code>znode</code>节点时，会同时返回节点数据和版本号。另外当<code>dataversion</code>为 <code>-1</code>的时候可以忽略版本进行操作。对一个节点设置权限时<code>aclVersion</code>版本号会递增，下边会详细说ACL权限控制。</p>
<p>验证一下，我们修改<code>/test</code>节点的数据看看<code>dataVersion </code>有什么变化，发现<code>dataVersion </code>属性变成了 3，版本号递增了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] <span class="built_in">set</span> /<span class="built_in">test</span> 8888</span><br><span class="line">cZxid = 0x59ac</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59b6</span><br><span class="line">mtime = Mon Mar 30 16:58:08 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>

<h3 id="3、znode的类型"><a href="#3、znode的类型" class="headerlink" title="3、znode的类型"></a>3、znode的类型</h3><p><code>zookeeper</code> 有四种类型的<code>znode</code>，在用客户端 <code>client</code> 创建节点的时候需要指定类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.create(<span class="string">&quot;/公众号/程序员内点事&quot;</span>, <span class="string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PERSISTENT</code>-持久化目录节点 ：client创建节点后，与zookeeper断开连接该节点将被持久化，当client再次连接后节点依旧存在。</li>
<li><code>PERSISTENT_SEQUENTIAL</code>-持久化顺序节点 ：client创建节点后，与zookeeper断开连接该节点将被持久化，再次连接节点还存在，zookeeper会给该节点名称进行顺序编号，例如：/lock/0000000001、/lock/0000000002、/lock/0000000003。</li>
<li><code>EPHEMERAL</code>-临时目录节点 ： client与zookeeper断开连接后，该节点即会被删除</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>-临时顺序节点 ： client与zookeeper断开连接后，该节点被删除，会给该节点名称进行顺序编号，例如：/lock/0000000001、/lock/0000000002、/lock/0000000003。</li>
</ul>
<h2 id="二、节点的ACL权限控制"><a href="#二、节点的ACL权限控制" class="headerlink" title="二、节点的ACL权限控制"></a>二、节点的ACL权限控制</h2><p><code>ACL</code>：即 <code>Access Control List</code> (节点的权限控制)，通过<code>ACL</code>机制来解决<code>znode</code>节点的访问权限问题，要注意的是<code>zookeeper</code>对权限的控制是基于<code>znode</code>级别的，也就说节点之间的权限不具有继承性，即子节点不继承父节点的权限。</p>
<p><code>zookeeper</code>中设置ACL权限的格式由<code>&lt;schema&gt;:&lt;id&gt;:&lt;acl&gt;</code>三段组成。</p>
<p><strong>schema</strong> ：表示授权的方式</p>
<ul>
<li><code>world</code>：表示任何人都可以访问</li>
<li><code>auth</code>：只有认证的用户可以访问</li>
<li><code>digest</code>：使用username  ：password用户密码生成MD5哈希值作为认证ID</li>
<li><code>host/ip</code>：使用客户端主机IP地址来进行认证</li>
</ul>
<p><strong>id</strong>： 权限的作用域，用来标识身份，依赖于schema选择哪种方式。</p>
<p><strong>acl</strong>：给一个节点赋予哪些权限，节点的权限有create,、delete、write、read、admin 统称 <code>cdwra</code>。</p>
<h3 id="1、world：表示任何人都可以访问"><a href="#1、world：表示任何人都可以访问" class="headerlink" title="1、world：表示任何人都可以访问"></a>1、<code>world</code>：表示任何人都可以访问</h3><p>我们用 <code>getAcl</code> 命令来看一下，没有设置过权限的<code>znode</code>节点，默认情况下的权限情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] getAcl /<span class="built_in">test</span></span><br><span class="line"><span class="string">&#x27;world,&#x27;</span>anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure>

<p>看到没有设置ACL属性的节点，默认schema 使用的是<code>world</code>，作用域是<code>anyone</code>，节点权限是<code>cdwra</code>，也就是说任何人都可以访问。</p>
<p>那我们如果要给一个schema 为非<code>world</code>的节点设置<code>world</code>权限咋搞？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl /<span class="built_in">test</span> world:anyone:crdwa</span><br></pre></td></tr></table></figure>

<h3 id="2、auth：只有认证的用户可以访问"><a href="#2、auth：只有认证的用户可以访问" class="headerlink" title="2、auth：只有认证的用户可以访问"></a>2、<code>auth</code>：只有认证的用户可以访问</h3><p>schema 用<code>auth</code>授权表示只有认证后的用户才可以访问，那么首先就需要添加认证用户，添加完以后需要对认证的用户设置ACL权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addauth digest <span class="built_in">test</span>:password(明文)</span><br></pre></td></tr></table></figure>

<p>需要注意的是设置认证用户时的密码是明文的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] addauth digest user:user //用户名：密码</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] setAcl /<span class="built_in">test</span> auth:user:crdwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] getAcl /<span class="built_in">test</span></span><br><span class="line"><span class="string">&#x27;digest,&#x27;</span>user:ben+k/3JomjGj4mfd4fYsfM6p0A=</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure>

<p>实际上我们这样设置以后，就是将这个节点开放给所有认证的用户，<code>setAcl /test auth:user:crdwa</code> 相当于<code>setAcl /test auth::crdwa</code>。</p>
<h3 id="3、digest：用户名-密码的验证方式"><a href="#3、digest：用户名-密码的验证方式" class="headerlink" title="3、digest：用户名:密码的验证方式"></a>3、<code>digest</code>：用户名:密码的验证方式</h3><p>用户名:密码方式授权是针对单个特定用户，这种方式是不需要先添加认证用户的。</p>
<p>如果在代码中使用zookeeper客户端设置ACL，那么密码是明文的，但若是zk.cli等客户端操作就需要将密码进行<code>sha1</code>及<code>base64</code>处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setAcl &lt;path&gt; digest:&lt;user&gt;:&lt;password(密文)&gt;:&lt;acl&gt;</span><br><span class="line"></span><br><span class="line">setAcl /<span class="built_in">test</span> digest:user:jalRr+knv/6L2uXdenC93dEDNuE=:crdwa</span><br></pre></td></tr></table></figure>

<p>那么密码如何加密嘞？有以下几种方式：</p>
<p>通过<code>shell</code>命令加密</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure>

<p>使用<code>zookeeper</code>自带的类库<code>org.apache.zookeeper.server.auth.DigestAuthenticationProvider</code>生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -cp /zookeeper-3.4.13/zookeeper-3.4.13.jar:/zookeeper-3.4.13/lib/slf4j-api-1.7.25.jar \</span><br><span class="line">  org.apache.zookeeper.server.auth.DigestAuthenticationProvider \</span><br><span class="line">  root:root</span><br><span class="line">root:root-&gt;root:qiTlqPLK7XM2ht3HMn02qRpkKIE=</span><br></pre></td></tr></table></figure>

<h3 id="4、host-ip：使用客户端主机IP地址来进行认证"><a href="#4、host-ip：使用客户端主机IP地址来进行认证" class="headerlink" title="4、host/ip：使用客户端主机IP地址来进行认证"></a>4、<code>host/ip</code>：使用客户端主机IP地址来进行认证</h3><p>这种方式就比较好理解了，通过对特定的IP地址，也可以是一个IP段进行授权。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] setAcl /test0000000014 ip:127.0.0.1:crdwa</span><br><span class="line">cZxid = 0x59ac</span><br><span class="line">ctime = Mon Mar 30 15:20:08 CST 2020</span><br><span class="line">mZxid = 0x59b6</span><br><span class="line">mtime = Mon Mar 30 16:58:08 CST 2020</span><br><span class="line">pZxid = 0x59ac</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 3 // 这个版本一直在增加</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>

<h2 id="三、zookeeper的灵魂-watcher"><a href="#三、zookeeper的灵魂-watcher" class="headerlink" title="三、zookeeper的灵魂 watcher"></a>三、zookeeper的灵魂 watcher</h2><p>我们在开头就说过：<code>zookeeper</code>可以为<code>dubbo</code>提供服务的注册与发现，作为注册中心，但你有想过<code>zookeeper</code>为啥能够实现服务的注册与发现吗？这就不得不说一下<code>zookeeper</code>的灵魂 <code>Watcher</code>（监听者）。</p>
<h3 id="1、watcher是个啥？"><a href="#1、watcher是个啥？" class="headerlink" title="1、watcher是个啥？"></a>1、watcher是个啥？</h3><p><code>watcher</code> 是<code>zooKeeper</code>中一个非常核心功能 ，客户端<code>watcher</code> 可以监控节点的数据变化以及它子节点的变化，一旦这些状态发生变化，zooKeeper服务端就会通知所有在这个节点上设置过<code>watcher</code>的客户端 ，从而每个客户端都很快感知，它所监听的节点状态发生变化，而做出对应的逻辑处理。</p>
<p>简单的介绍了一下<code>watcher</code> ，那么我们来分析一下，<code>zookeeper</code>是如何实现服务的注册与发现。 <code>zookeeper</code>的服务注册与发现，主要应用的是<code>zookeeper</code>的<code>znode</code>节点数据模型和<code>watcher</code>机制，大致的流程如下：</p>
<p><img src="/2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/2a10d2a2b39a4cedbcd430dc2a2394a4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<ul>
<li><strong>服务注册：</strong> 服务提供者（<code>Provider</code>）启动时，会向<code>zookeeper服务端</code>注册服务信息，也就是创建一个节点，例如：用户注册服务<code>com.xxx.user.register</code>，并在节点上存储服务的相关数据（如服务提供者的ip地址、端口等）。</li>
<li><strong>服务发现：</strong> 服务消费者（<code>Consumer</code>）启动时，根据自身配置的依赖服务信息，向<code>zookeeper服务端</code>获取注册的服务信息并设置<code>watch监听</code>，获取到注册的服务信息之后，将服务提供者的信息缓存在本地，并进行服务的调用。</li>
<li><strong>服务通知：</strong> 一旦服务提供者因某种原因宕机不再提供服务之后，客户端与<code>zookeeper</code>服务端断开连接，<code>zookeeper</code>服务端上服务提供者对应服务节点会被删除（例如：用户注册服务<code>com.xxx.user.register</code>），随后<code>zookeeper</code>服务端会异步向所有消费用户注册服务<code>com.xxx.user.register</code>，且设置了<code>watch监听</code>的服务消费者发出节点被删除的通知，消费者根据收到的通知拉取最新服务列表，更新本地缓存的服务列表。</li>
</ul>
<p>上边的过程就是<code>zookeeper</code>可以实现服务注册与发现的大致原理。</p>
<h3 id="2、watcher类型"><a href="#2、watcher类型" class="headerlink" title="2、watcher类型"></a>2、watcher类型</h3><p><code>znode</code>节点可以设置两类<code>watch</code>，一种是<code>DataWatches</code>，基于znode节点的数据变更从而触发 <code>watch</code> 事件，触发条件<code>getData()</code>、<code>exists()</code>、<code>setData()</code>、 <code>create()</code>。</p>
<p>另一种是<code>Child Watches</code>，基于znode的孩子节点发生变更触发的watch事件，触发条件 <code>getChildren()</code>、 <code>create()</code>。</p>
<p>而在调用 <code>delete()</code> 方法删除znode时，则会同时触发<code>Data Watches</code>和<code>Child Watches</code>，如果被删除的节点还有父节点，则父节点会触发一个<code>Child Watches</code>。</p>
<h3 id="3、watcher特性"><a href="#3、watcher特性" class="headerlink" title="3、watcher特性"></a>3、watcher特性</h3><p><code>watch</code>对节点的监听事件是一次性的！客户端在指定的节点设置了监听<code>watch</code>，一旦该节点数据发生变更通知一次客户端后，客户端对该节点的监听事件就失效了。</p>
<p>如果还要继续监听这个节点，就需要我们在客户端的监听回调中，再次对节点的监听<code>watch</code>事件设置为<code>True</code>。否则客户端只能接收到一次该节点的变更通知。</p>
<h2 id="四、zookeeper能实现哪些功能"><a href="#四、zookeeper能实现哪些功能" class="headerlink" title="四、zookeeper能实现哪些功能"></a>四、zookeeper能实现哪些功能</h2><p>服务的注册与发现功能只是zookeeper的冰山一角，它还能实现诸如分布式锁、队列、配置中心等一系列功能，接下来我们只分析一下原理，具体的实现大家上网查一下资料还是比较全的。</p>
<h3 id="1、分布式锁"><a href="#1、分布式锁" class="headerlink" title="1、分布式锁"></a>1、分布式锁</h3><p><code>zookeeper</code>基于<code>watcher</code>机制和<code>znode</code>的有序节点，天生就是一个分布式锁的坯子。首先创建一个<code>/test/lock</code>父节点作为一把锁，尽量是持久节点（PERSISTENT类型），每个尝试获取这把锁的客户端，在<code>/test/lock</code>父节点下创建临时顺序子节点。</p>
<p>由于序号的递增性，我们规定序号最小的节点即获得锁。例如：客户端来获取锁，在<code>/test/lock</code>节点下创建节点为<code>/test/lock/seq-00000001</code>，它是最小的所以它优先拿到了锁，其它节点等待通知再次获取锁。<code>/test/lock/seq-00000001</code>执行完自己的逻辑后删除节点释放锁。</p>
<p><strong>那么节点<code>/test/lock/seq-00000002</code>想要获取锁等谁的通知呢？</strong></p>
<p>这里我们让<code>/test/lock/seq-00000002</code>节点监听<code>/test/lock/seq-00000001</code>节点，一旦<code>/test/lock/seq-00000001</code>节点删除，则通知<code>/test/lock/seq-00000002</code>节点，让它再次判断自己是不是最小的节点，是则拿到锁，不是继续等通知。</p>
<p>以此类推<code>/test/lock/seq-00000003</code>节点监听<code>/test/lock/seq-00000002</code>节点，总是让后一个节点监听前一个节点，不用让所有节点都监听最小的节点，避免设置不必要的监听，以免造成大量无效的通知，形成“羊群效应”。</p>
<p><code>zookeeper</code>分布式锁和<code>redis</code>分布式锁相比，因为大量的创建、删除节点性能上比较差，并不是很推荐。 <img src="/2020/12/22/Zookeeper%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/7d20302015de4629acd6d633bf0f5253~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="2、分布式队列"><a href="#2、分布式队列" class="headerlink" title="2、分布式队列"></a>2、分布式队列</h3><p>zookeeper实现分布式队列也很简单，应用znode的有序节点天然的“先进先出”，后创建的节点总是最大的，出队总是拿序号最小的节点即可。</p>
<h3 id="3、配置管理"><a href="#3、配置管理" class="headerlink" title="3、配置管理"></a>3、配置管理</h3><p>现在有很多开源项目都在使用Zookeeper来维护配置，像消息队列Kafka中，就使用Zookeeper来维护broker的信息；dubbo中管理服务的配置信息。原理也是基于<code>watcher</code>机制，例如：创建一个<code>/config</code>节点存放一些配置，客户端监听这个节点，一点修改<code>/config</code>节点的配置信息，通知各个客户端数据变更重新拉取配置信息。</p>
<h3 id="4、命名服务"><a href="#4、命名服务" class="headerlink" title="4、命名服务"></a>4、命名服务</h3><p><code>zookeeper</code>的命名服务：也就是我们常说的服务注册与发现，主要是根据指定名字来获取资源或服务的地址，服务提供者等信息，利用其<code>znode</code>节点的特点和<code>watcher</code>机制，将其作为动态注册和获取服务信息的配置中心，统一管理服务名称和其对应的服务器列表信息，我们能够近乎实时地感知到后端服务器的状态(上线、下线、宕机)。</p>
<h2 id="五、基本操作"><a href="#五、基本操作" class="headerlink" title="五、基本操作"></a>五、基本操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ul>
<li>create /blog “blog” 创建普通节点</li>
<li>create -e /blog-temp “temp” 创建临时节点</li>
<li>create -s /blog-sequence “sequence” 创建序列节点</li>
<li>create -s  -e /blog-ts “ts” 创建带序号的临时节点</li>
</ul>
<h3 id="节点监听"><a href="#节点监听" class="headerlink" title="节点监听"></a>节点监听</h3><ul>
<li>get /servers watch   节点的值变化监听</li>
<li>ls /servers watch 节点的子节点变化监听（增、删）</li>
<li>stat -w /path 监听节点属性的变化</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>delete /blog  删除节点（不能删除带有子节点的节点）</li>
<li>rmr /sanguo  递归删除节点（可以删除带有子节点的节点）</li>
</ul>
<h3 id="显示配额"><a href="#显示配额" class="headerlink" title="显示配额"></a>显示配额</h3><ul>
<li>listquota /zookeeper  返回值count=2,bytes=-1 节点个数限额为2，长度无限额</li>
</ul>
<h3 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h3><ul>
<li>stat /blog-temp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid &#x3D; 0x70000012e  引起这个znode创建的zxid，创建节点的事务的zxid（ZooKeeper Transaction Id），每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生</span><br><span class="line">ctime &#x3D; Mon Oct 12 06:08:52 UTC 2020 znode被创建的时间戳(从1970年开始)</span><br><span class="line">mZxid &#x3D; 0x70000012e znode最后更新的zxid</span><br><span class="line">mtime &#x3D; Mon Oct 12 06:08:52 UTC 2020 znode最后修改的时间戳(从1970年开始)</span><br><span class="line">pZxid &#x3D; 0x70000012e  znode最后更新的子节点zxid</span><br><span class="line">cversion &#x3D; 0 znode子节点变化号，znode子节点修改次数</span><br><span class="line">dataVersion &#x3D; 0 znode数据变化号</span><br><span class="line">aclVersion &#x3D; 0 znode访问控制列表的变化号</span><br><span class="line">ephemeralOwner &#x3D; 0x0 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0</span><br><span class="line">dataLength &#x3D; 4 znode的数据长度</span><br><span class="line">numChildren &#x3D; 0 znode子节点数量</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>  分布式消息同步和协调机制</li>
<li>  服务器节点动态上下线</li>
<li>  统一配置管理</li>
<li>  负载均衡</li>
<li>  集群管理</li>
<li>  。。。。。。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>  zookeeper的数据模型的结构和unix文件系统很相似，整体上看是一颗目录树，每一个节点称为ZNode（每个节点不但有目录名称，还必须要有值，类似于键值对）。<br>  zookeeper集群自身维护了一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为”znode”，每一个znode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。</p>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><ul>
<li>  短暂（ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除。</li>
<li>  持久（persistent）：客户端和服务器端断开连接后，创建的节点不删除。</li>
<li>  持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号，顺序编号有小到大。</li>
<li>  临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号，顺序编号有小到大。</li>
</ul>
<h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><h2 id="zab原子广播协议"><a href="#zab原子广播协议" class="headerlink" title="zab原子广播协议"></a>zab原子广播协议</h2><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><h2 id="失败恢复"><a href="#失败恢复" class="headerlink" title="失败恢复"></a>失败恢复</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6906694879380766727">zookeeper 基础</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/java%E4%B9%8BType/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/java%E4%B9%8BType/" class="post-title-link" itemprop="url">java之Type</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-22 10:19:02 / Modified: 10:47:08" itemprop="dateCreated datePublished" datetime="2020-12-22T10:19:02+08:00">2020-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Class（原始类型、基本数据类型-）"><a href="#Class（原始类型、基本数据类型-）" class="headerlink" title="Class（原始类型、基本数据类型 ）"></a>Class（原始类型、基本数据类型 ）</h2><p>Type的直接实现子类</p>
<h2 id="ParameterizedType（泛型参数化类型）"><a href="#ParameterizedType（泛型参数化类型）" class="headerlink" title="ParameterizedType（泛型参数化类型）"></a>ParameterizedType（泛型参数化类型）</h2><p>参数化的类型，比如Collection&lt;?&gt;,实现类是<strong>ParameterizedTypeImpl</strong></p>
<p>public Type[] getActualTypeArguments() ;   返回实际的Type()。</p>
<h2 id="GenericArrayType（泛型数组类型）"><a href="#GenericArrayType（泛型数组类型）" class="headerlink" title="GenericArrayType（泛型数组类型）"></a>GenericArrayType（泛型数组类型）</h2><p>元素类型是参数化类型或者类型变量的数组类型,实现类<strong>GenericArrayTypeImpl</strong></p>
<p>public Type getGenericComponentType()；获取泛型数组类型</p>
<h2 id="TypeVariable（泛型类型变量）"><a href="#TypeVariable（泛型类型变量）" class="headerlink" title="TypeVariable（泛型类型变量）"></a>TypeVariable（泛型类型变量）</h2><p>各种类型变量的公共父接口，实现类是<strong>TypeVariableImpl</strong></p>
<p>public D getGenericDeclaration()；</p>
<h2 id="WildcardType（泛型通配符类型）"><a href="#WildcardType（泛型通配符类型）" class="headerlink" title="WildcardType（泛型通配符类型）"></a>WildcardType（泛型通配符类型）</h2><p>一种通配符类型表达式，比如?, ? extends Number, ? super Integer，实现类：<strong>WildcardTypeImpl</strong></p>
<p>Type[] getUpperBounds();  获取通配符表达式对象的泛型限定的上边界的类型</p>
<p>Type[] getLowerBounds(); 下边界类型</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> E <span class="title">methodIV</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;ArrayList&gt; al1,  //al1的类型是ArrayList，返回类型是ParameterizedType</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;E&gt; al2,          //al2的类型是E，返回类型是TypeVariable</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;String&gt; al3,     //al3的类型是String，返回类型是Class</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;? extends Number&gt; al4,   //al4的类型是? extends Number，返回类型是WildcardType</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList&lt;E[]&gt; al5)</span></span>&#123;&#125;)     <span class="comment">//al5的类型是E[]，返回类型是GenericArrayType</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型出现之前的类型"><a href="#泛型出现之前的类型" class="headerlink" title="泛型出现之前的类型"></a>泛型出现之前的类型</h3><p>没有泛型的时候，只有所谓的原始类型。此时，所有的原始类型都通过字节码文件类Class类进行抽象。Class类的一个具体对象就代表一个指定的原始类型。</p>
<h3 id="泛型出现之后的类型"><a href="#泛型出现之后的类型" class="headerlink" title="泛型出现之后的类型"></a>泛型出现之后的类型</h3><p>泛型出现之后，扩充了数据类型。从只有原始类型扩充了参数化类型、类型变量类型、泛型限定的的参数化类型 (含通配符+通配符限定表达式)、泛型数组类型。</p>
<h3 id="与泛型有关的类型不能和原始类型统一到Class的原因"><a href="#与泛型有关的类型不能和原始类型统一到Class的原因" class="headerlink" title="与泛型有关的类型不能和原始类型统一到Class的原因"></a>与泛型有关的类型不能和原始类型统一到Class的原因</h3><p>[1]. 【产生泛型擦除的原因】<br>本来新产生的类型+原始类型都应该统一成各自的字节码文件类型对象。但是由于泛型不是最初Java中的成分。如果真的加入了泛型，涉及到JVM指令集的修改，这是非常致命的。<br>[2]. 【Java中如何引入泛型】<br>为了使用泛型的优势又不真正引入泛型，Java采用泛型擦除的机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部擦除。<br>[3]. 【Class不能表达与泛型有关的类型】<br>因此，与泛型有关的参数化类型、类型变量类型、泛型限定的的参数化类型 (含通配符+通配符限定表达式)、泛型数组类型这些类型全部被打回原形，在字节码文件中全部都是泛型被擦除后的原始类型，并不存在和自身类型一致的字节码文件。所以和泛型相关的新扩充进来的类型不能被统一到Class类中。<br>(4). 与泛型有关的类型在Java中的表示<br>为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了ParameterizedType，GenericArrayType，TypeVariable 和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。<br>(5). Type的引入：统一与泛型有关的类型和原始类型Class</p>
<h3 id="引入Type的原因"><a href="#引入Type的原因" class="headerlink" title="引入Type的原因"></a>引入Type的原因</h3><p>为了程序的扩展性，最终引入了Type接口作为Class，ParameterizedType，GenericArrayType，TypeVariable和WildcardType这几种类型的总的父接口。这样实现了Type类型参数接受以上五种子类的实参或者返回值类型就是Type类型的参数。</p>
<h3 id="Type接口中没有方法的原因"><a href="#Type接口中没有方法的原因" class="headerlink" title="Type接口中没有方法的原因"></a>Type接口中没有方法的原因</h3><p>从上面看到，Type的出现仅仅起到了通过多态来达到程序扩展性提高的作用，没有其他的作用。因此Type接口的源码中没有任何方法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/21/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/21/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">规则引擎介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-21 18:19:02 / Modified: 18:31:39" itemprop="dateCreated datePublished" datetime="2020-12-21T18:19:02+08:00">2020-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">规则引擎</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Drools"><a href="#Drools" class="headerlink" title="Drools"></a>Drools</h2><p>Drools 是用 Java 语言编写的开放源码规则引擎，使用 Rete 算法对所编写的规则求值。Drools 允许使用声明方式表达业务逻辑。可以使用非 XML 的本地语言编写规则，从而便于学习和理解。并且，还可以将 Java 代码直接嵌入到规则文件中，这令 Drools 的学习更加吸引人。</p>
<p>Drools 还具有其他优点：</p>
<ul>
<li>非常活跃的社区支持</li>
<li>易用</li>
<li>快速的执行速度</li>
<li>在 Java 开发人员中流行</li>
<li>与 Java Rule Engine API（JSR 94）兼容</li>
</ul>
<h2 id="QLExpress"><a href="#QLExpress" class="headerlink" title="QLExpress"></a>QLExpress</h2><p>由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。</p>
<p>QLExpress脚本引擎被广泛应用在阿里的电商业务场景，具有以下的一些特性:</p>
<ul>
<li>1、线程安全，引擎运算过程中的产生的临时变量都是threadlocal类型。</li>
<li>2、高效执行，比较耗时的脚本编译过程可以缓存在本地机器，运行时的临时变量创建采用了缓冲池的技术，和groovy性能相当。</li>
<li>3、弱类型脚本语言，和groovy，javascript语法类似，虽然比强类型脚本语言要慢一些，但是使业务的灵活度大大增强。</li>
<li>4、安全控制,可以通过设置相关运行参数，预防死循环、高危系统api调用等情况。</li>
<li>5、代码精简，依赖最小，250k的jar包适合所有java的运行环境，在android系统的低端pos机也得到广泛运用。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/cuibo119/QLExpress">QLExpress基本语法</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/621206">QLExpress功能清单</a></p>
<h2 id="Drools中文网"><a href="#Drools中文网" class="headerlink" title="Drools中文网"></a><a target="_blank" rel="noopener" href="http://www.drools.org.cn/">Drools中文网</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/21/p6spy%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/21/p6spy%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">p6spy之简单使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-21 18:05:43 / Modified: 18:15:15" itemprop="dateCreated datePublished" datetime="2020-12-21T18:05:43+08:00">2020-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/p6spy/" itemprop="url" rel="index"><span itemprop="name">p6spy</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="p6spy作用"><a href="#p6spy作用" class="headerlink" title="p6spy作用"></a>p6spy作用</h2><p>将所有执行的sql打出日志，放在一个文件下。</p>
<p>p6spy将应用的数据源给劫持了，应用操作数据库其实在调用p6spy的数据源，p6spy劫持到需要执行的sql或者hql之类的语句之后，他自己去调用一个realDatasource，再去操作数据库</p>
<p>p6spy 可以输出日志到文件中、控制台、或者传递给 Log4j，而且还能配搭 SQL Profiler 或 IronTrackSQL 图形化监控 SQL 语句，监测到哪些语句的执行是耗时的，逐个优化。</p>
<h2 id="p6spy的配置"><a href="#p6spy的配置" class="headerlink" title="p6spy的配置"></a>p6spy的配置</h2><ul>
<li><p>p6spy.jar放入应用的classpath下</p>
</li>
<li><p>修改连接池或者连接配置的jdbc的驱动为p6spy所提供的驱动，com.p6spy.engine.spy.P6SpyDriver</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在单独的Hibernate的应用中，数据库驱动配置在hibernate.cfg.xml里面,所以我需要配置文件中的connection.driver_class属性从oracle.jdbc.driver.OracleDriver改为com.p6spy.engine.spy.P6SpyDriver其他的用户名密码等等配置信息全部不用修改.在web程序中，配置的连接池部分，也只需要修改jdbc-driver的配置即可。</span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>&gt;</span>com.p6spy.engine.spy.P6SpyDriver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>&gt;</span>jdbc:oracle:thin:@localhost:1521:orcl<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.username&quot;</span>&gt;</span>scott<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.password&quot;</span>&gt;</span>tiger<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.pool_size&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span>&gt;</span>org.hibernate.dialect.Oracle9Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;current_session_context_class&quot;</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.provider_class&quot;</span>&gt;</span>org.hibernate.cache.NoCacheProvider<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hbm2ddl.auto&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.jdbc.batch_size&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 spy.properties 并将其放到classpath下</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment"># MODULES                                                       #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Modules provide the P6Spy functionality.  If a module, such   #</span></span><br><span class="line"><span class="comment"># as module_log is commented out, that functionality will not   #</span></span><br><span class="line"><span class="comment"># be available.  If it is not commented out (if it is active),  #</span></span><br><span class="line"><span class="comment"># the functionality will be active.                             #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Values set in Modules cannot be reloaded using the            #</span></span><br><span class="line"><span class="comment"># reloadproperties variable.  Once they are loaded, they remain #</span></span><br><span class="line"><span class="comment"># in memory until the application is restarted.                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment">#第一：module.log的属性必须配置，如果不配置，P6SPY将不起任何作用，典型配置：</span></span><br><span class="line"><span class="meta">module.log</span>=<span class="string">com.p6spy.engine.logging.P6LogFactory</span></span><br><span class="line"><span class="comment">#module.outage=com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment"># REALDRIVER(s)                                                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># In your application server configuration file you replace the #</span></span><br><span class="line"><span class="comment"># &quot;real driver&quot; name with com.p6spy.engine.P6SpyDriver. This is #</span></span><br><span class="line"><span class="comment"># where you put the name of your real driver P6Spy can find and #</span></span><br><span class="line"><span class="comment"># register your real driver to do the database work.            #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># If your application uses several drivers specify them in      #</span></span><br><span class="line"><span class="comment"># realdriver2, realdriver3\.  See the documentation for more     #</span></span><br><span class="line"><span class="comment"># details.                                                      #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment"># Values set in REALDRIVER(s) cannot be reloaded using the      #</span></span><br><span class="line"><span class="comment"># reloadproperties variable.  Once they are loaded, they remain #</span></span><br><span class="line"><span class="comment"># in memory until the application is restarted.                 #</span></span><br><span class="line"><span class="comment">#                                                               #</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二：数据库驱动配置，你懂的，不多说了</span></span><br><span class="line"><span class="comment"># oracle driver</span></span><br><span class="line"><span class="comment"># realdriver=oracle.jdbc.driver.OracleDriver</span></span><br><span class="line"><span class="comment"># mysql Connector/J driver</span></span><br><span class="line"><span class="comment"># realdriver=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># informix driver</span></span><br><span class="line"><span class="comment"># realdriver=com.informix.jdbc.IfxDriver</span></span><br><span class="line"><span class="comment"># ibm db2 driver</span></span><br><span class="line"><span class="comment"># realdriver=COM.ibm.db2.jdbc.net.DB2Driver</span></span><br><span class="line"><span class="comment"># the mysql open source driver</span></span><br><span class="line"><span class="attr">realdriver</span>=<span class="string">org.gjt.mm.mysql.Driver</span></span><br><span class="line"><span class="comment">#specifies another driver to use</span></span><br><span class="line"><span class="attr">realdriver2</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#specifies a third driver to use</span></span><br><span class="line"><span class="attr">realdriver3</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第三：appender配置，一般分为三种</span></span><br><span class="line"><span class="comment">#specifies the appender to use for logging</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.logging.appender.Log4jLogger</span></span><br><span class="line"><span class="comment">#控制台</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.logging.appender.StdoutLogger</span></span><br><span class="line"><span class="attr">appender</span>=<span class="string">com.p6spy.engine.logging.appender.FileLogger</span></span><br><span class="line"><span class="comment"># name of logfile to use, note Windows users should make sure to use forward slashes in their pathname (e:/test/spy.log) (used for file logger only)</span></span><br><span class="line"><span class="comment">#日志文件存放路径及文件名</span></span><br><span class="line"><span class="attr">logfile</span>     = <span class="string">spy.log</span></span><br><span class="line"><span class="comment"># append to  the p6spy log file.  if this is set to false the</span></span><br><span class="line"><span class="comment"># log file is truncated every time.  (file logger only)</span></span><br><span class="line"><span class="attr">append</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#The following are for log4j logging only</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.STDOUT.layout.ConversionPattern</span>=<span class="string">p6spy - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.p6spy</span>=<span class="string">INFO,STDOUT</span></span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">java之异常处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-21 17:53:17 / Modified: 17:59:07" itemprop="dateCreated datePublished" datetime="2020-12-21T17:53:17+08:00">2020-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><ul>
<li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h2 id="异常类图"><a href="#异常类图" class="headerlink" title="异常类图"></a>异常类图</h2><p><img src="/2020/12/21/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201221175446673.png" alt="image-20201221175446673"></p>
<h2 id="Java-的非检查性异常"><a href="#Java-的非检查性异常" class="headerlink" title="Java 的非检查性异常"></a>Java 的非检查性异常</h2><table>
<thead>
<tr>
<th align="left"><strong>异常</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">ArithmeticException</td>
<td align="left">当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td>
</tr>
<tr>
<td align="left">ArrayIndexOutOfBoundsException</td>
<td align="left">用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td>
</tr>
<tr>
<td align="left">ArrayStoreException</td>
<td align="left">试图将错误类型的对象存储到一个对象数组时抛出的异常。</td>
</tr>
<tr>
<td align="left">ClassCastException</td>
<td align="left">当试图将对象强制转换为不是实例的子类时，抛出该异常。</td>
</tr>
<tr>
<td align="left">IllegalArgumentException</td>
<td align="left">抛出的异常表明向方法传递了一个不合法或不正确的参数。</td>
</tr>
<tr>
<td align="left">IllegalMonitorStateException</td>
<td align="left">抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td>
</tr>
<tr>
<td align="left">IllegalStateException</td>
<td align="left">在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td>
</tr>
<tr>
<td align="left">IllegalThreadStateException</td>
<td align="left">线程没有处于请求操作所要求的适当状态时抛出的异常。</td>
</tr>
<tr>
<td align="left">IndexOutOfBoundsException</td>
<td align="left">指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td>
</tr>
<tr>
<td align="left">NegativeArraySizeException</td>
<td align="left">如果应用程序试图创建大小为负的数组，则抛出该异常。</td>
</tr>
<tr>
<td align="left">NullPointerException</td>
<td align="left">当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</td>
</tr>
<tr>
<td align="left">NumberFormatException</td>
<td align="left">当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td>
</tr>
<tr>
<td align="left">SecurityException</td>
<td align="left">由安全管理器抛出的异常，指示存在安全侵犯。</td>
</tr>
<tr>
<td align="left">StringIndexOutOfBoundsException</td>
<td align="left">此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</td>
</tr>
<tr>
<td align="left">UnsupportedOperationException</td>
<td align="left">当不支持请求的操作时，抛出该异常。</td>
</tr>
</tbody></table>
<h2 id="检查性异常类"><a href="#检查性异常类" class="headerlink" title="检查性异常类"></a>检查性异常类</h2><table>
<thead>
<tr>
<th align="left"><strong>异常</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">ClassNotFoundException</td>
<td align="left">应用程序试图加载类时，找不到相应的类，抛出该异常。</td>
</tr>
<tr>
<td align="left">CloneNotSupportedException</td>
<td align="left">当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</td>
</tr>
<tr>
<td align="left">IllegalAccessException</td>
<td align="left">拒绝访问一个类的时候，抛出该异常。</td>
</tr>
<tr>
<td align="left">InstantiationException</td>
<td align="left">当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td>
</tr>
<tr>
<td align="left">InterruptedException</td>
<td align="left">一个线程被另一个线程中断，抛出该异常。</td>
</tr>
<tr>
<td align="left">NoSuchFieldException</td>
<td align="left">请求的变量不存在</td>
</tr>
<tr>
<td align="left">NoSuchMethodException</td>
<td align="left">请求的方法不存在</td>
</tr>
</tbody></table>
<h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>public String getMessage()</strong></td>
<td align="left">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td>
</tr>
<tr>
<td align="left"><strong>public Throwable getCause()</strong></td>
<td align="left">返回一个Throwable 对象代表异常原因。</td>
</tr>
<tr>
<td align="left"><strong>public String toString()</strong></td>
<td align="left">使用getMessage()的结果返回类的串级名字。</td>
</tr>
<tr>
<td align="left"><strong>public void printStackTrace()</strong></td>
<td align="left">打印toString()结果和栈层次到System.err，即错误输出流。</td>
</tr>
<tr>
<td align="left"><strong>public StackTraceElement [] getStackTrace()</strong></td>
<td align="left">返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td>
</tr>
<tr>
<td align="left"><strong>public Throwable fillInStackTrace()</strong></td>
<td align="left">用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td>
</tr>
</tbody></table>
<h2 id><a href="#" class="headerlink" title></a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/21/nacos%E4%B9%8BgRPC%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/21/nacos%E4%B9%8BgRPC%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">nacos之gRPC调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-21 17:32:39 / Modified: 17:35:12" itemprop="dateCreated datePublished" datetime="2020-12-21T17:32:39+08:00">2020-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>acos 规划准备基于 gRPC 来替换现有的通信场景(Http + UDP)，以下是重点需要和社区讨论的项。请大家积极踊跃发表自己的看法。</p>
<h2 id="Nacos-能够替换成长连接的两大前提"><a href="#Nacos-能够替换成长连接的两大前提" class="headerlink" title="Nacos 能够替换成长连接的两大前提"></a>Nacos 能够替换成长连接的两大前提</h2><ul>
<li><p>通信模型的匹配</p>
<table>
<thead>
<tr>
<th align="center">现有的通信场景</th>
<th align="center">新的通讯场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Http 服务接口 服务接口 Request/Response</td>
<td align="center">gRPC Request/Response</td>
</tr>
<tr>
<td align="center">配置推送 Http Long Polling</td>
<td align="center">gRPC Request/Stream</td>
</tr>
<tr>
<td align="center">UDP 服务推送 Request/Response</td>
<td align="center">gRPC Request/Stream</td>
</tr>
<tr>
<td align="center">支持ssl 通讯</td>
<td align="center">支持ssl 通讯</td>
</tr>
</tbody></table>
</li>
<li><p>通信的数据格式能够匹配</p>
<p>基于 gRPC 的业务层俩进程之间是需要协调好一致的通信数据格式 ，然后在 proto 文件里面来描述。为了能够服务好多场景下的通信模型数据格式的一致性，就像 Http 的通信数据格式一样，不 care 上层业务通信的数据具体表现形式，只 care 通信时数据格式的表现能力。以下关注两方面来阐述基于 gRPC 之后的数据格式长啥样。</p>
<ol>
<li><p>Request 数据格式</p>
<table>
<thead>
<tr>
<th align="center">通信数据格式字段</th>
<th align="center">数据类型</th>
<th align="center">必要性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RequestId</td>
<td align="center">string</td>
<td align="center">必要</td>
<td align="center">标识当前的一次请求，方便于后续问题的排查</td>
</tr>
<tr>
<td align="center">Action</td>
<td align="center">string</td>
<td align="center">必要</td>
<td align="center">标识当前请求的具体行为，<strong>对标 Http 中的 URI 。</strong></td>
</tr>
<tr>
<td align="center">Headers</td>
<td align="center">map&lt;string,string&gt;</td>
<td align="center">必要</td>
<td align="center">动态可伸缩的消息头，<strong>对标 http 请求中的 header 。</strong></td>
</tr>
<tr>
<td align="center">Source</td>
<td align="center">string</td>
<td align="center">可选</td>
<td align="center">标明消息的发送源，是哪一个节点发送的消息。</td>
</tr>
<tr>
<td align="center">Params</td>
<td align="center">map&lt;string,string&gt; l 可选</td>
<td align="center">动态可伸缩的参数传递，<strong>对标 http 请求中的 参数传递。</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Method</td>
<td align="center">string</td>
<td align="center">可选</td>
<td align="center">请求的 Method，<strong>对标 http 请求中的 method。</strong></td>
</tr>
<tr>
<td align="center">Payload</td>
<td align="center">byte[]</td>
<td align="center">必要</td>
<td align="center">请求的消息内容体，<strong>对标 http 请求中的 请求内容体。</strong></td>
</tr>
</tbody></table>
</li>
<li><p>Response 数据格式</p>
<table>
<thead>
<tr>
<th align="center">通信数据格式字段</th>
<th align="center">数据类型</th>
<th align="center">必要性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ReponseId</td>
<td align="center">string</td>
<td align="center">必要</td>
<td align="center">标识当前的一次 response，方便于后续问题的排查 。通常他的值是来源于 request id，标识当前这个 response 是针对那次 请求进行响应的。</td>
</tr>
<tr>
<td align="center">Source</td>
<td align="center">string</td>
<td align="center">可选</td>
<td align="center">标明消息的Response源，是哪一个节点响应的消息。</td>
</tr>
<tr>
<td align="center">Action</td>
<td align="center">string</td>
<td align="center">必要</td>
<td align="center">标识当前 Response 是对哪个 Action 进行响应的。</td>
</tr>
<tr>
<td align="center">Headers</td>
<td align="center">map&lt;string,string&gt;</td>
<td align="center">必要</td>
<td align="center">动态可伸缩的消息头，<strong>对标 http 请求中的 header 。</strong></td>
</tr>
<tr>
<td align="center">Response Code</td>
<td align="center">int l 必要</td>
<td align="center">响应状态码，对标 http 响应中的响应码 。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Response Payload</td>
<td align="center">byte[]</td>
<td align="center">必要</td>
<td align="center">响应的消息内容体，<strong>对标 http 响应中的内容体。</strong></td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ul>
<h2 id="协议协商-通信的基础"><a href="#协议协商-通信的基础" class="headerlink" title="协议协商-通信的基础"></a>协议协商-通信的基础</h2><p>长连接支持的过程中必然会出现客户端/服务端，服务端/服务端 版本支持的通信协议不一致的情况。比如说，此时客户端支持 Http，但是服务端升级到新版本，既支持 Http,有支持 gRPC。这个时候客户端服务端通信要协商好一致的通信协议。面对客户端/服务端通信协议不一致的场景，主要采取<strong>通信协议降级</strong>的处理方式。通信协议降级处理主要分为两种：<strong>服务端通信协议降级处理</strong> 和 <strong>客户端通信协议降级处理</strong>。</p>
<ul>
<li><p>场景一：服务端版本高(既支持 Http+ UDP,有支持 gRPC),客户端版本低(支持 Http + UDP)。那这个时候经过客户端和服务端协议协商后，达成一致的通信协议是 Http + UDP。那么此时服务端对此客户端支持的通信协议就采用 Http +UDP，相对于新的通信协议，就降级了，这就是<strong>服务端通信协议降级处理。</strong></p>
<p><strong>注意:</strong> 服务端的通信协议降级处理是针对多个客户端而言的。因为有的客户端连接过来的是新版本，这个时候就没有服务端的通信协议降级处理，直接采用新的通信协议 gRPC 来处理；但是有的客户端连接过来的是低版本，那么这个时候就需要单独对这个客户端进行服务端通信协议降级处理了。</p>
</li>
<li><p>场景二：客户端版本高了(既支持 Http+ UDP,有支持 gRPC),服务端版本低(支持 Http + UDP)。那这个时候经过客户端和服务端协议协商后，达成一致的通信协议是 Http + UDP。那么此时客户端通信协议就采用 Http +UDP，相对于新的通信协议，就降级了，这就是<strong>客户端通信协议降级处理。</strong></p>
</li>
</ul>
<h2 id="服务端推送-Naming-Config-的支持"><a href="#服务端推送-Naming-Config-的支持" class="headerlink" title="服务端推送(Naming+Config)的支持"></a>服务端推送(Naming+Config)的支持</h2><ul>
<li>服务端推送-Naming(注册中心)</li>
<li>服务端推送-Config(配置中心)</li>
</ul>
<h2 id="Http-接口的改造"><a href="#Http-接口的改造" class="headerlink" title="Http 接口的改造"></a>Http 接口的改造</h2><p>Http 接口的改造，主要内容含两部分，分别是请求接口的数据和响应内容的处理。</p>
<ul>
<li><p>Http/gRPC 请求 通信数据格式的映射</p>
<table>
<thead>
<tr>
<th align="center">Http 请求</th>
<th align="center">gRPC 请求</th>
</tr>
</thead>
<tbody><tr>
<td align="center">URL</td>
<td align="center">Action</td>
</tr>
<tr>
<td align="center">Headers</td>
<td align="center">Headers</td>
</tr>
<tr>
<td align="center">Params</td>
<td align="center">Params</td>
</tr>
<tr>
<td align="center">Body</td>
<td align="center">Payload</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">其他字段按需指定</td>
</tr>
</tbody></table>
</li>
<li><p>Http/gRPC 响应 通信数据格式的映射</p>
<table>
<thead>
<tr>
<th align="center">Http 响应</th>
<th align="center">gRPC 响应</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Response Code</td>
<td align="center">Response Code</td>
</tr>
<tr>
<td align="center">Response Body</td>
<td align="center">Response Payload</td>
</tr>
<tr>
<td align="center">Response Headers</td>
<td align="center">Response Headers</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">其他字段按需指定</td>
</tr>
</tbody></table>
<p>也就是说改为 gRPC 长连接之后，原先设置 Http 请求/响应所携带的相关数据都有具体的协议格式来于此对应，与此同时，在此基础上还丰富了原有的通信协议(例如 RequestId，Source 等)。在不失扩展性的同时，还降低了切换时数据通信改造和学习的成本。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/21/nacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="灰(｢･ω･)｢嘿灰">
      <meta itemprop="description" content="学习还是需要记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/21/nacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">nacos之注册中心原理解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-21 16:08:19 / Modified: 17:07:13" itemprop="dateCreated datePublished" datetime="2020-12-21T16:08:19+08:00">2020-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>注册和撤销服务，使用NamingProxy进行Http调用，使用jdk自带的Http协议API</li>
<li>查询服务，使用HostReactor类借助NamingProxy进行服务查询，重点是使用PushReceiver类创建UDP长连接，更新服务</li>
<li>subscribe/unsubscribe,使用EventDispatcher类addListener方法添加监听，重点是使用PushReceiver类创建UDP长连接，更新服务</li>
<li>都是使用定时任务线程池ScheduledExecutorService进行多线程处理</li>
</ul>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="string">&quot;serverAddr&quot;</span>, System.getProperty(<span class="string">&quot;serverAddr&quot;</span>));</span><br><span class="line">properties.setProperty(<span class="string">&quot;namespace&quot;</span>, System.getProperty(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line"></span><br><span class="line">NamingService naming = NamingFactory.createNamingService(properties);</span><br><span class="line"></span><br><span class="line">naming.registerInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;11.11.11.11&quot;</span>, <span class="number">8888</span>, <span class="string">&quot;TEST1&quot;</span>);</span><br><span class="line">naming.registerInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;2.2.2.2&quot;</span>, <span class="number">9999</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">System.out.println(naming.getAllInstances(<span class="string">&quot;nacos.test.3&quot;</span>));</span><br><span class="line">naming.deregisterInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;2.2.2.2&quot;</span>, <span class="number">9999</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">System.out.println(naming.getAllInstances(<span class="string">&quot;nacos.test.3&quot;</span>));</span><br><span class="line"></span><br><span class="line">naming.subscribe(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        System.out.println(((NamingEvent)event).getServiceName());</span><br><span class="line">        System.out.println(((NamingEvent)event).getInstances());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="NamingService"><a href="#NamingService" class="headerlink" title="NamingService"></a>NamingService</h2><p>NamingService是Nacos对外提供给使用者的接口，其实现类为com.alibaba.nacos.client.naming.NacosNamingService，归纳起来，NamingService提供了以下方法：</p>
<ul>
<li>registerInstance：注册实例。</li>
<li>deregisterInstance：注销实例。</li>
<li>getAllInstances：获取某一服务的所有实例。</li>
<li>selectInstances：获取某一服务健康或不健康的实例。</li>
<li>selectOneHealthyInstance：根据权重选择一个健康的实例。</li>
<li>getServerStatus：检测服务端健康状态。</li>
<li>subscribe：注册对某个服务的监听。</li>
<li>unsubscribe：注销对某个服务的监听。</li>
<li>getSubscribeServices：获取被监听的服务。</li>
<li>getServicesOfServer：获取命名空间（namespace)下的所有服务名。</li>
</ul>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><img src="/2020/12/21/nacos%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/baa968b2dce6422703ca528e5550ca19" alt="core-class" style="zoom: 50%;">

<h2 id="NacosNamingService"><a href="#NacosNamingService" class="headerlink" title="NacosNamingService"></a>NacosNamingService</h2><p>NacosNamingService是NamingService接口的实现类。实现了上面提到的那些方法。此外，NacosNamingService还起到了初始化其他核心类的作用，因为对外提供的方法都是委托给其他核心类处理的。按顺序将依次初始化EventDispatcher、NamingProxy、BeatReactor、HostReactor。从NacosNamingService的构造函数我们也可以了解到，可以进行一些参数的自定义，可参考<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/concepts.html">官方文档</a></p>
<h2 id="EventDispatcher"><a href="#EventDispatcher" class="headerlink" title="EventDispatcher"></a>EventDispatcher</h2><p>EventDispatcher与其他事件分发的组件没什么不同，用于处理subscribe、unsubscribe等等与服务监听相关的方法，并分发NamingEvent到各Listener。成员变量ConcurrentMap&lt;String, List<EventListener>&gt; observerMap保存了注册的Listener，key为{服务名}@@{集群名}，value为各个EventListener的列表。EventDispatcher会启动<strong>1</strong>个名为com.alibaba.nacos.naming.client.listener的线程用于处理事件的分发。</EventListener></p>
<blockquote>
<p>注意点：</p>
<ul>
<li>分发NamingEvent时，按照subscribe(…)方法的调用顺序串行依次调用EventListener的onEvent(…)方法。</li>
<li>调用subscribe(…)方法会引起对应Service的事件分发。</li>
</ul>
</blockquote>
<h2 id="NamingProxy"><a href="#NamingProxy" class="headerlink" title="NamingProxy"></a>NamingProxy</h2><p>NamingProxy用于<strong>与Nacos服务端通信</strong>，注册服务、注销服务、发送心跳等都经由NamingProxy来请求服务端。NamingProxy会启动<strong>1</strong>个名为com.alibaba.nacos.client.naming.serverlist.updater的线程，用于定期调用refreshSrvIfNeed()方法更新Nacos服务端地址，默认间隔为<strong>30秒</strong>，对服务端API的调用将在后文总结。</p>
<blockquote>
<p>注意点：refreshSrvIfNeed()方法对Nacos服务端地址的更新仅在使用endpoint的时候才会进行实际更新，如果是通过serverAddr配置的Nacos服务端地址，refreshSrvIfNeed()方法将不会进行任何操作。</p>
</blockquote>
<h2 id="BeatReactor"><a href="#BeatReactor" class="headerlink" title="BeatReactor"></a>BeatReactor</h2><p>BeatReactor用于<strong>向Nacos服务端发送已注册服务的心跳</strong>。成员变量Map&lt;String, BeatInfo&gt; dom2Beat中保存了需要发送的BeatInfo，key为{serviceName}#{ip}#{port}，value为对应的BeatInfo。BeatReactor会启动名为com.alibaba.nacos.naming.beat.sender的线程来发送心跳，默认线程数为1~CPU核心数的一半，可由namingClientBeatThreadCount参数指定。<br>默认情况下每<strong>5秒</strong>发送一次心跳，可根据Nacos服务端返回的clientBeatInterval的值调整心跳间隔。</p>
<h2 id="HostReactor"><a href="#HostReactor" class="headerlink" title="HostReactor"></a>HostReactor</h2><p>HostReactor<strong>用于获取、保存、更新各Service实例信息。</strong>成员变量Map&lt;String, ServiceInfo&gt; serviceInfoMap中保存了已获取到的服务的信息，key为{服务名}@@{集群名}。HostReactor会启动名为com.alibaba.nacos.client.naming.updater的线程来更新服务信息，默认线程数为1~CPU核心数的一半，可由namingPollingThreadCount参数指定。定时任务UpdateTask会根据服务的cacheMillis值定时更新服务信息，默认值为<strong>10秒</strong>。该定时任务会在获取某一服务信息时创建，保存在成员变量Map&lt;String, ScheduledFuture&lt;?&gt;&gt; futureMap中。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="PushReceiver"><a href="#PushReceiver" class="headerlink" title="PushReceiver"></a>PushReceiver</h3><p>PushReceiver<strong>用于接收Nacos服务端的推送</strong>，初始化时会创建DatagramSocket使用UDP的方式接收推送。会启动<strong>1</strong>个名为com.alibaba.nacos.naming.push.receiver的线程。</p>
<h3 id="FailoverReactor"><a href="#FailoverReactor" class="headerlink" title="FailoverReactor"></a>FailoverReactor</h3><p>用于故障转移，会启动<strong>1</strong>个名为com.alibaba.nacos.naming.failover的线程并定时读取名为00-00—000-VIPSRV_FAILOVER_SWITCH-000—00-00的文件，内容为1时表示开启，此时获取服务信息时会返回FailoverReactor缓存的服务信息。</p>
<h3 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h3><p>根据服务实例的权重挑选一个实例，实现简单的负载均衡。</p>
<h3 id="DiskCache"><a href="#DiskCache" class="headerlink" title="DiskCache"></a>DiskCache</h3><p>用于服务信息的持久化。</p>
<h2 id="Naming-API"><a href="#Naming-API" class="headerlink" title="Naming API"></a>Naming API</h2><p>API汇总如下：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>URI</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>POST</td>
<td>/nacos/v1/ns/instance</td>
<td>注册实例</td>
</tr>
<tr>
<td>DELETE</td>
<td>/nacos/v1/ns/instance</td>
<td>注销实例</td>
</tr>
<tr>
<td>GET</td>
<td>/nacos/v1/ns/instance/list</td>
<td>获取实例列表</td>
</tr>
<tr>
<td>PUT</td>
<td>/nacos/v1/ns/instance/beat</td>
<td>发送心跳</td>
</tr>
<tr>
<td>GET</td>
<td>/nacos/v1/ns/api/hello</td>
<td>Nacos服务端状态</td>
</tr>
<tr>
<td>GET</td>
<td>/nacos/v1/ns/service/list</td>
<td>获取所有服务名</td>
</tr>
</tbody></table>
<h2 id="参数列表及示例"><a href="#参数列表及示例" class="headerlink" title="参数列表及示例"></a>参数列表及示例</h2><h3 id="注册实例"><a href="#注册实例" class="headerlink" title="注册实例"></a>注册实例</h3><table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>namespaceId</td>
<td>命名空间</td>
<td>默认为public</td>
</tr>
<tr>
<td>ip</td>
<td>实例IP地址</td>
<td></td>
</tr>
<tr>
<td>port</td>
<td>实例端口</td>
<td></td>
</tr>
<tr>
<td>weight</td>
<td>权重</td>
<td>默认为1.0</td>
</tr>
<tr>
<td>enable</td>
<td>是否开启</td>
<td>默认为true</td>
</tr>
<tr>
<td>healthy</td>
<td>健康状态</td>
<td>默认为true</td>
</tr>
<tr>
<td>metadata</td>
<td>其他信息</td>
<td></td>
</tr>
<tr>
<td>serviceName</td>
<td>服务名</td>
<td></td>
</tr>
<tr>
<td>clusterName</td>
<td>集群名</td>
<td>默认为DEFAULT</td>
</tr>
</tbody></table>
<p>请求示例：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/v1/ns/instance?metadata=%7B%7D&namespaceId=public&port=8888&enable=true&healthy=true&ip=11.11.11.11&clusterName=TEST1&weight=1.0&serviceName=nacos.test.3&encoding=UTF-8&">http://localhost:8848/nacos/v1/ns/instance?metadata=%7B%7D&amp;namespaceId=public&amp;port=8888&amp;enable=true&amp;healthy=true&amp;ip=11.11.11.11&amp;clusterName=TEST1&amp;weight=1.0&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;</a></p>
<p>返回示例：ok</p>
<h3 id="注销实例"><a href="#注销实例" class="headerlink" title="注销实例"></a>注销实例</h3><table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>namespaceId</td>
<td>命名空间</td>
<td>默认为public</td>
</tr>
<tr>
<td>ip</td>
<td>实例IP地址</td>
<td></td>
</tr>
<tr>
<td>port</td>
<td>实例端口</td>
<td></td>
</tr>
<tr>
<td>serviceName</td>
<td>服务名</td>
<td></td>
</tr>
<tr>
<td>clusterName</td>
<td>集群名</td>
<td>默认为DEFAULT</td>
</tr>
</tbody></table>
<p>请求示例：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/v1/ns/instance?cluster=DEFAULT&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;port=9999&amp;ip=2.2.2.2&amp;">http://localhost:8848/nacos/v1/ns/instance?cluster=DEFAULT&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;port=9999&amp;ip=2.2.2.2&amp;</a></p>
<p>返回示例：ok</p>
<h3 id="获取实例列表"><a href="#获取实例列表" class="headerlink" title="获取实例列表"></a>获取实例列表</h3><table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>namespaceId</td>
<td>命名空间</td>
<td>默认为public</td>
</tr>
<tr>
<td>serviceName</td>
<td>服务名</td>
<td></td>
</tr>
<tr>
<td>clusters</td>
<td>集群名</td>
<td>默认为DEFAULT</td>
</tr>
<tr>
<td>udpPort</td>
<td>监听的UPD端口号</td>
<td>由PushReceiver创建</td>
</tr>
<tr>
<td>clientIP</td>
<td>客户端IP</td>
<td></td>
</tr>
<tr>
<td>healthyOnly</td>
<td>是否只返回健康的实例</td>
<td></td>
</tr>
</tbody></table>
<p>请求示例：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/v1/ns/instance/list?healthyOnly=false&amp;namespaceId=public&amp;clientIP=172.16.20.114&amp;serviceName=nacos.test.3&amp;udpPort=53957&amp;encoding=UTF-8&amp;">http://localhost:8848/nacos/v1/ns/instance/list?healthyOnly=false&amp;namespaceId=public&amp;clientIP=172.16.20.114&amp;serviceName=nacos.test.3&amp;udpPort=53957&amp;encoding=UTF-8&amp;</a></p>
<p>返回示例：{“metadata”:{},”dom”:”nacos.test.3”,”cacheMillis”:10000,”useSpecifiedURL”:false,”hosts”:[{“valid”:true,”marked”:false,”metadata”:{},”instanceId”:”2.2.2.2#9999#DEFAULT#nacos.test.3”,”port”:9999,”ip”:”2.2.2.2”,”clusterName”:”DEFAULT”,”weight”:1.0,”serviceName”:”nacos.test.3”,”enabled”:true},{“valid”:true,”marked”:false,”metadata”:{},”instanceId”:”11.11.11.11#8888#TEST1#nacos.test.3”,”port”:8888,”ip”:”11.11.11.11”,”clusterName”:”TEST1”,”weight”:1.0,”serviceName”:”nacos.test.3”,”enabled”:true}],”checksum”:”bd1054e6afb8d10730d945d74c4ce4421550584589236”,”lastRefTime”:1550584589236,”env”:””,”clusters”:””}</p>
<h3 id="发送心跳"><a href="#发送心跳" class="headerlink" title="发送心跳"></a>发送心跳</h3><table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>namespaceId</td>
<td>命名空间</td>
<td>默认为public</td>
</tr>
<tr>
<td>serviceName</td>
<td>服务名</td>
<td></td>
</tr>
<tr>
<td>beat</td>
<td>BeatInfo的JSON字符串</td>
<td></td>
</tr>
</tbody></table>
<p>BeatInfo对象结构如下，与Instance对象类似：</p>
<table>
<thead>
<tr>
<th>field</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>port</td>
<td>端口</td>
<td></td>
</tr>
<tr>
<td>ip</td>
<td>IP地址</td>
<td></td>
</tr>
<tr>
<td>weight</td>
<td>权重</td>
<td></td>
</tr>
<tr>
<td>metadata</td>
<td>其他信息</td>
<td></td>
</tr>
<tr>
<td>serviceName</td>
<td>服务名</td>
<td></td>
</tr>
<tr>
<td>clusterName</td>
<td>集群名</td>
<td></td>
</tr>
<tr>
<td>scheduled</td>
<td>是否心跳中</td>
<td>这个是BeatReactor用来标识状态的</td>
</tr>
</tbody></table>
<p>请求示例：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/v1/ns/instance/beat?beat=%7B%22cluster%22:%22DEFAULT%22,%22ip%22:%222.2.2.2%22,%22metadata%22:%7B%7D,%22port%22:9999,%22scheduled%22:true,%22serviceName%22:%22nacos.test.3%22,%22weight%22:1.0%7D&serviceName=nacos.test.3&encoding=UTF-8&namespaceId=public&">http://localhost:8848/nacos/v1/ns/instance/beat?beat=%7B%22cluster%22%3A%22DEFAULT%22%2C%22ip%22%3A%222.2.2.2%22%2C%22metadata%22%3A%7B%7D%2C%22port%22%3A9999%2C%22scheduled%22%3Atrue%2C%22serviceName%22%3A%22nacos.test.3%22%2C%22weight%22%3A1.0%7D&amp;serviceName=nacos.test.3&amp;encoding=UTF-8&amp;namespaceId=public&amp;</a></p>
<p>返回示例：{“clientBeatInterval”:5000}</p>
<h3 id="Nacos服务端状态"><a href="#Nacos服务端状态" class="headerlink" title="Nacos服务端状态"></a>Nacos服务端状态</h3><table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>namespaceId</td>
<td>命名空间</td>
<td>默认为public</td>
</tr>
</tbody></table>
<p>请求示例：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/v1/ns/api/hello?encoding=UTF-8&amp;namespaceId=public&amp;">http://localhost:8848/nacos/v1/ns/api/hello?encoding=UTF-8&amp;namespaceId=public&amp;</a></p>
<p>返回示例：{“msg”:”Hello! I am Nacos-Naming and healthy! total services: raft 2, local port:8848”}</p>
<h3 id="获取所有服务名"><a href="#获取所有服务名" class="headerlink" title="获取所有服务名"></a>获取所有服务名</h3><table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>namespaceId</td>
<td>命名空间</td>
<td>默认为public</td>
</tr>
<tr>
<td>pageNo</td>
<td>页码</td>
<td>注意从1开始</td>
</tr>
<tr>
<td>pageSize</td>
<td>返回数量</td>
<td></td>
</tr>
<tr>
<td>selector</td>
<td>过滤器</td>
<td></td>
</tr>
</tbody></table>
<p>请求示例：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/v1/ns/service/list?pageSize=100&amp;encoding=UTF-8&amp;namespaceId=public&amp;pageNo=0&amp;">http://localhost:8848/nacos/v1/ns/service/list?pageSize=100&amp;encoding=UTF-8&amp;namespaceId=public&amp;pageNo=0&amp;</a></p>
<p>返回示例：{“count”:1,”doms”:[“nacos.test.3”]}</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">灰(｢･ω･)｢嘿灰</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
