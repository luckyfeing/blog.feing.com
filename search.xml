<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ribbon源码解析</title>
      <link href="2020/12/11/Ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2020/12/11/Ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://www.cnblogs.com/trust-freedom/">Trust_FreeDom</a></p><p>出处：<a href="https://www.cnblogs.com/trust-freedom/p/11216280.html#3560239013">https://www.cnblogs.com/trust-freedom/p/11216280.html#3560239013</a></p><p>事情的起因是这样的，公司内部要实现基于Zuul网关的灰度路由，在上线时进行灰度测试，故需要配置业务微服务向Eureka注册的metadata元数据，和自定义Ribbon的负载规则达到只访问灰度服务的目的。这样就需要自定义Ribbon的IRule，实现灰度请求只会负载到带有灰度标签元数据的业务微服务上，当自定义IRule规则开发好后，问题是如何将这个IRule规则配置给某个Ribbon Client或者全局生效。</p><blockquote><p>本次使用Spring Cloud Dalston.SR5版本</p><p>在其 <a href="https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi_spring-cloud-ribbon.html">官方文档</a> 中其实已经给出了一些如何针对某个Client 或者 修改默认配置的方式，但没有说明为什么这样使用</p></blockquote><p>下面将按照这样的思路分析：</p><ul><li>简单分析Spring Cloud Ribbon启动时如何自动配置的，以了解其装配到Spring中的Bean</li><li>Spring Cloud Ribbon Client的懒加载</li><li>Spring Cloud Ribbon Client的配置加载，包含全局配置及Client配置</li><li>如何自定义Client配置、全局配置</li><li>解释官方文档中的一些注意事项<h2 id="Spring-Cloud-Ribbon自动配置"><a href="#Spring-Cloud-Ribbon自动配置" class="headerlink" title="Spring Cloud Ribbon自动配置"></a>Spring Cloud Ribbon自动配置</h2></li></ul><p>当前版本中的Netflix所有自动配置都在<code>spring-cloud-netflix-core-xxx.jar</code>中，根据其<code>META-INF/spring.factories</code>中的配置得知，Spring Cloud Ribbon的自动配置类为 <strong><code>RibbonAutoConfiguration</code></strong><br><img src="/2020/12/11/Ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/677054-20190719235138006-1969052898.jpg" alt="img"></p><h2 id="RibbonAutoConfiguration"><a href="#RibbonAutoConfiguration" class="headerlink" title="RibbonAutoConfiguration"></a>RibbonAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; IClient.class, RestTemplate.class, AsyncRestTemplate.class, Ribbon.class&#125;)</span></span><br><span class="line"><span class="meta">@RibbonClients</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(name = &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RibbonEagerLoadProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有针对某个RibbonClient指定的配置</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ribbon是否懒加载的配置文件</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会给每个RibbonClient创建独立的ApplicationContext上下文</span></span><br><span class="line">    <span class="comment">// 并在其上下文中创建RibbonClient对应的Bean：如IClient、ILoadbalancer等</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring创建的带负载均衡功能的Client，会使用SpringClientFactory创建对应的Bean和配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(LoadBalancerClient.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(springClientFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到Spring environment中加载针对某个Client的Ribbon的核心接口实现类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertiesFactory <span class="title">propertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PropertiesFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是懒加载，启动时就使用RibbonApplicationContextInitializer加载并初始化客户端配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;ribbon.eager-load.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RibbonApplicationContextInitializer <span class="title">ribbonApplicationContextInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RibbonApplicationContextInitializer(springClientFactory(),</span><br><span class="line">ribbonEagerLoadProperties.getClients());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>RibbonAutoConfiguration</code>创建的Bean主要分以下几类：</p><ul><li>为Ribbon Client创建环境及获取配置<ul><li><strong>SpringClientFactory</strong>： 会给每个Ribbon Client创建一个独立的Spring应用上下文ApplicationContext，并在其中加载对应的配置及Ribbon核心接口的实现类</li><li><strong>PropertiesFactory</strong>： 用于从Spring enviroment环境中获取针对某个Ribbon Client配置的核心接口实现类，并实例化</li></ul></li><li>创建<code>RibbonLoadBalancerClient</code>，并将springClientFactory注入，方便从中获取对应的配置及实现类，<code>RibbonLoadBalancerClient</code>是Spring对<code>LoadBalancerClient</code>接口的实现类，其<code>execute()</code>方法提供客户端负载均衡能力</li><li>懒加载相关<ul><li>RibbonEagerLoadProperties： 懒加载配置项Properties，可以指定是否懒加载，及哪些Client不懒加载</li><li>RibbonApplicationContextInitializer： 启动时就加载RibbonClient配置（非懒加载）的初始化器</li></ul></li></ul><p>可以看到默认启动流程中并没有加载RibbonClient的上下文和配置信息，而是在使用时才加载，即懒加载</p><h2 id="Spring-Cloud-RibbonClient的懒加载"><a href="#Spring-Cloud-RibbonClient的懒加载" class="headerlink" title="Spring Cloud RibbonClient的懒加载"></a>Spring Cloud RibbonClient的懒加载</h2><p>既然是在使用时才会加载，那么以Zuul网关为例，在其<code>RibbonRoutingFilter</code>中会创建RibbonCommand，其包含了Ribbon的负载均衡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## RibbonRoutingFilter  Zuul负责路由的Filter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRoutingFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line"><span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RibbonCommandContext commandContext = buildCommandContext(context);</span><br><span class="line">ClientHttpResponse response = forward(commandContext);</span><br><span class="line">setResponse(response);</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ZuulException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">forward</span><span class="params">(RibbonCommandContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; info = <span class="keyword">this</span>.helper.debug(context.getMethod(),</span><br><span class="line">context.getUri(), context.getHeaders(), context.getParams(),</span><br><span class="line">context.getRequestEntity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ribbonCommandFactory创建RibbonCommand</span></span><br><span class="line">RibbonCommand command = <span class="keyword">this</span>.ribbonCommandFactory.create(context);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ClientHttpResponse response = command.execute();</span><br><span class="line"><span class="keyword">this</span>.helper.appendDebug(info, response.getStatusCode().value(),</span><br><span class="line">response.getHeaders());</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (HystrixRuntimeException ex) &#123;</span><br><span class="line"><span class="keyword">return</span> handleException(info, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行<code>RibbonRoutingFilter#run()</code>进行路由时会执行<code>forward()</code>方法，由于此处是在<strong>HystrixCommand</strong>内部执行Ribbon负载均衡调用，故使用ribbonCommandFactory创建RibbonCommand，Ribbon客户端的懒加载就在这个方法内，这里我们看<code>HttpClientRibbonCommandFactory</code>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.zuul.filters.route.apache.HttpClientRibbonCommandFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonCommandFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRibbonCommandFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpClientRibbonCommand <span class="title">create</span><span class="params">(<span class="keyword">final</span> RibbonCommandContext context)</span> </span>&#123;</span><br><span class="line">ZuulFallbackProvider zuulFallbackProvider = getFallbackProvider(context.getServiceId());</span><br><span class="line"><span class="keyword">final</span> String serviceId = context.getServiceId();</span><br><span class="line">        <span class="comment">// 通过SpringClientFactory获取IClient接口实例</span></span><br><span class="line"><span class="keyword">final</span> RibbonLoadBalancingHttpClient client = <span class="keyword">this</span>.clientFactory.getClient(</span><br><span class="line">serviceId, RibbonLoadBalancingHttpClient.class);</span><br><span class="line">client.setLoadBalancer(<span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommand(serviceId, client, context, zuulProperties, zuulFallbackProvider,</span><br><span class="line">clientFactory.getClientConfig(serviceId));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>RibbonLoadBalancingHttpClient</code>的逻辑在 <code>SpringClientFactory#getClient(serviceId, RibbonLoadBalancingHttpClient.class)</code>，如下：</p><ul><li>SpringClientFactory#getInstance(name, clientClass)<ul><li>NamedContextFactory#getInstance(name, type)：<ul><li>获取Client对应的ApplicationContext，如没有则调用createContext()创建，其中包含注册统一默认配置类RibbonClientConfiguration，或@RibbonClient、@RibbonClients(defaultConfiguration=xxx) 设置的配置类的逻辑</li><li>从ApplicationContext中根据类型获取实例，如没有使用反射创建，并通过IClientConfig配置</li></ul></li></ul></li></ul><p>如上执行完毕RibbonClient就基本懒加载完成了，就可以到RibbonClient对应的ApplicationContext中继续获取其它核心接口的实现类了，这些实现类都是根据 <strong>默认/全局/Client自定义</strong> 配置创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.SpringClientFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringClientFactory</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">RibbonClientSpecification</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String NAMESPACE = <span class="string">&quot;ribbon&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(RibbonClientConfiguration.class, NAMESPACE, <span class="string">&quot;ribbon.client.name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the rest client associated with the name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RuntimeException if any error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;C extends IClient&lt;?, ?&gt;&gt; <span class="function">C <span class="title">getClient</span><span class="params">(String name, Class&lt;C&gt; clientClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getInstance(name, clientClass);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// name代表当前Ribbon客户端，type代表要获取的实例类型，如IClient、IRule</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">getInstance</span><span class="params">(String name, Class&lt;C&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先从父类NamedContextFactory中直接从客户端对应的ApplicationContext中获取实例</span></span><br><span class="line">        <span class="comment">// 如果没有就根据IClientConfig中的配置找到具体的实现类，并通过反射初始化后放到Client对应的ApplicationContext中</span></span><br><span class="line">C instance = <span class="keyword">super</span>.getInstance(name, type);</span><br><span class="line"><span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">IClientConfig config = getInstance(name, IClientConfig.class);</span><br><span class="line"><span class="keyword">return</span> instantiateWithConfig(getContext(name), type, config);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用IClientConfig实例化</span></span><br><span class="line">    <span class="keyword">static</span> &lt;C&gt; <span class="function">C <span class="title">instantiateWithConfig</span><span class="params">(AnnotationConfigApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;C&gt; clazz, IClientConfig config)</span> </span>&#123;</span><br><span class="line">C result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过以IClientConfig为参数的构造创建clazz类实例</span></span><br><span class="line">Constructor&lt;C&gt; constructor = clazz.getConstructor(IClientConfig.class);</span><br><span class="line">result = constructor.newInstance(config);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="comment">// Ignored</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没创建成功，使用无惨构造</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">result = BeanUtils.instantiate(clazz);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用初始化配置方法</span></span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> IClientConfigAware) &#123;</span><br><span class="line">((IClientConfigAware) result).initWithNiwsConfig(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理自动织入</span></span><br><span class="line"><span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.getAutowireCapableBeanFactory().autowireBean(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//## 父类 org.springframework.cloud.context.named.NamedContextFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">// 维护Ribbon客户端对应的ApplicationContext上下文</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护Ribbon客户端的@Configuration配置类</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defaultConfigType;  <span class="comment">// 默认配置类为 RibbonClientConfiguration</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertySourceName;  <span class="comment">// 默认为 ribbon</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertyName;  <span class="comment">// 默认读取RibbonClient名的属性为ribbon.client.name</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamedContextFactory</span><span class="params">(Class&lt;?&gt; defaultConfigType, String propertySourceName,</span></span></span><br><span class="line"><span class="function"><span class="params">String propertyName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType = defaultConfigType;</span><br><span class="line"><span class="keyword">this</span>.propertySourceName = propertySourceName;</span><br><span class="line"><span class="keyword">this</span>.propertyName = propertyName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果包含Client上下文直接返回</span></span><br><span class="line"><span class="comment">// 如果不包含，调用createContext(name)，并放入contexts集合</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建名为name的RibbonClient的ApplicationContext上下文</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// configurations集合中是否包含当前Client相关配置类，包含即注入到ApplicationContext</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//configurations集合中是否包含default.开头的通过@RibbonClients(defaultConfiguration=xxx)配置的默认配置类</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册PropertyPlaceholderAutoConfiguration、RibbonClientConfiguration</span></span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType);</span><br><span class="line"><span class="comment">// 添加 ribbon.client.name=具体RibbonClient name的enviroment配置 </span></span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置父ApplicationContext，这样可以使得当前创建的子ApplicationContext可以使用父上下文中的Bean</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line">context.refresh();  <span class="comment">//刷新Context</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面比较重要的就是在创建每个RibbonClient的ApplicationContext的<code>createContext(name)</code>方法，其中包含了根据哪个@Configuration配置类创建Ribbon核心接口的实现类的逻辑，故需重点分析（Ribbon核心接口讲解 <a href="https://blog.csdn.net/zhxdick/article/details/79710960">参考</a>）</p><p>那么在<code>createContext(name)</code>方法创建当前Ribbon Client相关的上下文，并注入配置类时，除了默认配置类<code>RibbonClientConfiguration</code>是写死的，其它的配置类，如default全局配置类，针对某个Ribbon Client的配置类，又是怎么配置的呢？</p><h2 id="Spring-Cloud-RibbonClient的配置加载，包含全局配置及Client配置"><a href="#Spring-Cloud-RibbonClient的配置加载，包含全局配置及Client配置" class="headerlink" title="Spring Cloud RibbonClient的配置加载，包含全局配置及Client配置"></a>Spring Cloud RibbonClient的配置加载，包含全局配置及Client配置</h2><h2 id="创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类"><a href="#创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类" class="headerlink" title="创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类"></a>创建RibbonClient对应ApplicationContext，并注册所有可用的Configuration配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.context.named.NamedContextFactory#createContext()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、注册专门为RibbonClient指定的configuration配置类，@RibbonClient注解</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、将为所有RibbonClient的configuration配置类注册到ApplicationContext</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;default.&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、注册defaultConfigType，即Spring的默认配置类 RibbonClientConfiguration</span></span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line">context.refresh();  <span class="comment">// 刷新上下文</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据如上逻辑可以看出会从3个地方将Ribbon相关的Configuration配置类注册到专门为其准备的ApplicationContext上下文，并根据配置类创建Ribbon核心接口的实现类，即达到配置RibbonClient的目的</p><ol><li>从configurations这个Map中根据RibbonClient name获取专门为其指定的configuration配置类，并注册到其对应的ApplicationContext上下文</li><li>从configurations这个Map中找到 <strong>default. 开头</strong> 的配置类，即为所有RibbonClient的默认配置，并注册到其对应的ApplicationContext上下文</li><li>如果不是开发者单独指定的话，前两项都是没有数据的，还会注册Spring Cloud的默认配置类<code>RibbonClientConfiguration</code></li></ol><p>那么configurations这个Map里的配置类数据是从哪儿来的呢？？下面逐步分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## RibbonAutoConfiguration</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是在RibbonAutoConfiguration自动配置类创建<code>SpringClientFactory</code>是设置的，这个configurations集合是@Autowired的Spring容器内的<code>RibbonClientSpecification</code>集合，那么<code>RibbonClientSpecification</code>集合是何时被注册的？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.RibbonClientConfigurationRegistrar</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfigurationRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、@RibbonClients注解</span></span><br><span class="line">Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(</span><br><span class="line">RibbonClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 1.1 value是RibbonClient[]，遍历针对具体的RibbonClient配置的configuration配置类，并注册</span></span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span> &amp;&amp; attrs.containsKey(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">AnnotationAttributes[] clients = (AnnotationAttributes[]) attrs.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes client : clients) &#123;</span><br><span class="line">registerClientConfiguration(registry, getClientName(client),</span><br><span class="line">client.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 1.2 找到@RibbonClients注解的defaultConfiguration，即默认配置</span></span><br><span class="line">        <span class="comment">//     注册成以default.Classname.RibbonClientSpecification为名的RibbonClientSpecification</span></span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span> &amp;&amp; attrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">&#125;</span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">attrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、@RibbonClient注解</span></span><br><span class="line">        <span class="comment">// 注册某个具体Ribbon Client的configuration配置类</span></span><br><span class="line">Map&lt;String, Object&gt; client = metadata.getAnnotationAttributes(</span><br><span class="line">RibbonClient.class.getName(), <span class="keyword">true</span>);</span><br><span class="line">String name = getClientName(client);</span><br><span class="line"><span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">registerClientConfiguration(registry, name, client.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(Map&lt;String, Object&gt; client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String value = (String) client.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(value)) &#123;</span><br><span class="line">value = (String) client.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">&quot;Either &#x27;name&#x27; or &#x27;value&#x27; must be provided in @RibbonClient&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">Object name, Object configuration)</span> </span>&#123;</span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(RibbonClientSpecification.class);</span><br><span class="line">builder.addConstructorArgValue(name);</span><br><span class="line">builder.addConstructorArgValue(configuration);</span><br><span class="line">registry.registerBeanDefinition(name + <span class="string">&quot;.RibbonClientSpecification&quot;</span>,</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可知，configurations配置类集合是根据<code>@RibbonClient</code> 和 <code>@RibbonClients</code> 注解配置的，分别有 <em>针对具体某个RibbonClient的配置</em> 和 <em>default默认配置</em></p><p>总结一下，Ribbon相关的@Configuration配置类是如何加载的</p><ol><li>在创建完RibbonClient对应的AnnotationConfigApplicationContext后，先从根据<code>@RibbonClient</code> 和 <code>@RibbonClients</code> 注解加载的configurations集合中找当前RibbonClient name对应的配置类，如有，就注册到上下文</li><li>再从configurations集合中找根据<code>@RibbonClients</code>注解加载的 <strong>default.开头</strong> 的默认配置类，如有，就注册到上下文</li><li>最后注册Spring Cloud默认的 <code>RibbonClientConfiguration</code></li></ol><p>上面说是如何创建RibbonClient相关的ApplicationContext上下文及注册Ribbon Client相关的配置类的逻辑，在确定配置类后，其中会用到Ribbon的<code>IClientConfig</code>相关的客户端配置来加载Ribbon客户端相关的配置信息，如超时配置、具体创建哪个核心接口的实现类等，可以从Spring Cloud默认注册的 <code>RibbonClientConfiguration</code>来一探究竟</p><h2 id="RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建"><a href="#RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建" class="headerlink" title="RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建"></a>RibbonClientConfiguration配置加载及Ribbon核心接口实现类创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration</span></span><br><span class="line"><span class="meta">@Import(&#123;OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;ribbon.client.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name = <span class="string">&quot;client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span></span><br><span class="line"><span class="comment">// associated with ribbon clients</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IClientConfig <span class="title">ribbonClientConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DefaultClientConfigImpl config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">config.loadProperties(<span class="keyword">this</span>.name);</span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">rule.initWithNiwsConfig(config);</span><br><span class="line"><span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只截取了一段代码，给出了Ribbon相关的 <code>IClientConfig</code>客户端配置 和 某一个核心接口<code>IRule</code>实现类 是如何加载配置并创建的</p><p><strong>IClientConfig</strong></p><p><code>IClientConfig</code>就是Ribbon客户端配置的接口，可以看到先是创建了<code>DefaultClientConfigImpl</code>默认实现类，再<code>config.loadProperties(this.name)</code>加载当前Client相关的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//## com.netflix.client.config.DefaultClientConfigImpl#loadProperties()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load properties for a given client. It first loads the default values for all properties,</span></span><br><span class="line"><span class="comment"> * and any properties already defined with Archaius ConfigurationManager.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(String restClientName)</span></span>&#123;</span><br><span class="line">    enableDynamicProperties = <span class="keyword">true</span>;</span><br><span class="line">    setClientName(restClientName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、使用Netflix Archaius的ConfigurationManager从Spring env中加载“ribbon.配置项”这类默认配置</span></span><br><span class="line">    <span class="comment">//   如没加载到有默认静态配置</span></span><br><span class="line">    loadDefaultValues();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、使用Netflix Archaius的ConfigurationManager从Spring env中加载“client名.ribbon.配置项”这类针对某个Client的配置信息</span></span><br><span class="line">    Configuration props = ConfigurationManager.getConfigInstance().subset(restClientName);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;String&gt; keys = props.getKeys(); keys.hasNext(); )&#123;</span><br><span class="line">        String key = keys.next();</span><br><span class="line">        String prop = key;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prop.startsWith(getNameSpace()))&#123;</span><br><span class="line">                prop = prop.substring(getNameSpace().length() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setPropertyInternal(prop, getStringValue(props, key));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;Property %s is invalid&quot;</span>, prop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据如上注释，如果你没有在项目中指定ribbon相关配置，那么会使用<code>DefaultClientConfigImpl</code>中的默认静态配置，如果Spring enviroment中包含“ribbon.配置项”这类针对所有Client的配置会被加载进来，有“client名.ribbon.配置项”这类针对某个Client的配置信息也会被加载进来</p><p><strong>静态配置如下：</strong></p><p><a href="https://img2018.cnblogs.com/blog/677054/201907/677054-20190719235215286-1439271885.jpg"><img src="https://img2018.cnblogs.com/blog/677054/201907/677054-20190719235215286-1439271885.jpg" alt="img"></a></p><p><strong>RibbonClient核心接口实现类配置加载及创建</strong></p><p>上面说完<code>IClientCOnfig</code>配置项是如何加载的，按道理说其中已经包含了当前RibbonClient使用哪个核心接口实现类的配置，但Spring Cloud在此处定义了自己的实现逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看propertiesFactory是否有关于当前接口的配置，如有就使用，并创建实例返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spring cloud 默认配置</span></span><br><span class="line">ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">rule.initWithNiwsConfig(config);</span><br><span class="line"><span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看<code>PropertiesFactory</code>的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">PropertiesFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">classToProperty.put(ILoadBalancer.class, <span class="string">&quot;NFLoadBalancerClassName&quot;</span>);</span><br><span class="line">classToProperty.put(IPing.class, <span class="string">&quot;NFLoadBalancerPingClassName&quot;</span>);</span><br><span class="line">classToProperty.put(IRule.class, <span class="string">&quot;NFLoadBalancerRuleClassName&quot;</span>);</span><br><span class="line">classToProperty.put(ServerList.class, <span class="string">&quot;NIWSServerListClassName&quot;</span>);</span><br><span class="line">classToProperty.put(ServerListFilter.class, <span class="string">&quot;NIWSServerListFilterClassName&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看当前clazz是否在classToProperty管理的几个核心接口之一</span></span><br><span class="line">    <span class="comment">// 如是，查看Spring environment中是否能找到 “clientName.ribbon.核心接口配置项”的配置信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StringUtils.hasText(getClassName(clazz, name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">String classNameProperty = <span class="keyword">this</span>.classToProperty.get(clazz);</span><br><span class="line">String className = environment.getProperty(name + <span class="string">&quot;.&quot;</span> + NAMESPACE + <span class="string">&quot;.&quot;</span> + classNameProperty);</span><br><span class="line"><span class="keyword">return</span> className;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是先调用getClassName()获取Spring enviroment中配置的核心接口实现类名</span></span><br><span class="line">    <span class="comment">// 再使用IClientConfig配置信息创建其实例</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">get</span><span class="params">(Class&lt;C&gt; clazz, IClientConfig config, String name)</span> </span>&#123;</span><br><span class="line">String className = getClassName(clazz, name);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(className)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; toInstantiate = Class.forName(className);</span><br><span class="line"><span class="keyword">return</span> (C) instantiateWithConfig(toInstantiate, config);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown class to load &quot;</span>+className+<span class="string">&quot; for class &quot;</span> + clazz + <span class="string">&quot; named &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故以上面创建<code>IRule</code>接口实现类的逻辑</p><ul><li>先通过<strong>propertiesFactory</strong>查看Spring enviroment中是否配置了针对当前Ribbon Client的IRule核心接口实现类的配置信息，如有，就创建其实例返回（相关配置格式： clientName.ribbon.NFLoadBalancerRuleClassName=具体IRule实现类）</li><li>如没有，那么没有直接使用Netflix在其<code>DefaultClientConfigImpl</code>中的静态配置，而是使用Spring Cloud自定义的默认实现类，拿<code>IRule</code>规则接口来说是<code>ZoneAvoidanceRule</code></li></ul><blockquote><p><strong>总结：</strong></p><p>首先会创建RibbonClient的ApplicationContext上下文，并确定使用哪个Configuration配置类</p><p>1、@RibbonClients注册的全局默认配置类</p><p>2、@RibbonClient注册的某个Client配置类</p><p>3、Spring Cloud 默认的RibbonClientConfiguration配置类</p><p>确定配置类后就是加载Client相关的IClientConfig配置信息，并创建核心接口实现类</p><p>如果没有自定义全局/客户端配置类，那么就是使用<code>RibbonClientConfiguration</code>，而其规则是</p><p>对于超时等配置（除核心接口实现类以外）：使用Netflix的配置逻辑，通过 <strong>ribbon.xxx</strong> 作为默认配置，以 <strong>clientName.ribbon.xxx</strong> 作为客户端定制配置</p><p>对于核心接口实现类配置：客户端定制配置仍然使用 <strong>clientName.ribbon.xxx</strong>，但默认配置是Spring Cloud在<code>RibbonClientConfiguration</code>方法中写死的默认实现类</p></blockquote><p>已经知道大概的逻辑了，下面就看看具体如何自定义Client配置、全局配置</p><h2 id="如何自定义RibbonClient配置、全局配置"><a href="#如何自定义RibbonClient配置、全局配置" class="headerlink" title="如何自定义RibbonClient配置、全局配置"></a>如何自定义RibbonClient配置、全局配置</h2><p>这部分在Spring Cloud官方reference中有说明 <a href="https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi_spring-cloud-ribbon.html#_customizing_the_ribbon_client">16.2 Customizing the Ribbon Client</a></p><p><img src="/2020/12/11/Ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/677054-20190719235233605-1701546833.jpg" alt="img"></p><p>大致意思如下：</p><ul><li><p>一部分配置（非核心接口实现类的配置）可以使用Netflix原生API提供的方式，即使用如 *<em>.ribbon.**</em> 的方式配置，具体有哪些配置项，可以参考 <code>com.netflix.client.config.CommonClientConfigKey</code></p></li><li><p>如果想比较全面的控制RibbonClient并添加一些额外配置，可以使用 <code>@RibbonClient</code> 或 <code>@RibbonClients</code> 注解，并配置一个配置类，如上的 FooConfiguration</p><ul><li><p>@RibbonClient(name = “foo”, configuration = FooConfiguration.class) 是针对名为 foo 的RibbonClient的配置类，也可以使用@RibbonClients({@RibbonClient数组}) 的形式给某几个RibbonClient设置配置类</p></li><li><p>@RibbonClients( defaultConfiguration = { xxx.class } ) 是针对所有RIbbonClient的默认配置</p><ul><li><p>官方文档说 FooConfiguration配置类 必须是@Configuration的，这样就必须注意，SpringBoot主启动类不能扫描到FooConfiguration，否则针对某个RibbonClient的配置就会变成全局的，原因是在创建每个RibbonClient时会为其创建ApplicationContext上下文，其parent就是主启动类创建的ApplicationContext，子ApplicationContext中可以使用父ApplicationContext中的Bean，且创建Bean时都使用了<code>@ConditionalOnMissingBean</code>，所以FooConfiguration如果被主启动类的上下文加载，且创建了比如IRule的实现类，在某个RIbbonClient创建其子ApplicationContext并@Bean想创建其自定义IRule实现类时，会发现parent ApplicationContext已经存在，就不会创建了，配置就失效了</p><blockquote><p>但在我的实验中，即使FooConfiguration不加@Configuration注解也可以加载为RibbonClient的配置，且由于没有@Configuration了，也不会被主启动类扫描到</p></blockquote></li></ul></li></ul></li></ul><p>所以主要分成2种配置：</p><p>（1）超时时间等静态配置，使用 <strong>ribbon.*** 配置所有Client，使用 *<em>.ribbon.</em></strong> 配置某个Client</p><p>（2）使用哪种核心接口实现类配置，使用**@RibbonClients注解<strong>做默认配置，使用</strong>@RibbonClient**做针对Client的配置（注意@Configuration不要被SpringBoot主启动类扫描到的问题）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-cloud-loadbalancer入门</title>
      <link href="2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://cloud.tencent.com/developer/user/1219867">冷冷</a></p><p>出处：<a href="https://cloud.tencent.com/developer/article/1491013">https://cloud.tencent.com/developer/article/1491013</a></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><strong>加入 loadbalancer pom坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置使用还是和 ribbon 一样配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LbConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doOtherStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://big-provider-server/demo&quot;</span>, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="LoadBalancerClient-实现"><a href="#LoadBalancerClient-实现" class="headerlink" title="LoadBalancerClient 实现"></a>LoadBalancerClient 实现</h3><p><img src="/2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/1.jpeg"></p><ul><li>目前版本只提供了 BlockingLoadBalancerClient 的实现， 注意看中文注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除只保留了核心代码注意</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingLoadBalancerClient</span> <span class="keyword">implements</span> <span class="title">LoadBalancerClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 根据 服务名称去查询可用实例</span></span><br><span class="line">ServiceInstance serviceInstance = choose(serviceId);</span><br><span class="line"><span class="keyword">return</span> execute(serviceId, serviceInstance, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取负载均衡策略</span></span><br><span class="line">ReactiveLoadBalancer&lt;ServiceInstance&gt; loadBalancer = loadBalancerClientFactory</span><br><span class="line">.getInstance(serviceId);</span><br><span class="line"><span class="comment">// 执行负载均衡策略获取可以实例</span></span><br><span class="line">Response&lt;ServiceInstance&gt; loadBalancerResponse = Mono.from(loadBalancer.choose())</span><br><span class="line">.block();</span><br><span class="line"><span class="keyword">return</span> loadBalancerResponse.getServer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadBalancer-负载均衡策略实现"><a href="#loadBalancer-负载均衡策略实现" class="headerlink" title="loadBalancer 负载均衡策略实现"></a>loadBalancer <a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>策略实现</h3><p><img src="/2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/2.jpeg">目前只有一个RoundRobinLoadBalancer 轮询选择server的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="title">implements</span> <span class="title">ReactorServiceInstanceLoadBalancer</span> </span>&#123;</span><br><span class="line">public Mono&lt;Response&lt;ServiceInstance&gt;&gt; <span class="function"><span class="title">choose</span>(<span class="params">Request request</span>)</span> &#123;</span><br><span class="line">ServiceInstanceSupplier supplier = <span class="built_in">this</span>.serviceInstanceSupplier.getIfAvailable();</span><br><span class="line"><span class="keyword">return</span> supplier.get().collectList().map(instances -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No servers available for service: &quot;</span> + <span class="built_in">this</span>.serviceId);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EmptyResponse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> enforce order?</span></span><br><span class="line">int pos = <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.position.incrementAndGet());</span><br><span class="line"></span><br><span class="line">ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultResponse(instance);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和ribbon-比较"><a href="#和ribbon-比较" class="headerlink" title="和ribbon 比较"></a>和ribbon 比较</h2><h3 id="默认负载均衡比较"><a href="#默认负载均衡比较" class="headerlink" title="默认负载均衡比较"></a>默认负载均衡比较</h3><ul><li><p>ribbon 提供7中默认的负载均衡策略，常见的常见都有覆盖，一般我们都是使用 ZoneAvoidanceRule复合判断server所在区域的性能和server的可用性选择server</p><p><img src="/2020/12/11/Spring-cloud-loadbalancer%E5%85%A5%E9%97%A8/3.jpeg"></p></li></ul><h3 id="配置方面丰富性"><a href="#配置方面丰富性" class="headerlink" title="配置方面丰富性"></a>配置方面丰富性</h3><ul><li><p>目前<code>spring-cloud-loadbalancer</code> 仅支持 重试操作的配置</p></li><li><p>ribbon 支持超时、懒加载处理、重试及其和 hystrix整合高级属性等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> loadbalancer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack的架构设计</title>
      <link href="2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/u/4376602">osc_s8zboupn</a></p><p>出处：<a href="https://my.oschina.net/u/4376602/blog/3542502">openstack：OpenStack架构详解</a></p><p>OpenStack既是一个社区，也是一个项目和一个开源软件，提供开放源码软件，建立公共和私有云，它提供了一个部署云的操作平台或工具集，其宗旨在于：帮助组织运行为虚拟计算或存储服务的云，为公有云、私有云，也为大云、小云提供可扩展的、灵活的云计算。<br>OpenStackd开源项目由社区维护，包括OpenStack计算（代号为Nova），OpenStack对象存储（代号为Swift），并OpenStack镜像服务（代号Glance）的集合。 OpenStack提供了一个操作平台，或工具包，用于编排云。</p><p>下面列出Openstack的详细构架图</p><p><img src="/2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803154744809-483681990.png" alt="img"></p><p>Openstack的网络拓扑结构图</p><p><img src="/2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803154957606-291369411.png" alt="img"></p><p>整个OpenStack是由控制节点，计算节点，网络节点，存储节点四大部分组成。（这四个节点也可以安装在一台机器上，单机部署）<br>其中：<br>控制节点负责对其余节点的控制，包含虚拟机建立，迁移，网络分配，存储分配等等<br>计算节点负责虚拟机运行<br>网络节点负责对外网络与内网络之间的通信<br>存储节点负责对虚拟机的额外存储管理等等</p><p>控制节点架构：</p><p>控制节点包括以下服务</p><p>  管理支持服务</p><p>  基础管理服务</p><p>  扩展管理服务</p><p>  1）管理支持服务包含MySQL与Qpid两个服务</p><p>MySQL：数据库作为基础/扩展服务产生的数据存放的地方</p><p>Qpid：消息代理(也称消息中间件)为其他各种服务之间提供了统一的消息通信服务</p><p>  2）基础管理服务包含Keystone，Glance，Nova，Neutron，Horizon五个服务</p><p>Keystone：认证管理服务，提供了其余所有组件的认证信息/令牌的管理，创建，修改等等，使用MySQL作为统一的数据库</p><p>Glance：镜像管理服务，提供了对虚拟机部署的时候所能提供的镜像的管理，包含镜像的导入，格式，以及制作相应的模板</p><p>Nova：计算管理服务，提供了对计算节点的Nova的管理，使用Nova-API进行通信</p><p>Neutron：网络管理服务，提供了对网络节点的网络拓扑管理，同时提供Neutron在Horizon的管理面板</p><p>Horizon：控制台服务，提供了以Web的形式对所有节点的所有服务的管理，通常把该服务称为DashBoard</p><p>  3）扩展管理服务包含Cinder，Swift，Trove，Heat，Centimeter五个服务</p><p>Cinder：提供管理存储节点的Cinder相关，同时提供Cinder在Horizon中的管理面板</p><p>Swift：提供管理存储节点的Swift相关，同时提供Swift在Horizon中的管理面板</p><p>Trove：提供管理数据库节点的Trove相关，同时提供Trove在Horizon中的管理面板</p><p>Heat：提供了基于模板来实现云环境中资源的初始化，依赖关系处理，部署等基本操作，也可以解决自动收缩,负载均衡等高级特性。</p><p>Centimeter：提供对物理资源以及虚拟资源的监控，并记录这些数据，对该数据进行分析，在一定条件下触发相应动作</p><p>控制节点一般来说只需要一个网络端口用于通信/管理各个节点</p><p>网络节点架构</p><p>网络节点仅包含Neutron服务</p><p>Neutron：负责管理私有网段与公有网段的通信，以及管理虚拟机网络之间的通信/拓扑，管理虚拟机之上的防火等等</p><p>网络节点包含三个网络端口</p><p>eth0：用于与控制节点进行通信</p><p>eth1：用于与除了控制节点之外的计算/存储节点之间的通信</p><p>eth2：用于外部的虚拟机与相应网络之间的通信</p><p>计算节点架构</p><p>计算节点包含Nova，Neutron，Telemeter三个服务</p><p> 1）基础服务</p><p>Nova：提供虚拟机的创建，运行，迁移，快照等各种围绕虚拟机的服务，并提供API与控制节点对接，由控制节点下发任务</p><p>Neutron：提供计算节点与网络节点之间的通信服务</p><p> 2）扩展服务</p><p>Telmeter：提供计算节点的监控代理，将虚拟机的情况反馈给控制节点，是Centimeter的代理服务</p><p>计算节点包含最少两个网络端口</p><p>eth0：与控制节点进行通信，受控制节点统一调配</p><p>eth1：与网络节点，存储节点进行通信</p><p>存储节点架构</p><p>存储节点包含Cinder，Swift等服务</p><p>Cinder：块存储服务，提供相应的块存储，简单来说，就是虚拟出一块磁盘，可以挂载到相应的虚拟机之上，不受文件系统等因素影响，对虚拟机来说，这个操作就像是新加了一块硬盘，可以完成对磁盘的任何操作，包括挂载，卸载，格式化，转换文件系统等等操作，大多应用于虚拟机空间不足的情况下的空间扩容等等</p><p>Swift：对象存储服务，提供相应的对象存储，简单来说，就是虚拟出一块磁盘空间，可以在这个空间当中存放文件，也仅仅只能存放文件，不能进行格式化，转换文件系统，大多应用于云磁盘/文件</p><p>存储节点包含最少两个网络接口</p><p>eth0：与控制节点进行通信，接受控制节点任务，受控制节点统一调配</p><p>eth1：与计算/网络节点进行通信，完成控制节点下发的各类任务</p><p>-—————————————————————————————————————————————————————————————</p><p>下面说一说Openstack的各个组件作用及关系</p><p>Openstack发展至今，总共集成了下面几个组件：</p><p>Nova - 计算服务<br>Neutron-网络服务<br>Swift - 对象存储服务<br>Cinder-块存储服务<br>Glance - 镜像服务<br>Keystone - 认证服务<br>Horizon - UI服务<br>Ceilometer-监控服务<br>Heat-集群服务<br>Trove-数据库服务</p><p>组件间的关系图如下：</p><p><img src="/2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/907596-20160803161818153-400482667.png" alt="img"></p><p>重要组件介绍</p><p>OpenStack认证服务（Keystone）<br>Keystone为所有的OpenStack组件提供认证和访问策略服务，它依赖自身REST（基于Identity API）系统进行工作，主要对（但不限于）Swift、Glance、Nova等进行认证与授权。事实上，授权通过对动作消息来源者请求的合法性进行鉴定。下图显示了身份认证服务流程：</p><p><img src="/2020/12/10/OpenStack%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/0b988d224229300230a345f657c1c909103.png" alt="img"></p><p>Keystone采用两种授权方式，一种基于用户名/密码，另一种基于令牌（Token）。</p><p>除此之外，Keystone提供以下三种服务：<br>  令牌服务：含有授权用户的授权信息<br>  目录服务：含有用户合法操作的可用服务列表<br>  策略服务：利用Keystone具体指定用户或群组某些访问权限</p><p>keystone认证服务注意点：</p><p>服务入口：如Nova、Swift和Glance一样每个OpenStack服务都拥有一个指定的端口和专属的URL，我们称其为入口（endpoints）。</p><p>区位：在某个数据中心，一个区位具体指定了一处物理位置。在典型的云架构中，如果不是所有的服务都访问分布式数据中心或服务器的话，则也称其为区位。</p><p>用户：Keystone授权使用者<br>　　PS：代表一个个体，OpenStack以用户的形式来授权服务给它们。用户拥有证书（credentials），且可能分配给一个或多个租户。经过验证后，会为每个单独的租户提供一个特定的令牌。</p><p>服务：总体而言，任何通过Keystone进行连接或管理的组件都被称为服务。举个例子，我们可以称Glance为Keystone的服务。</p><p>角色：为了维护安全限定，就云内特定用户可执行的操作而言，该用户关联的角色是非常重要的。<br>　　PS：一个角色是应用于某个租户的使用权限集合，以允许某个指定用户访问或使用特定操作。角色是使用权限的逻辑分组，它使得通用的权限可以简单地分组并绑定到与某个指定租户相关的用户。</p><p>租间：租间指的是具有全部服务入口并配有特定成员角色的一个项目。<br>　　PS：一个租间映射到一个Nova的“project-id”，在对象存储中，一个租间可以有多个容器。根据不同的安装方式，一个租间可以代表一个客户、帐号、组织或项目。</p><p>OpenStack计算设施—-Nova</p><p>Nova是OpenStack计算的弹性控制器。OpenStack云实例生命期所需的各种动作都将由Nova进行处理和支撑，这就意味着Nova以管理平台的身份登场，负责管理整个云的计算资源、网络、授权及测度。虽然Nova本身并不提供任何虚拟能力，但是它将使用libvirt API与虚拟机的宿主机进行交互。Nova通过Web服务API来对外提供处理接口，而且这些接口与Amazon的Web服务接口是兼容的。</p><p>功能及特点：　<br>实例生命周期管理<br>计算资源管理<br>网络与授权管理<br>基于REST的API<br>异步连续通信<br>支持各种宿主：Xen、XenServer/XCP、KVM、UML、VMware vSphere及Hyper-V</p><p>Nova弹性云（OpenStack计算部件）包含以下主要部分：<br>API Server（nova-api）<br>消息队列（rabbit-mq server）<br>运算工作站（nova-compute）<br>网络控制器（nova-network）<br>卷管理（nova-volume）<br>调度器（nova-scheduler）</p><p>解释如下：<br>1）API服务器（nova-api）<br>API服务器提供了云设施与外界交互的接口，它是外界用户对云实施管理的唯一通道。通过使用web服务来调用各种EC2的API，接着API服务器便通过消息队列把请求送达至云内目标设施进行处理。作为对EC2-api的替代，用户也可以使用OpenStack的原生API，我们把它叫做“OpenStack API”。</p><p>2）消息队列（Rabbit MQ Server）<br>OpenStack内部在遵循AMQP（高级消息队列协议）的基础上采用消息队列进行通信。Nova对请求应答进行异步调用，当请求接收后便则立即触发一个回调。由于使用了异步通信，不会有用户的动作被长置于等待状态。例如，启动一个实例或上传一份镜像的过程较为耗时，API调用就将等待返回结果而不影响其它操作，在此异步通信起到了很大作用，使整个系统变得更加高效。</p><p>　3）调度器（nova-scheduler）　　</p><p>调度器负责把nova-API调用送达给目标。调度器以名为“nova-schedule”的守护进程方式运行，并根据调度算法从可用资源池中恰当地选择运算服务器。有很多因素都可以影响调度结果，比如负载、内存、子节点的远近、CPU架构等等。强大的是nova调度器采用的是可插入式架构。</p><p>目前nova调度器使用了几种基本的调度算法：<br>　　随机化：主机随机选择可用节点；<br>　　可用化：与随机相似，只是随机选择的范围被指定；<br>　　简单化：应用这种方式，主机选择负载最小者来运行实例。负载数据可以从别处获得，如负载均衡服务器。</p><p>4）运算工作站（nova-compute）<br>运算工作站的主要任务是管理实例的整个生命周期。他们通过消息队列接收请求并执行，从而对实例进行各种操作。在典型实际生产环境下，会架设许多运算工作站，根据调度算法，一个实例可以在可用的任意一台运算工作站上部署。</p><p>　5）网络控制器（nova-network）<br>网络控制器处理主机的网络配置，例如IP地址分配，配置项目VLAN，设定安全群组以及为计算节点配置网络。</p><p>　6）卷工作站（nova-volume）　<br>卷工作站管理基于LVM的 实例卷，它能够为一个实例创建、删除、附加卷，也可以从一个实例中分离卷。卷管理为何如此重要？因为它提供了一种保持实例持续存储的手段，比如当结束一个 实例后，根分区如果是非持续化的，那么对其的任何改变都将丢失。可是，如果从一个实例中将卷分离出来，或者为这个实例附加上卷的话，即使实例被关闭，数据 仍然保存其中。这些数据可以通过将卷附加到原实例或其他实例的方式而重新访问。</p><p>因此，为了日后访问，重要数据务必要写入卷中。这种应用对于数据服务器实例的存储而言，尤为重要。</p><p>OpenStack镜像服务器—-Glance</p><p>OpenStack镜像服务器是一套虚拟机镜像发现、注册、检索系统，我们可以将镜像存储到以下任意一种存储中：<br>本地文件系统（默认）<br>S3直接存储<br>S3对象存储（作为S3访问的中间渠道）<br>OpenStack对象存储等等。<br>　　<br>功能及特点：<br>提供镜像相关服务。</p><p>Glance构件：<br>1）Glance-API：<br>　 主要负责接收响应镜像管理命令的Restful请求，分析消息请求信息并分发其所带的命令（如新增，删除，更新等）。默认绑定端口是9292。<br>2）Glance-Registry：<br>　　主要负责接收响应镜像元数据命令的Restful请求。分析消息请求信息并分发其所带的命令（如获取元数据，更新元数据等）。默认绑定的端口是9191。</p><p>OpenStack存储设施—-Swift</p><p>Swift为OpenStack提供一种分布式、持续虚拟对象存储，它类似于Amazon Web Service的S3简单存储服务。Swift具有跨节点百级对象的存储能力。Swift内建冗余和失效备援管理，也能够处理归档和媒体流，特别是对大数据（千兆字节）和大容量（多对象数量）的测度非常高效。</p><p>swift功能及特点：　　<br>海量对象存储<br>大文件（对象）存储<br>数据冗余管理<br>归档能力—–处理大数据集<br>为虚拟机和云应用提供数据容器<br>处理流媒体<br>对象安全存储<br>备份与归档<br>良好的可伸缩性</p><p>Swift组件<br>Swift账户<br>Swift容器<br>Swift对象<br>Swift代理<br>Swift RING<br>　　<br>Swift代理服务器　　<br>用户都是通过Swift-API与代理服务器进行交互，代理服务器正是接收外界请求的门卫，它检测合法的实体位置并路由它们的请求。<br>此外，代理服务器也同时处理实体失效而转移时，故障切换的实体重复路由请求。</p><p>Swift对象服务器<br>对象服务器是一种二进制存储，它负责处理本地存储中的对象数据的存储、检索和删除。对象都是文件系统中存放的典型的二进制文件，具有扩展文件属性的元数据（xattr）。</p><p>注意：xattr格式被Linux中的ext3/4，XFS，Btrfs，JFS和ReiserFS所支持，但是并没有有效测试证明在XFS，JFS，ReiserFS，Reiser4和ZFS下也同样能运行良好。不过，XFS被认为是当前最好的选择。</p><p>Swift容器服务器<br>容器服务器将列出一个容器中的所有对象，默认对象列表将存储为SQLite文件（译者注：也可以修改为MySQL，安装中就是以MySQL为例）。容器服务器也会统计容器中包含的对象数量及容器的存储空间耗费。</p><p>Swift账户服务器<br>账户服务器与容器服务器类似，将列出容器中的对象。</p><p>Ring（索引环）</p><p>Ring容器记录着Swift中物理存储对象的位置信息，它是真实物理存储位置的实体名的虚拟映射，类似于查找及定位不同集群的实体真实物理位置的索引服务。这里所谓的实体指账户、容器、对象，它们都拥有属于自己的不同的Rings。</p><p>OpenStack管理的Web接口—-Horizon</p><p>Horizon是一个用以管理、控制OpenStack服务的Web控制面板，它可以管理实例、镜像、创建密匙对，对实例添加卷、操作Swift容器等。除此之外，用户还可以在控制面板中使用终端（console）或VNC直接访问实例。</p><p>总之，Horizon具有如下一些特点：　　<br>实例管理：创建、终止实例，查看终端日志，VNC连接，添加卷等<br>访问与安全管理：创建安全群组，管理密匙对，设置浮动IP等<br>偏好设定：对虚拟硬件模板可以进行不同偏好设定<br>镜像管理：编辑或删除镜像<br>查看服务目录<br>管理用户、配额及项目用途<br>用户管理：创建用户等<br>卷管理：创建卷和快照<br>对象存储处理：创建、删除容器和对象<br>为项目下载环境变量</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudFoundry的架构设计</title>
      <link href="2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/javayou">红薯</a></p><p>出处：<a href="https://www.oschina.net/question/12_32393">深度剖析CloudFoundry的架构设计</a></p><p>VMware发布了业内第一个开源的PaaS——CloudFoundry。Ruby开发的一款开源PaaS云计算平台。</p><p>本文会分为两个部份：第一部份主要介绍CloudFoundry的架构设计，从它所包含的模块介绍起，到各部份的消息流向，各模块如何协调合作；第 二部份会在第一部份的基础上，以如何在你的数据中心里面用CloudFoundry部署一个私有PaaS为目标，把第一部分介绍到的架构知识使用起来。</p><p>第一部份讲的很多内容，会引用Pat在10月12日的VMwareCloud Forum上面关于CloudFoundry架构的演讲。Pat是CloudFoundry Core的负责人，他的那次演讲很值得一听。如果你当时在场，并且理解他所说的内容，本部份可以选择直接跳过。我除了会把说的内容讲具体点外，不太可能可 以讲得比他好。</p><p><strong>一、架构及模块</strong></p><p>从总体地看，CloudFoundry的架构如下：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_dsI0.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>这个架构图以及下文所用到的各模块架构图均来自Pat的PPT。从上图能够看到CloudFoundry主要有以下几大组件组成：</p><p>1、 Router：顾名思义，Router组件在CloudFoundry中是对所有进来的Request进行路由。进入Router的request主要有两类：首先是来自VMCClient或者STS的，由CloudFoundry使用者发出的，管理型指令。</p><p>例如：列出你所有apps的vmcapps，提交一个apps等等。这类request会被路由到AppLife Management组件，又叫CloudController组件去；第二类是外界对你所部署的apps访问的request。这部份requests 会被路由到Appexecution，又或者叫做DEAs的组件去。所有进入CloudFoundry系统的requests都会经过Router组件， 看到这里可能会有朋友会担心Router成为单点，从而成为整个云的瓶颈。</p><p>但是CloudFoundry作为云系统，其设计的核心就是去单点依赖，组件平行扩充，且可替代的以保证扩展性，这是CloudFoundry，甚 至所有云计算系统的设计原则，后文会讨论CloudFoundry如何做到这点，目前只要知道，系统可以部署多个Routers共同处理进来的 requests，但是Router上层的LoadBalance不在CloudFoundry的实现范围，CloudFoundry只保证所有的 request是无状态的，这样就使上层均衡附载选择面非常非常大了，例如可以通过DNS做，也可以部署硬件的LoadBalancer，或者简单点，弄 台ngnix作负载均衡器，都是可行的。</p><p>Router组件，目前版本是对nginx的一个简单封装。熟悉ngnix的朋友应该知道，它可以一个套接字文件（.sock文件）作为输入输出。所有安装CloudFoundry的Router组件服务器都会安装一个nginx，其ngnix.conf文件有以下配置：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_k33L.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>从整体的来看，Router组件的结构如下：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_WBeV.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>外界httprequest进入CloudFoundry服务器，nginx会首先接到request，nginx通过sock与 router.rb进行交互，于是真正处理请求的是Router组件。router.rb里面根据传入的url，用户名密码等，进行逻辑判断，到 CloudController组件或者DEA组件取数据并且返通过与niginx连接的.sock文件返回。</p><p>router.rb是对nginx进行了逻辑封装。熟悉CloudFoundry的朋友肯定知道，CloudFoundry给每一个app分配了一 个url访问，如果直接使用VMware所托管的CloudFoundry.com的话，那你的app的url可能就是 xxx.cloudfoundry.com，无论通过命令给你的app扩展了多少个instances，都是从这个url访问的，这里面的url转换路由 就是由router.rb实现的。</p><p>2、DEA(Droplet Execution Agency): 首先要解析下什么叫做Droplet。Droplet在CloudFoundry的概念里面是指一个把你提交的源代码，以及CloudFoundry配套 好的运行环境，再加上一些管理脚本，例如Start/Stop这些小脚本全部压缩好在一起的tar包。还有一个概念，叫做Stagingapp，就是指制 作上面描述这个包，然后把它存储好的过程。CloudFoundry会自动保存这个Droplet，直到你start一个app的时候，一台部署了DEA 模块的服务器会来拿一个Droplet的copy去运行。所以如果你扩展你的app到10个instances，那这个Droplet就被会复制十份，让 10个DEA服务器拿去运行。</p><p>下图是DEA模块的架构图：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_GFkn.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>Cloud Controller模块（下面会介绍）会发送start/stop等基本的apps管理请求给DEA，dea.rb接收这些请求，然后从NFS里面找到 合适的Droplet。前面说到Droplet其实是一个带有运行脚本的，带运行环境的tar包，DEA只需要把它拿过来解压，并即行里面的start脚 本，就可以让这个app跑起来。到此，app算是可以访问，并start起来了，换句话说就是有这台服务器的某一个端口已经在待命，只要有request 从这个端口进来，这个app就可以接收并返回正确的信息。</p><p>接着dea.rb要做些善后的工作：1、把这个信息告诉Router模块。我们前面说到，所有进入CloudFoundry的requests都是 由Router模块处理并转发的，包括用户对app的访问request，一个app起来后，需要告诉router，让它根据loadbalance等原 则，把合适的request转进来，使这个app的instance能够干起活；2、一些统计性的工作，例如要把这个用户又新部署了一个app告诉 CloudController，以作quota控制等；3、把运行信息告诉HealthManager模块，实时报告该app的instance运行情 况。另外DEA还要负责部份对Droplet的查询工作，譬如，如果用户通过CloudController想查询一个app的log信息，那DEA需要 从该Droplet里面取到log返回等等。</p><p>3、CloudController：CloudController是CloudFoundry的管理模块。主要工作包括：</p><p>a) 对apps的增删改读；</p><p>b) 启动、停止应用程序；</p><p>c) Staging apps（把apps打包成一个droplet）；</p><p>d) 修改应用程序运行环境，包括instance、mem等等；</p><p>e) 管理service，包括service与app的绑定等；</p><p>f) Cloud环境的管理；</p><p>g) 修改Cloud的用户信息；</p><p>h) 查看Cloud Foundry，以及每一个app的log信息。</p><p>这似乎有点复杂，但简单的说，可以很简单：就是与VMC和STS交互的服务器端。VMC和STS与CloudFoundry通信采用的是 restful接口，另一方面CloudController是一个典型的Rubyon Rails项目，从VMC或者STS接到JSON格式的协议，然后写入CloudController Database，并发消息到各模快去控制管理整个云。和其他ROR项目一样，CloudController的所有API可以从 conf/routes.rb里看到。开放的Restful接口好处在于第三方应用开发和集成，企业在用CloudFoundry部署私有云的时候，可以 通过这些接口来自动化控制管理整个Cloud环境。这部份内容将在第二部份论述。</p><p>下图是Cloud Controller的架构图：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_4FyB.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>图中Health Manager和DEA是外部模块，CCDatabase就是CloudController Database，这个是整个CloudFoundry不能做HP的地方。CloudController Database的并发性不会很多，应用级别的数据库访问是由底下的Service模块处理的，这个数据库存的是Cloud的配置信息。读操作主要来自 DEA启动，作为初始化DEA的依据；以及healthmanager模块会从这里读取预期的状态信息，这部份数据会与从DEA得到的实际状态信息进行比 对。</p><p>NFS是多个CloudController的共享存储，CloudController其中一个重要工作就是StagingApps。 Droplets的存储是在集群环境的唯一的。而CloudController是集群运行，换言之，就是每一个控制Request可能由不同的 CloudController处理，假设一个简单的用户场景：我们需要部署一个app到CloudFoundry中。我们在敲完那条简单的push命令 后，VMC开始工作，在做完一轮的用户鉴权、查看所部署的apps数量是否超过预定数额，问了一堆相关app的问题后，需要发4个指令：</p><p>1．发一个POST到”apps”，创建一个app;</p><p>2．发一个PUT到”apps/:name/application”，上传app;</p><p>3．发一个GET到”apps/:name/”，取得app状态，看看是否已经启动；</p><p>4．如果没有启动，发一个PUT到”apps/:name/”，使其启动。</p><p>如果第2和第4步由不同的Cloud Controller来处理，而又无法保证他们能找到同一个Droplet，那第4步将会因为找不到对应的Droplet而启动失败。如何保证这一连串指 令过来所指向的Droplet都是同一个呢？使用NFS，使CloudController共享存储是最简单的方法。但是这个方法在安全性等方面并不完 美。在10月12日的VMwareCloud Forum上，Pat告诉我们下一版本的CloudFoundry这里将会有大调整，但是在那部份代码公开前，我不方便在这评价太多。</p><p>4、HealthManager: 做的事情不复杂，简单的说是从各个DEA里面拿到运行信息，然后进行统计分析，报告等。统计数据会与CloudController的设定指标进行比对， 并提供Alert等。HealthManager模块目前还不是十分完善，但是CloudManage栈里面，自动化health管理、分析是一个很重要 的领域，而这方面可以扩展的地方也很多，结合OrchestrationEngine可以使云自管理、自预警；而与BI方面技术结合，可以统计运营情况， 合理分配资源等。这方面CloudFoundry还在发展之中。</p><p>5、Services:Cloud Foundry的Service模块从源代码控制上看就知道是一个独立的、可Plugin的模块，以方便第三方把自己的服务整合入 CloudFoundry生态系统。在Github上看到service是与CloudFoundry Core项目vcap独立的一个repository，为vcap-service。Service模块其中设计原则是方便第三方服务提供商提供服务。在 这方面CloudFoundry做得很成功，从Github上看，已经有以下服务提供：a)MongoDB; b) mysql; c) neo4j; d) PostgreSql; e) RabbitMQ; f) Redis; g)vBlob。基类都是放在base文件夹中。</p><p>第三方如果需要自己开发CloudFoundry的服务，需要继承改写它里面的两个基础类：Node和Gateway；而里面一些操作， 如：Provision，可以在base的provisioner.rb基础上加入自己的逻辑，同样的还有Service_Error和 Service_Message等。关于如何写自己的Service，ELC的博客会推出相应文章详细论述，并不在本文的讨论范围里面，从架构了解上来 说，只要知道服务间的关系，知道个服务与base间透过继承关系来横向扩充，而CloudFoundry与apps调用Service是通过base来完 成这一简单的架构方法即可。</p><p>6、NATS(Message bus): 从CloudFoundry的总架构图看，位于各模块中心位置的是一个叫nats的组件。NATS是由CloudFoundry的架构师Derek开发的一个轻量级的，支持发布、订阅机制的消息系统。Github开源地址是：<a href="https://github.com/derekcollison/nats%E3%80%82%E5%85%B6%E6%A0%B8%E5%BF%83%E5%9F%BA%E4%BA%8EEventMachine%E5%BC%80%E5%8F%91%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%87%8F%E4%B8%8D%E5%A4%9A%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E6%85%A2%E6%85%A2%E7%A0%94%E7%A9%B6%E3%80%82">https://github.com/derekcollison/nats。其核心基于EventMachine开发，代码量不多，可以下载下来慢慢研究。</a></p><p>CloudFoundry是一个多模块的分布式系统，支持模块自发现，错误自检，且模块间低耦合。其核心原理就是基于消息发布订阅机制。每个台服务 器上的每个模块会根据自己的消息类别，向MessageBus发布多个消息主题；而同时也向自己需要交互的模块，按照需要的信息内容的消息主题订阅消息。 譬如：一个DEA被加入CloudFoundry集群中，它需要向大家吼一下，以表明它已经准备好服务了，它会发布一个主题是”dea.start”的消 息：</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_gxEP.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>@ hello_message_json中包括DEA的UUID,ip, port, 版本信息等内容。</p><p>再例如，CloudController需要启动一个Droplet的instance：</p><p>a)首先一个DEA在启动的时候，会首先会对自己UUID的消息主题进行订阅。</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_xEQk.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>其他模块需要通过’’dea.#{uuid}.start”这个主题发送消息来使它启动，一旦这个DEA接收到消息，就会触发process_dea_start(msg)这个方法来处理启动所需要的工作。</p><p>b)Cloud Controller或者其他模块发送消息，让UUID为xxx的DEA启动。</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_FF7U.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>c)DEA模块接收到消息后，就会触发process_dea_start(msg)方法。msg是由其他模块发送过来的消息内容，包 括：droplet_id,instance_index, service, runtime等内容，process_dea_start会取得这些启动DEA必须的信息，然后进行一系列操作，例如从NFS中取得Droplet，解 压，修改必要环境配置，运行启动脚本等等。等一切都准备好后，然后需要给Router发个消息，告诉它这个Droplet已经随时准备好报效国家，以后有 相应的request记得让它来处理。</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_nMFD.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>d)Router模块在启动时就已经订阅”router.register”消息主题。</p><p><img src="/2020/12/10/CloudFoundry%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/21123334_ehTo.jpg" alt="深度剖析CloudFoundry的架构设计"></p><p>收到前面DEA发出的信息后，会触发register_droplet方法，去绑定Droplet。到此启动一个Droplet的instance工作完成。</p><p>我们可以看到整个CloudFoundry的核心就是一套消息系统，如果想了解CloudFoundry的来龙去脉，去跟踪它里面复杂的消息机制是 非常好的方法。另一方面，CloudFoundry是一套基于消息的分布式系统，面向消息的架构是它节点横向扩展，组件自发现等云特性的基础。</p><p>Cloud Foundry的架构简单介绍至此，其实作为第一款开源的PaaS，CloudFoundry架构有很多可以学习借鉴的地方，很多细节上的处理是很精妙 的，这些内容如果有可能会在后续文章继续探讨，本文题虽为深入CloudFoundry，其实也只是浅尝即止，把总体架构介绍一下，目标在于使我们有足够 的背景知识去用CloudFoundry搭建企业内部的私有PaaS。总结一下，笔者从CloudFoundry的结构中学到的东西：</p><p>1、基于消息的多组件架构是实现集群的简单、且有效方法。消息可以使集群节点间解耦，使自注册，自发现这些在大规模数据中心中很重要的功能得到实现；</p><p>2、适当的抽象层，模板模式的使用，方便第三方可以方便在CloudFoundry开发扩展功能。CloudFoundry在DEA及 Service层都做了抽象层处理，相对应地使开发者可以容易地为CloudFoundry开发Runtime和Service。例如，在 CloudFoundry刚推出的时候，只支持Node.js,Java, Ruby，但第三方提供商、开源社区快速跟进，为CloudFoundry添加了PHP,Python的支持。这得益于CloudFoundry精巧的 DEA架构设计，如何开发新的Runtime支持，会在后续博文中有所论述.</p><p><strong>二、源码导读</strong></p><p>笔者一直觉得深入理解一个技术的最好方法就是读它的源码，而CloudFoundry是完全开源的PaaS平台，而因为刚发展起来，代码量不多，主 要作者们的代码功力也相当不错，读起来很舒服，很适合研读。而不得不再次表扬一下它完全基于消息机制的架构设计，对组件扩展性，第三方接入等方面做得很 好，读者可以从中学到不少思想性的东西。笔者很推荐大家去读一下它的源代码。你可以在Github上找到CloudFoundry的全部代码：<a href="https://github.com/cloudfoundry%EF%BC%8C%E4%BD%A0%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%87%A0%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84Repositories%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9A">https://github.com/cloudfoundry，你会看到几个不同的Repositories，它们分别是：</a></p><p>1、vcap: Cloud Foundry的Core，又或者称作Kernel；</p><p>2、vcap-service: Cloud Foundry的Service组件。Cloud Foundry的service是作为插件提供的，这出于它方便第三方开发service而设计的；</p><p>3、vmc: VMware Cloud CLI. 是一个Ruby应用，与Cloud Foundry的CLI交互。主要通过分析用户输入的CLI，向CloudFoundry发送Restful请求；</p><p>4、vcap-java: 如果你的app是用java开发，且需要与Cloud Foundry交互，例如取得当前serviceserver的ip地址等，你可能需要这个jar，里面对我们Java开发常用框架有所支持，它底层也是 对CloudFoundry的Restful请求的包装；</p><p>5、vcap-java-client: Cloud Foundry的Restful API的Java封装，与上面的项目不一样，它只是个简单的读取CloudFoundry信息，并放如JavaBean中；</p><p>6、vcap-test: Cloud Foundry的test cases;</p><p>7、vcap-test-assets: Cloud Foundry一些apps示例。</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudFoundry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack和CloudFoundry</title>
      <link href="2020/12/10/OpenStack%E5%92%8CCloudFoundry/"/>
      <url>2020/12/10/OpenStack%E5%92%8CCloudFoundry/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h2><p>OpenStack 是一个旨在为公共及私有云的建设与管理提供软件的开源项目。它的社区拥有超过130家企业及1350位开发者，这些机构与个人都将OpenStack作为基础设施即服务（简称IaaS）资源的通用前端。OpenStack项目的首要任务是简化云的部署过程并为其带来良好的可扩展性。OpenStack 源码在 Git@OSC 上的镜像：<a href="http://git.oschina.net/openstack">http://git.oschina.net/openstack</a></p><p>开源项目，搭建私有云，公有云，混合云。openStack是偏IaaS层的开源云计算框架</p><p><img src="/2020/12/10/OpenStack%E5%92%8CCloudFoundry/001610_vm0P_5189.jpg" alt="img"></p><h2 id="CloudFoundry"><a href="#CloudFoundry" class="headerlink" title="CloudFoundry"></a>CloudFoundry</h2><p>Cloud Foundry是一个独立于云的平台即服务解决方案，也是业界最成功的PaaS平台，是PaaS层的开源框架。。Cloud Foundry提供了一个可轻松运行、扩展和维护应用程序的环境和快速便捷的开发者体验。Cloud Foundry支持Java、NodeJS、Ruby、Python等大多数语言和环境。</p><p>开源的Cloud Foundry由Cloud Foundry基金会开发并支持，基金会包括Pivotal、IBM、VMware以及其它许多厂商。商业版本的Cloud Foundry，如IBM Bluemix和Pivotal Cloud Foundry，是基于开源的Cloud Foundry项目并在其基础上提供企业级的支持。</p><p>Cloud Foundry对容器采用了一个非常固执的方式。它使用了一个叫garden的容器解决方案。PCF的较早版本的原始容器称为warden，它事实上要早于Docker本身。</p><p>Cloud Foundry自身事实上也早于Kubernetes，它的第一个版本始于2011年，而Kubernetes直到2014年才出现。</p><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Kubernetes是一个来源于谷歌Borg项目的开源云平台。它由Cloud Native Computing Foundation发起，该基金会的成员包括了许多行业巨头，如AWS、Azure、Intel、IBM、RedHat、Pivotal等许多公司。</p><p>Cloud Foundry最重要的特点是，它是一个PaaS。Kubernetes则不太像PaaS，有些人把它看做IaaS+ ，甚至Kubernetes 的文档也把自己描述为“不是传统的、包罗万象的PaaS”。</p><p>Kubernetes首要的功能是一个容器编排和容器生命周期的管理。尽管不限于此，但它通常是被用来运行Docker容器，它的受众人群更广泛一些，比如想要构建在容器服务之上的应用和服务开发人员。有一些解决方案基于Kubernetes提供了PaaS体验，比如IBM的Container Service和RedHat的OpenShift等。</p><h2 id="Cloud-Foundry的优势在于"><a href="#Cloud-Foundry的优势在于" class="headerlink" title="Cloud Foundry的优势在于"></a>Cloud Foundry的优势在于</h2><ol><li>成熟的身份验证系统UAA，用户组和multi-tenancy的支持</li><li>方便快捷的cf push</li><li>自带负载均衡Router</li><li>强大的日志和metrics整合</li><li>成熟的部署工具BOSH</li></ol><h2 id="Kubernetes的优势在于"><a href="#Kubernetes的优势在于" class="headerlink" title="Kubernetes的优势在于"></a>Kubernetes的优势在于</h2><ol><li>大量社区和第三方支持，提供强大的扩展性</li><li>完善的容器生命周期和自动伸缩管理</li><li>方便快捷的容器化应用部署</li><li>良好、多样的持久层支持</li><li>多种开源UI支持</li></ol><h2 id="Cloud-Foundry和Kubernetes相似点"><a href="#Cloud-Foundry和Kubernetes相似点" class="headerlink" title="Cloud Foundry和Kubernetes相似点"></a>Cloud Foundry和Kubernetes相似点</h2><p>两者都使用容器的思想来隔离应用和系统其它组件。<br>两者都可以既运行在公有云（AWS、Azure、GCP）上，也可以运行在预置型云平台，如使用Vmware vsphere的云平台上。<br>两者都提供了混合环境上的运行能力，允许你在不同的云平台运行应用以提高可用性，甚至支持应用在公有云和私有云上同时运行。<br>Pivotal Cloud Foundry的最新版本也开始支持Kubernetes作为通用的容器运行时。</p><h2 id="CloudFoundry和Kubernetes使用"><a href="#CloudFoundry和Kubernetes使用" class="headerlink" title="CloudFoundry和Kubernetes使用"></a>CloudFoundry和Kubernetes使用</h2><p>使用Docker，你需要定义一个Dockerfile以支持运行基于Java的应用。你可以用各种不同方式来定义这个容器。你可以选择不同的基础操作系统，不同服务商提供的不同JDK版本，你可以暴露不同的端口，以支持不同安全级别上的访问。没有一个标准说基于Java的Spring Boot应用该长什么样。</p><p>在Cloud Foundry，所有基于Java的应用都有一个基线buildpack，这个buildpack是由供应商提供的。一个buildpack是针对给定语言创建应用运行时的模板。buildpack是由Cloud Foundry自身管理的。</p><p>Cloud Foundry把定义容器的部分工作从开发者手上接了过来。它定了一个标准，基于Java的容器应该长什么样，这样所有开发者，不管是DevOps团队还是IT专家，都可以同步这个模板。你可以确信你的容器将和其他开发者提供的容器一样运行，不管在现有的集群内，还是将来有可能转到的公有云平台上。</p><h2 id="OpenShift和CloudFoundry比较"><a href="#OpenShift和CloudFoundry比较" class="headerlink" title="OpenShift和CloudFoundry比较"></a>OpenShift和CloudFoundry比较</h2><p>具体未来谁流行现在很难说清楚，从现在热度来看红帽子在云方面的力量还是弱于Vmware的，CloudFoundry应该会更加流行。两者关键区别：<br>1.语言方面：基本相同，都支持java，Pythone,php,perl,ruby等。CF多支持Elang<br>2.关系数据库：都支持mysql和PostgreSql<br>3.NoSQL:都支持MongoDB，CF多支持Redis，Neo4j，分布式缓存memcacheD</p><h2 id="CloudFoundry和Kubernetes结合"><a href="#CloudFoundry和Kubernetes结合" class="headerlink" title="CloudFoundry和Kubernetes结合"></a>CloudFoundry和Kubernetes结合</h2><h4 id="Kubernetes-CPI"><a href="#Kubernetes-CPI" class="headerlink" title="Kubernetes CPI"></a>Kubernetes CPI</h4><p>我们知道BOSH是Cloud Foundry官方指定的部署工具，它是一个针对大规模分布式系统的部署和生命周期管理的开源工具。但是BOSH不仅仅局限于部署Cloud Foundry，也可以应用于别的分布式系统，只需要其提供符合要求的Release即可。CPI全称Cloud Provider Interface，是BOSH用来与IaaS通信完成虚拟机实例和模板的创建和管理的一个API接口，CPI目前能够支持Amazon的AWS、微软的Azure、IBM的SoftLayer等IaaS平台，国内阿里云也提供了CPI的支持。BOSH的主控制器Director通过CPI与底层的IaaS层交互，将BOSH manifest.yaml 文件定义任务及组件部署到IaaS层的VM上。</p><p>也就是开发一套Kubernetes的CPI，通过BOSH和manifest.yaml的配置将Cloud Foundry部署到Kubernetes上。现在有一些大的厂商如IBM、SAP在开发相应的Kubernetes CPI，大家可以在GitHub中搜索到。我个人觉得，这种方式虽然容易上手，但还是以IaaS的角度来看待Kubernetes，底层还是通过BOSH来管理的，没能最大地发挥Kubernetes平台的优势的。</p><h4 id="Cloud-Foundry-Container-Runtime（CFCR）"><a href="#Cloud-Foundry-Container-Runtime（CFCR）" class="headerlink" title="Cloud Foundry Container Runtime（CFCR）"></a>Cloud Foundry Container Runtime（CFCR）</h4><p>Cloud Foundry基金会在2017年底宣布把Pivotal和谷歌捐献的Kubo项目改名为CFCR（Cloud Foundry Container Runtime）。总体来说是利用BOSH来部署Cloud Foundry和Kubernetes，并通过Application Runtime管理Cloud Foundry的Application Service；通过Container Runtime管理Kubernetes的Container Service，比如一些无法部署在Cloud Foundry内的服务，如数据库、监控等。然后通过Open Service Broker将两者连接起来</p><h4 id="容器化Cloud-Foundry"><a href="#容器化Cloud-Foundry" class="headerlink" title="容器化Cloud Foundry"></a>容器化Cloud Foundry</h4><p>将Cloud Foundry所有组件容器化，并部署到Kubernetes上是一种比较新型的整合方式。现在有一些大的厂商做这方面的工作，比如SUSE、IBM和SAP。其核心就是通过将Cloud Foundry的BOSH Release转化成Docker镜像，然后通过Kubernetes的部署工具Helm来将Cloud Foundry更加自然地部署到Kubernetes上。只有在生成Cloud Foundry组件的Docker镜像是需要用到BOSH Cli去转化BOSH release，部署及部署之后的管理，都不需要BOSH，而是交给Kubernetes来对所有Cloud Foundry组件的Pod、服务及相应配置资源的生命周期进行管理。这样既享受到了Cloud Foundry带来的良好的开发者体验，又用到了Kubernetes强大的管理和扩展能力</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然两者结合的探索工作不止于此，现在越来越多的厂商和开发者加入到两者整合的研究中。其中比较火的有IBM主导的Cloud Foundry孵化项目Eirini，其想法是想将Cloud Foundry中的Diego-cell容器Garden替换成Kubernetes的容器，从而将两者更紧密地连接在一起。</p><p>Kubernetes之于Cloud Foundry的关系不是挑战也不是竞争关系，Cloud Foundry希望与其更好地融合，就像Cloud Foundry Foundation执行董事Abby Kearns说的：“Cloud Foundry是结构化的PaaS平台，其他平台是非结构化的，用户的需求是多元化的，并不是一定要如何容器化，而是希望平台能够更开放、支持更多的类型。”</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_30154571/article/details/84955097">Cloud Foundry和 Kubernetes 的区别</a></p><p><a href="http://dockone.io/article/8295">Cloud Foundry和Kubernetes结合的过去与未来</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
            <tag> CloudFoundry </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> OpenShift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之Spring重试机制</title>
      <link href="2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
      <url>2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/ybyn/">一步一年</a></p><p>出处：<a href="https://www.cnblogs.com/ybyn/p/13691058.html">https://www.cnblogs.com/ybyn/p/13691058.html</a></p><p>消费端在处理消息过程中可能会报错，此时该如何重新处理消息呢？解决方案有以下两种。</p><blockquote><ul><li>在redis或者数据库中记录重试次数，达到最大重试次数以后消息进入死信队列或者其他队列，再单独针对这些消息进行处理；</li><li>使用spring-rabbit中自带的retry功能；</li></ul></blockquote><p>第一种方案我们就不再详细说了，我们主要来看一下第二种方案，老规矩，先上代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span>  <span class="comment"># 自动ack</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">max-interval:</span> <span class="number">10000</span>   <span class="comment"># 重试最大间隔时间</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">2000</span>  <span class="comment"># 重试初始间隔时间</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">2</span> <span class="comment"># 间隔时间乘子，间隔时间*乘子=下一次的间隔时间，最大不能超过设置的最大间隔时间</span></span><br></pre></td></tr></table></figure><p>此时我们的消费者代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;platform.queue-name&#125;&quot;&#125;,concurrency = &quot;1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgConsumer</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;接收到消息&gt;&gt;&gt;&#123;&#125;&quot;</span>,msg);</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">log.info(<span class="string">&quot;消息&#123;&#125;消费成功&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动程序，发送消息后可以看到控制台输出内容如下：</p><p><img src="/2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142316393-1426680370.png" alt="img"></p><p>可以看到重试次数是5次（包含自身消费的一次），重试时间依次是2s，4s，8s，10s（上一次间隔时间*间隔时间乘子），最后一次重试时间理论上是16s，但是由于设置了最大间隔时间是10s，因此最后一次间隔时间只能是10s，和配置相符合。</p><blockquote><p>注意：</p><p>重试并不是RabbitMQ重新发送了消息，仅仅是消费者内部进行的重试，换句话说就是重试跟mq没有任何关系；</p><p>因此上述消费者代码不能添加try{}catch(){}，一旦捕获了异常，在自动ack模式下，就相当于消息正确处理了，消息直接被确认掉了，不会触发重试的；</p></blockquote><h2 id="MessageReCoverer"><a href="#MessageReCoverer" class="headerlink" title="MessageReCoverer"></a>MessageReCoverer</h2><p>上面的例子在测试中我们还发现了一个问题，就是经过5次重试以后，控制台输出了一个异常的堆栈日志，然后队列中的数据也被ack掉了（自动ack模式），首先我们看一下这个异常日志是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.amqp.rabbit.listener.exception.ListenerExecutionFailedException: Retry Policy Exhausted</span><br></pre></td></tr></table></figure><p>出现消息被消费掉并且出现上述异常的原因是因为在构建SimpleRabbitListenerContainerFactoryConfigurer类时使用了MessageRecoverer接口，这个接口有一个cover方法，用来实现重试完成之后对消息的处理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListenerRetry retryConfig = configuration.getRetry();</span><br><span class="line"><span class="keyword">if</span> (retryConfig.isEnabled()) &#123;</span><br><span class="line">RetryInterceptorBuilder&lt;?, ?&gt; builder = (retryConfig.isStateless()) ? RetryInterceptorBuilder.stateless()</span><br><span class="line">: RetryInterceptorBuilder.stateful();</span><br><span class="line">RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplateFactory(<span class="keyword">this</span>.retryTemplateCustomizers)</span><br><span class="line">.createRetryTemplate(retryConfig, RabbitRetryTemplateCustomizer.Target.LISTENER);</span><br><span class="line">builder.retryOperations(retryTemplate);</span><br><span class="line">MessageRecoverer recoverer = (<span class="keyword">this</span>.messageRecoverer != <span class="keyword">null</span>) ? <span class="keyword">this</span>.messageRecoverer</span><br><span class="line">: <span class="keyword">new</span> RejectAndDontRequeueRecoverer(); <span class="comment">//&lt;1&gt;</span></span><br><span class="line">builder.recoverer(recoverer);</span><br><span class="line">factory.setAdviceChain(builder.build());</span><br></pre></td></tr></table></figure><p>注意看&lt;1&gt;处的代码，默认使用的是RejectAndDontRequeueRecoverer实现类，根据实现类的名字我们就可以看出来该实现类的作用就是拒绝并且不会将消息重新发回队列，我们可以看一下这个实现类的具体内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectAndDontRequeueRecoverer</span> <span class="keyword">implements</span> <span class="title">MessageRecoverer</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Log logger = LogFactory.getLog(RejectAndDontRequeueRecoverer.class); <span class="comment">// NOSONAR protected</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(Message message, Throwable cause)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(<span class="string">&quot;Retries exhausted for message &quot;</span> + message, cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(<span class="string">&quot;Retry Policy Exhausted&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> AmqpRejectAndDontRequeueException(cause), message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源码给出了异常的来源，但是未看到拒绝消息的代码，猜测应该是使用aop的方式实现的，此处不再继续深究。</p><p>MessageRecoverer接口还有另外两个实现类，分别是<strong>RepublishMessageRecoverer</strong>和<strong>ImmediateRequeueMessageRecoverer</strong>，顾名思义就是重新发布消息和立即重新返回队列，下面我们分别测试一个这两个实现类：</p><h3 id="RepublishMessageRecoverer"><a href="#RepublishMessageRecoverer" class="headerlink" title="RepublishMessageRecoverer"></a>RepublishMessageRecoverer</h3><p>先创建一个异常交换机和异常队列，并将两者进行绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">errorExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;error-exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">errorQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;error-queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorExchange)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorExchange).with(<span class="string">&quot;error-routing-key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建RepublishMessageRecoverer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">messageRecoverer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RepublishMessageRecoverer(rabbitTemplate,<span class="string">&quot;error-exchange&quot;</span>,<span class="string">&quot;error-routing-key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动服务，查看处理结果：</p><p><a href="https://img2020.cnblogs.com/blog/2159277/202009/2159277-20200918142342030-85649685.png"><img src="https://img2020.cnblogs.com/blog/2159277/202009/2159277-20200918142342030-85649685.png" alt="img"></a></p><p>通过控制台可以看到，消息重试5次以后直接以新的routingKey发送到了配置的交换机中，此时再查看监控页面，可以看原始队列中已经没有消息了，但是配置的异常队列中存在一条消息。</p><p><img src="/2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142352326-326808881.png" alt="img"></p><p>再测试一下ImmediateRequeueMessageRecoverer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">messageRecoverer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ImmediateRequeueMessageRecoverer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142500644-1269082311.png" alt="img"></p><p>重试5次之后，返回队列，然后再重试5次，周而复始直到不抛出异常为止，这样还是会影响后续的消息消费。</p><blockquote><p>总结：</p><p>通过上面的测试，对于重试之后仍然异常的消息，可以采用RepublishMessageRecoverer，将消息发送到其他的队列中，再专门针对新的队列进行处理。</p></blockquote><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>除了可以采用上述RepublishMessageRecoverer，还可以采用死信队列的方式处理重试失败的消息。</p><p>首先创建死信交换机、死信队列以及两者的绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">dlxExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(dlxExchangeName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">dlxQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(dlxQueueName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列绑定死信交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dlxQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dlxExchange</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">dlcBinding</span><span class="params">(Queue dlxQueue, DirectExchange dlxExchange)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(dlxQueue).to(dlxExchange).with(dlxRoutingKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务队列的创建需要做一些修改，添加死信交换机以及死信路由键的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">Map&lt;String,Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,dlxExchangeName);<span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,dlxRoutingKey);<span class="comment">//声明当前队列的死信路由键</span></span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(queueName).withArguments(params).build();</span><br><span class="line">    <span class="comment">//return new Queue(queueName,true);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动服务，可以看到同时创建了业务队列以及死信队列</p><p><img src="/2020/12/10/RabbitMQ%E4%B9%8BSpring%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/2159277-20200918142520353-1806232438.png" alt="img"></p><p>在业务队列上出现了DLX以及DLK的标识，标识已经绑定了死信交换机以及死信路由键，此时调用生产者发送消息，消费者在重试5次后，由于MessageCover默认的实现类是RejectAndDontRequeueRecoverer，也就是requeue=false，又因为业务队列绑定了死信队列，因此消息会从业务队列中删除，同时发送到死信队列中。</p><blockquote><p>注意：</p><p>如果ack模式是手动ack，那么需要调用channe.nack方法，同时设置requeue=false才会将异常消息发送到死信队列中</p></blockquote><h2 id="retry使用场景"><a href="#retry使用场景" class="headerlink" title="retry使用场景"></a>retry使用场景</h2><p>上面说了什么是重试，以及如何解决重试造成的数据丢失，那么怎么来选择重试的使用场景呢？</p><p>是否是消费者只要发生异常就要去重试呢？其实不然，假设下面的两个场景：</p><ul><li>http下载视频或者图片或者调用第三方接口</li><li>空指针异常或者类型转换异常（其他的受检查的运行时异常）</li></ul><p>很显然，第一种情况有重试的意义，第二种没有。</p><p>对于第一种情况，由于网络波动等原因造成请求失败，重试是有意义的；</p><p>对于第二种情况，需要修改代码才能解决的问题，重试也没有意义，需要的是记录日志以及人工处理或者轮询任务的方式去处理。</p><h2 id="retry最佳实践"><a href="#retry最佳实践" class="headerlink" title="retry最佳实践"></a>retry最佳实践</h2><p>对于消费端异常的消息，如果在有限次重试过程中消费成功是最好的，如果有限次重试之后仍然失败的消息，不管是采用RejectAndDontRequeueRecoverer还是使用私信队列都是可以的，同时也可以采用折中的方法，先将消息从业务队列中ack掉，再将消息发送到另外的一个队列中，后续再单独处理异常数据的队列。</p><p>另外，看到有人说retry只能在自动ack模式下使用，经过测试在手动ack模式下retry也是生效的，只不过不能使用catch捕获异常，即使在自动ack模式下使用catch捕获异常也是会导致不触发重试的。当然，在手动ackm模式下要记得确认消息，不管是确认消费成功还是确认消费失败，不然消息会一直处于unack状态，直到消费者进程重启或者停止。</p><p>如果一定要在手动ack模式下使用retry功能，最好还是确认在有限次重试过程中可以重试成功，否则超过重试次数，又没办法执行nack，就会出现消息一直处于unack的问题，我想这也就是所说的retry只能在自动ack模式下使用的原因，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;platform.queue-name&#125;&quot;&#125;,concurrency = &quot;1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgConsumer</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;接收到消息&gt;&gt;&gt;&#123;&#125;&quot;</span>,msg);</span><br><span class="line"><span class="keyword">if</span>(msg.indexOf(<span class="string">&quot;0&quot;</span>)&gt;-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">&quot;消息&#123;&#125;消费成功&quot;</span>,msg);</span><br><span class="line">channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之死信队列</title>
      <link href="2020/12/09/RabbitMQ%E4%B9%8B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
      <url>2020/12/09/RabbitMQ%E4%B9%8B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="死信交换机，死信队列"><a href="#死信交换机，死信队列" class="headerlink" title="死信交换机，死信队列"></a>死信交换机，死信队列</h2><p>DLX 全称（Dead-Letter-Exchange）,称之为死信交换器，当消息变成一个<strong>死信</strong>之后，如果这个消息所在的队列存在<strong>x-dead-letter-exchange</strong>参数，那么它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，与这个死信交换器绑定的队列就是死信队列。</p><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p>在RabbitMQ中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。</p><h2 id="死信消息"><a href="#死信消息" class="headerlink" title="死信消息"></a><strong>死信消息</strong></h2><ol><li>消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false</li><li>消息过期了</li><li>队列达到最大的长度(x-max-length)</li></ol><h2 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h2><ol><li>创建队列的时候绑定死信参数：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx-exchange&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlK-routingKey&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Queue(queue, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params); <span class="comment">//若不存在应该是会创建Queue</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>设置过期时间（TTL）</p><ul><li><p>设置队列中消息的过期时间（所有消息的过期时间都是一样）<strong>将消息的TTL值设置为0，意味着消息到达队列后将会立即过期不会被队列保存，除非消息能够被立即传递给消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(q_name, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map); <span class="comment">//原生jar</span></span><br></pre></td></tr></table></figure></li><li><p>设置单个消息的过期时间（可以设置每个消息的过期时间不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Spring</span></span><br><span class="line"><span class="keyword">this</span>.rabbitTemplate</span><br><span class="line">    .convertAndSend(orderStatusUpdateExchange, orderStatusUpdateKey, orderMessage, message -&gt; &#123;</span><br><span class="line">        message.getMessageProperties().setExpiration(expiration);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//原生jar</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                .expiration(<span class="string">&quot;6000&quot;</span>) <span class="comment">//设置TTL 毫秒</span></span><br><span class="line">                .build();</span><br><span class="line">channel.basicPublish(my-exchange, routing-key, properties, <span class="string">&quot;msg&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>设置队列过期（队列设置TTL过期后会被删除，但是不能保证实时被删除）该值决定了队列不再被使用后直到被自动删除的时长。<strong>不再使用的意思是队列没有订阅的消费者，队列最近没有被重新声明，并且在过期时间basic.get方法没有被调用</strong>。比如，在通过RabbitMQ实现RPC调用时，会生成大量的回复队列。<strong>服务器保证如果队列在最近的过期时间内没有被使用，那么该队列将会被删除。但是不保证在过期后能够以多快的速度删除</strong>。当服务器重启时，队列的租期重新开始计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;x-expires&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(q_name, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="死信注意点"><a href="#死信注意点" class="headerlink" title="死信注意点"></a>死信注意点</h2><blockquote><p>Caveats<br>Queues that had a per-message TTL applied to them retroactively (when they already had messages) will discard the messages when specific events occur. Only when expired messages reach the head of a queue will they actually be discarded (or dead-lettered). Consumers will not have expired messages delivered to them. Keep in mind that there can be a natural race condition between message expiration and consumer delivery, e.g. a message can expire after it was written to the socket but before it has reached a consumer.<br>When setting per-message TTL expired messages can queue up behind non-expired ones until the latter are consumed or expired. Hence resources used by such expired messages will not be freed, and they will be counted in queue statistics (e.g. the number of messages in the queue).<br>When retroactively applying a per-message TTL policy, it is recommended to have consumers online to make sure the messages are discarded quicker.<br>Given this behaviour of per-message TTL settings on existing queues, when the need to delete messages to free up resources arises, queue TTL should be used instead (or queue purging, or queue deletion).</p></blockquote><p><strong>注意事项</strong><br>当队列中已有消息，并设置消息的TTL，那么会追溯设置消息的有效期，当在特定情况下将会丢弃这些消息。**只有当过期消息到达队列的头部时，它们才会被真实地丢弃(或死信路由)**。消费者将不会接收到过期的消息，但是消息的传递和有效期有天然的竞争关系。比如，一个消息在被写入到socket但还未到达消费者时过期。</p><p>当设置了TTL过期时间的消息，可以在未过期消息后面排队，直到后者被消费或者过期。因此，被过期消息使用的资源并不会被释放，它们也会被队列的统计记入(比如，队列中消息的数量)。</p><p>当回溯地设置消息的TTL策略时，建议有消费者同时在线，可以保证消息的尽快丢弃。</p><p>考虑到给已存在的队列设置消息的TTL，来实现删除消息释放资源。设置队列的TTL（或队列清空，队列删除）应该替代这种方式</p><p><strong>测试</strong>：</p><ol><li>可以看出这次是正常发送，正常消费</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.036</span>， 消息内容：<span class="number">798</span></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.039</span>， 消息内容：<span class="number">456</span></span><br><span class="line">消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">03</span>:<span class="number">34.039</span>， 消息内容：<span class="number">123</span></span><br><span class="line">2020-07-02 15:03:35.116  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br><span class="line">2020-07-02 15:03:39.054  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:03:44.055  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>可以看出消息正常发出，但是过了10s同时被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.654</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.654</span>， 消息内容：<span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.655</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.655</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">45.655</span>  INFO <span class="number">132</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">05</span>:<span class="number">45.655</span>， 消息内容：<span class="number">798</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:05:55.665  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line">2020-07-02 15:05:55.666  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:05:55.666  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br></pre></td></tr></table></figure><ol start="3"><li>可以看出过了5秒第一次被消费，再过5秒后后两条消息同时被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.929</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.929</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.931</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.931</span>， 消息内容：<span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">26.931</span>  INFO <span class="number">11156</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">11</span>:<span class="number">26.931</span>， 消息内容：<span class="number">798</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:11:31.928  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:11:36.946  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br><span class="line">2020-07-02 15:11:36.947  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br></pre></td></tr></table></figure><ol start="4"><li>可以看出过了5秒前两条消息同时被消费，再过了5秒最后一条消息被消费</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;456&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">5</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;798&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">1</span> *<span class="number">1000</span>);</span><br><span class="line">rabbitMqSender.sendMsg(<span class="string">&quot;123&quot;</span>, RabbitMqConfig.EXCHANGE_QUESTION_EXPIRE_DL, RabbitMqConfig.ROUTINGKEY_QUESTION_EXPIRE_DL, <span class="number">10</span> *<span class="number">1000</span>);</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.818</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.818</span>， 消息内容：<span class="number">456</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.821</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.821</span>， 消息内容：<span class="number">798</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">27.821</span>  INFO <span class="number">10400</span> --- [main] com.example.demo.sender.RabbitMqSender   : 消息发送时间：<span class="number">2020</span>-<span class="number">07</span>-<span class="number">02</span>T15:<span class="number">12</span>:<span class="number">27.821</span>， 消息内容：<span class="number">123</span></span><br><span class="line"></span><br><span class="line">2020-07-02 15:12:32.834  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:456 </span><br><span class="line">2020-07-02 15:12:32.834  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:798 </span><br><span class="line">2020-07-02 15:12:37.837  INFO 15856 --- [ntContainer#0-1] c.e.demo.listener.RabbitMqReceiver : received msg:123 </span><br></pre></td></tr></table></figure><p><font color="red">可以看出应该就是只有消息队列头的消息被消费后，过期的消息才会被消费。</font></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>安装一个插件即可：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedRabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delay.queue.demo.delay.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delay.queue.demo.delay.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.delay.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">immediateQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">customExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingNotify</span><span class="params">(<span class="meta">@Qualifier(&quot;immediateQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;customExchange&quot;)</span> CustomExchange customExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息生产者的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayMsg</span><span class="params">(String msg, Integer delayTime)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, a -&gt;&#123;</span><br><span class="line">        a.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,延时队列收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/m0_37801313/article/details/107084076">RabbitMq 死信消息的过期时间的不同 会导致消费延时</a></p><p><a href="https://www.cnblogs.com/mfrank/p/11260355.html">【RabbitMQ】一文带你搞定RabbitMQ延迟队列</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之消息可靠性处理</title>
      <link href="2020/12/09/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/"/>
      <url>2020/12/09/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么做到消息不丢失（可靠性）"><a href="#怎么做到消息不丢失（可靠性）" class="headerlink" title="怎么做到消息不丢失（可靠性）"></a>怎么做到消息不丢失（可靠性）</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a><strong>持久化</strong></h3><ul><li>exchange要持久化</li><li>queue要持久化</li><li>message要持久化<h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3></li><li>生产者发送消息开启确认confirm机制：如果消息没有到达交换机,则该方法中isSuccess = false,error为错误信息; 如果消息正确到达交换机,则该方法中isSuccess = true;</li><li>生产者发送消息开启返回returnedMessage机制：消息从交换机成功到达队列，则returnedMessage方法不会执行; 消息从交换机未能成功到达队列，则returnedMessage方法会执行;</li><li>生产者发送消息开启事务，同步操作，直到入队列之后才会结束，影响性能。</li><li>消费者开启手动确认模式：只有手动确认返回，才删除队列里的数据，需要注意幂等性。</li></ul><h2 id="实现消息的失败重试"><a href="#实现消息的失败重试" class="headerlink" title="实现消息的失败重试"></a>实现消息的失败重试</h2><h4 id="生产者发送失败重试"><a href="#生产者发送失败重试" class="headerlink" title="生产者发送失败重试"></a>生产者发送失败重试</h4><p><strong>开启确认机制</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment">#旧版本已过期可以设置为：publisher-confirm-type=correlated 确认消息已发送到交换机选择确认类型为交互</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>确认机制代码处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitTemplateConfig</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>,<span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);            <span class="comment">//指定 ConfirmCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);             <span class="comment">//指定 ReturnCallback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息是否发送到了交换机，ack为结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息唯一标识：&quot;</span>+correlationData);</span><br><span class="line">        System.out.println(<span class="string">&quot;确认结果：&quot;</span>+ack);</span><br><span class="line">        System.out.println(<span class="string">&quot;失败原因：&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息未从交换机到达队列执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体 message : &quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体 message : &quot;</span>+replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;描述：&quot;</span>+replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的交换器 exchange : &quot;</span>+exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的路由键 routing : &quot;</span>+routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心逻辑在二个回调方法中</strong></p><ul><li><strong>发送消息异常</strong>，即可能没有连接上RabbitMQ，此时可以通过定时任务Job去重试</li><li><strong>确认回调确定消息发送失败</strong>，可以记录发送结果在Redis中，直接再次重新发送消息入队列</li><li><strong>总结</strong>：可以先收到回调之后自动发送记录发送次数，超过如5次之后，使用定时任务阶梯时间发送消息入队列</li></ul><h4 id="消费者处理失败重试（可阶梯延时处理或重试）"><a href="#消费者处理失败重试（可阶梯延时处理或重试）" class="headerlink" title="消费者处理失败重试（可阶梯延时处理或重试）"></a>消费者处理失败重试（可阶梯延时处理或重试）</h4><h5 id="简单重试（手动确认）"><a href="#简单重试（手动确认）" class="headerlink" title="简单重试（手动确认）"></a>简单重试（手动确认）</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">      <span class="comment">#NONE：自动确认 AUTO：根据情况确认 MANUAL：手动确认</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>AcknowledgeMode使用AUTO时，它会根据方法的执行情况来决定是否确认还是拒绝（是否重新入queue）</p><ul><li>如果消息成功被消费（成功的意思是在消费的过程中没有抛出异常），则自动确认</li><li>当抛出 AmqpRejectAndDontRequeueException 异常的时候，则消息会被拒绝，且 requeue = false（不重新入队列）</li><li>当抛出 ImmediateAcknowledgeAmqpException 异常，则消费者会被确认</li><li>其他的异常，则消息会被拒绝，且 requeue = true（如果此时只有一个消费者监听该队列，则有发生死循环的风险，多消费端也会造成资源的极大浪费，这个在开发过程中一定要避免的）。可以通过 setDefaultRequeueRejected（默认是true）去设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二种监听处理方式</span></span><br><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">    bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(exchange = @Exchange(value = &quot;$&#123;order.order-status.update.dlx.exchange&#125;&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;$&#123;order.order-status.update.dlx.key&#125;&quot;,</span></span><br><span class="line"><span class="meta">            value = @Queue(value = &quot;$&#123;order.order-status.update.dlx.queue&#125;&quot;, durable = &quot;true&quot;))&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(String message,Channel channel,<span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(tag,<span class="keyword">false</span>);            <span class="comment">// 确认消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局处理消息</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>);              <span class="comment">// 监听的队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL);        <span class="comment">// 手动确认</span></span><br><span class="line">    container.setMessageListener((ChannelAwareMessageListener) (message, channel) -&gt; &#123;      <span class="comment">//消息处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="keyword">if</span>(message.getMessageProperties().getHeaders().get(<span class="string">&quot;error&quot;</span>) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息已经确认&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);</span></span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息拒绝&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="阶梯重试（考虑幂等性）"><a href="#阶梯重试（考虑幂等性）" class="headerlink" title="阶梯重试（考虑幂等性）"></a>阶梯重试（考虑幂等性）</h5><ol><li>消息生产者将消息发送到普通队列，消费者接受到后进行处理；</li><li>若处理失败，将该消息发送到缓冲队列；</li><li>消息在队列到期后会自动的被发送到普通队列，再次消费。<br><img src="/2020/12/09/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A4%84%E7%90%86/20190113192348240.png" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ之management管理端详解</title>
      <link href="2020/12/08/RabbitMQ%E4%B9%8Bmanagement%E7%AE%A1%E7%90%86%E7%AB%AF%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/12/08/RabbitMQ%E4%B9%8Bmanagement%E7%AE%A1%E7%90%86%E7%AB%AF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.csdn.net/qq_27409289">坑里水库</a></p><p>出处：<a href="https://blog.csdn.net/qq_27409289/article/details/89510687">https://blog.csdn.net/qq_27409289/article/details/89510687</a></p><p><a href="https://link.jianshu.com/?t=https://github.com/rabbitmq/rabbitmq-management">rabbitmq-management</a>是RabbitMq web管理端，用的是erlang的cowboy框架进行开发。web页面包括Overview(概述)、Connections(连接)、Channels(通道)、Exchanges(交换器)、Queues(队列)、Admin(用户管理)</p><h2 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview(概述)"></a>Overview(概述)</h2><h3 id="overview-gt-Totals"><a href="#overview-gt-Totals" class="headerlink" title="overview-&gt;Totals"></a>overview-&gt;Totals</h3><p>Ready：待消费的消息总数。<br>Unacked：待应答的消息总数。<br>Total：总数 Ready+Unacked。</p><p>所有队列的消费情况。速率=(num1-num0)/(s1-s0) num1：s1时刻的个数。num0：s0时刻的个数。</p><p>Publish：producter pub消息的速率。<br>Publisher confirm：broker确认pub消息的速率。<br>Deliver(manual ack)：customer手动确认的速率。<br>Deliver( auto ack)：customer自动确认的速率。<br>Consumer ack：customer正在确认的速率。<br>Redelivered：正在传递’redelivered’标志集的消息的速率。<br>Get (manual ack)：响应basic.get而要求确认的消息的传输速率。<br>Get (auto ack)：响应于basic.get而发送不需要确认的消息的速率。<br>Return：将basic.return发送给producter的速率。<br>Disk read：queue从磁盘读取消息的速率。<br>Disk write：queue从磁盘写入消息的速率。</p><p>整体角色的个数</p><p>Connections：client的tcp连接的总数。<br>Channels：通道的总数。<br>Exchange：交换器的总数。<br>Queues：队列的总数。<br>Consumers：消费者的总数。</p><h3 id="Overview-gt-Nodes"><a href="#Overview-gt-Nodes" class="headerlink" title="Overview-&gt;Nodes"></a>Overview-&gt;Nodes</h3><p>broker的属性</p><p>Name：broker名称<br>File descriptors：broker打开的文件描述符和限制。<br>Socket descriptors：broker管理的网络套接字数量和限制。当限制被耗尽时，RabbitMQ将停止接受新的网络连接。<br>Erlang processes：erlang启动的进程数。<br>Memory：当前broker占用的内存。<br>Disk space：当前broker占用的硬盘。<br>Uptime：当前broker持续运行的时长。<br>Info：未知。<br>Reset stats：未知。</p><h3 id="Overview-gt-Export-definitions"><a href="#Overview-gt-Export-definitions" class="headerlink" title="Overview-&gt;Export definitions"></a>Overview-&gt;Export definitions</h3><p>定义由用户，虚拟主机，权限，参数，交换，队列和绑定组成。 它们不包括队列的内容或集群名称。 独占队列不会被导出。</p><h3 id="Overview-gt-Export-definitions-1"><a href="#Overview-gt-Export-definitions-1" class="headerlink" title="Overview-&gt;Export definitions"></a>Overview-&gt;Export definitions</h3><p>导入的定义将与当前定义合并。 如果在导入过程中发生错误，则所做的任何更改都不会回滚。</p><h2 id="Connections（当前所有客户端活动的连接。包括生成者和消费者）"><a href="#Connections（当前所有客户端活动的连接。包括生成者和消费者）" class="headerlink" title="Connections（当前所有客户端活动的连接。包括生成者和消费者）"></a>Connections（当前所有客户端活动的连接。包括生成者和消费者）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>User name：使用的用户名。<br>State：当前的状态，running：运行中；idle：空闲。<br>SSL/TLS：是否使用ssl进行连接。<br>Protocol：使用的协议。<br>Channels：创建的channel的总数。<br>From client：每秒发出的数据包。<br>To client：每秒收到的数据包。</p><h2 id="Channels（当前连接所有创建的通道）"><a href="#Channels（当前连接所有创建的通道）" class="headerlink" title="Channels（当前连接所有创建的通道）"></a>Channels（当前连接所有创建的通道）</h2><p>channel：名称。<br>Virtual host：所属的虚拟主机。<br>User name：使用的用户名。<br>Mode：渠道保证模式。 可以是以下之一，或者不是：C: confirm。T：transactional(事务)。<br>State ：当前的状态，running：运行中；idle：空闲。<br>Unconfirmed：待confirm的消息总数。<br>Prefetch：设置的prefetch的个数。<br>Unacker：待ack的消息总数。<br>publish：producter pub消息的速率。<br>confirm：producter confirm消息的速率。<br>deliver/get：consumer 获取消息的速率。<br>ack：consumer ack消息的速率。</p><h2 id="Exchanges（交换器属性）"><a href="#Exchanges（交换器属性）" class="headerlink" title="Exchanges（交换器属性）"></a>Exchanges（交换器属性）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>Type：exchange type，具体的type可以查看<a href="https://www.jianshu.com/p/5319b06f2e80">RabbitMq系列之一：基础概念</a>。<br>Features：功能。 可以是以下之一，或者不是：D: 持久化。T：Internal，存在改功能表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定，否则可以推送消息也可以绑定。<br>Message rate in：消息进入的速率。<br>Message rate out：消息出去的速率。</p><h2 id="Queues（队列的属性）"><a href="#Queues（队列的属性）" class="headerlink" title="Queues（队列的属性）"></a>Queues（队列的属性）</h2><p>Virtual host：所属的虚拟主机。<br>Name：名称。<br>Features：功能。 可以是以下之一，或者不是：D: 持久化。<br>State：当前的状态，running：运行中；idle：空闲。<br>Ready：待消费的消息总数。<br>Unacked：待应答的消息总数。<br>Total：总数 Ready+Unacked。<br>incoming：消息进入的速率。<br>deliver/get：消息获取的速率。<br>ack：消息应答的速率。</p><h2 id="Admin（用户属性）"><a href="#Admin（用户属性）" class="headerlink" title="Admin（用户属性）"></a>Admin（用户属性）</h2><p>Name：名称。<br>Tags：角色标签，只能选取一个。<br>Can access virtual hosts：允许进入的vhost。<br>Has password：设置了密码。</p><p>tags(原链接:<a href="https://link.jianshu.com/?t=https://www.cnblogs.com/java-zhao/p/5670476.html">https://www.cnblogs.com/java-zhao/p/5670476.html</a>)</p><ul><li>administrator (超级管理员)<br>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li><li>monitoring(监控者)<br>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li>policymaker(策略制定者)<br>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。</li><li>management(普通管理者)<br>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</li><li>none(其他)<br>无法登陆管理控制台，通常就是普通的生产者和消费者。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（九）之堆排序</title>
      <link href="2020/12/08/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2020/12/08/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>借助于二叉堆。使用二叉堆还实现了优先级队列，出队列的永远是最大优先级的数据即删除节点，入队列上浮即插入节点。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ol><li>把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。 </li><li>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。</li></ol><p>第1步，把无序数组构建成二叉堆，这一步的时间复杂度是O(n)。<br>第2步，需要进行n-1次循环。每次循环调用一次downAdjust方法，所以第2步的计算规模是 (n-1)×logn ，时间复杂度为O(nlogn)。<br>两个步骤是并列关系，所以整体的时间复杂度是O(nlogn)。</p><h2 id="堆排序和快速排序区别"><a href="#堆排序和快速排序区别" class="headerlink" title="堆排序和快速排序区别"></a>堆排序和快速排序区别</h2><p>相同点，堆排序和快速排序的平均时间复杂度都是O(nlogn)，并且都是不稳定排序。至于不同点，快速排序的最坏时间复杂度是O(n2)，而堆排序的最坏时间复杂度稳定在O(nlogn)。 </p><p>快速排序递归和非递归方法的平均空间复杂度都是O(logn)，而堆排序的空间复杂度是O(1)。 </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array       待调整的堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex 要“下沉”的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length      堆的有效大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">  <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">  <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">    <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">      childIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果父节点大于任何一个孩子的值，则直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">    array[parentIndex] = array[childIndex];</span><br><span class="line">    parentIndex = childIndex;</span><br><span class="line">    childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序（升序） * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 把无序数组构建成最大堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    downAdjust(array, i, array.length);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(Arrays.toString(array));</span><br><span class="line">  <span class="comment">// 循环删除堆顶元素，移到集合尾部，调整堆产生新的堆顶</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 最后1个元素和第1个元素进行交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[<span class="number">0</span>];</span><br><span class="line">    array[<span class="number">0</span>] = temp;</span><br><span class="line">    <span class="comment">// “下沉”调整最大堆</span></span><br><span class="line">    downAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  heapSort(arr);</span><br><span class="line">  System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-MVC原理</title>
      <link href="2020/12/07/Spring-MVC%E5%8E%9F%E7%90%86/"/>
      <url>2020/12/07/Spring-MVC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux发送http请求</title>
      <link href="2020/12/04/Linux%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/"/>
      <url>2020/12/04/Linux%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/kaleidoscope/">kaleidoscopic</a></p><p>出处：<a href="https://www.cnblogs.com/kaleidoscope/p/9719841.html">https://www.cnblogs.com/kaleidoscope/p/9719841.html</a></p><h2 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h2><h3 id="curl命令模拟Get请求："><a href="#curl命令模拟Get请求：" class="headerlink" title="curl命令模拟Get请求："></a>curl命令模拟Get请求：</h3><p>1、使用curl命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://www.baidu.com&quot;     如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span><br><span class="line">curl -i &quot;http://www.baidu.com&quot;  显示全部信息</span><br><span class="line">curl -I &quot;http://www.baidu.com&quot;  只显示头部信息</span><br><span class="line">curl -v &quot;http://www.baidu.com&quot;  显示get请求全过程解析</span><br></pre></td></tr></table></figure><p>2、使用wget命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;http://www.baidu.com&quot;</span><br></pre></td></tr></table></figure><h3 id="curl命令模拟Get请求携带参数（linux）："><a href="#curl命令模拟Get请求携带参数（linux）：" class="headerlink" title="curl命令模拟Get请求携带参数（linux）："></a>curl命令模拟Get请求携带参数（linux）：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com</span><br></pre></td></tr></table></figure><p>上述命令在linux系统，get请求携带的参数只到version=1，”&amp;”符号在linux系统中为后台运行的操作符，此处需要使用反斜杠”\”转义，即：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://127.0.0.1:80/xcloud/test?version=1\&amp;client_version=1.1.0\&amp;seq=1001\&amp;host=aaa.com</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;http://127.0.0.1:80/xcloud/test?version=1&amp;client_version=1.1.0&amp;seq=1001&amp;host=aaa.com&quot;</span><br></pre></td></tr></table></figure><h2 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h2><p>1、使用curl命令，通过-d参数，把访问参数放在里面，如果没有参数，则不需要-d，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;username=user1&amp;password=123&quot; &quot;www.test.com/login&quot;</span><br></pre></td></tr></table></figure><p>2、使用wget命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget –post-data &#x27;username=user1&amp;password=123&#x27; http://www.baidu.com</span><br></pre></td></tr></table></figure><p>3、发送格式化json请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -k -H &quot;Content-type: application/json&quot; -X POST -d &#x27;&#123;&quot;version&quot;:&quot;6.6.0&quot;, &quot;from&quot;:&quot;mu&quot;, &quot;product_version&quot;:&quot;1.1.1.0&quot;&#125;&#x27; https://10.10.10.10:80/test</span><br></pre></td></tr></table></figure><h2 id="curl和wget区别"><a href="#curl和wget区别" class="headerlink" title="curl和wget区别"></a>curl和wget区别</h2><p>curl模拟的访问请求一般直接在控制台显示，而wget则把结果保存为一个文件。如果结果内容比较少，需要直接看到结果可以考虑使用curl进行模拟请求，如果返回结果比较多，则可考虑wget进行模拟请求。</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（八）之快速排序</title>
      <link href="2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快排原理"><a href="#快排原理" class="headerlink" title="快排原理"></a>快排原理</h2><ol><li>随机选择一个元素作为基准元素（pivot），并且让基准元素和数列首元素交换位置。解决最大值或最小值本身就是第一个元素，退化成O(n^2^)。</li><li>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。</li></ol><p>虽然快速排序的平均时间复杂度是O(nlogn)，但最坏情况下的时间复杂度是O(n^2^)。</p><h2 id="元素的交换"><a href="#元素的交换" class="headerlink" title="元素的交换"></a>元素的交换</h2><ul><li>双边循环法。</li><li>单边循环法</li></ul><h4 id="双边循环法"><a href="#双边循环法" class="headerlink" title="双边循环法"></a>双边循环法</h4><p><strong>原则</strong>：</p><ol><li>选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。<img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207112907329.png" alt="image-20201207112907329" style="zoom: 50%;"></li><li>从right指针开始，让指针所指向的元素和基准元素做比较。如果大于或等于pivot，则指针向左移动；如果小于pivot，则right指针停止移动，切换到left指针。 <img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207132506437.png" alt="image-20201207132506437" style="zoom:50%;"></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex&gt;=endIndex)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition(arrays, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort(arrays,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">    quickSort(arrays,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arrays[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line">    <span class="keyword">while</span> (left!=right)&#123;</span><br><span class="line">      <span class="comment">//控制right 指针比较并左移</span></span><br><span class="line">      <span class="keyword">while</span> (left&lt;right &amp;&amp; arrays[right]&gt;pivot)&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">      <span class="keyword">while</span> (left&lt;right &amp;&amp; arrays[left]&lt;=pivot)&#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//交换left和right 指针所指向的元素</span></span><br><span class="line">      <span class="keyword">if</span>(right&gt;left)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arrays[right];</span><br><span class="line">        arrays[right] = arrays[left];</span><br><span class="line">        arrays[left] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pivot 和指针重合点交换</span></span><br><span class="line">    arrays[startIndex] = arrays[left];</span><br><span class="line">    arrays[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="单边循环法"><a href="#单边循环法" class="headerlink" title="单边循环法"></a>单边循环法</h4><p><strong>原理</strong>：</p><ol><li>首先选定基准元素pivot。同时，设置一个mark指针指向数列起始位置，这个mark指针代表小于基准元素的区域边界<img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207135733083.png" alt="image-20201207135733083" style="zoom:50%;"></li><li>如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1；第二，让最新遍历到的元素和mark指针所 在位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。 <img src="/2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20201207135924557.png" alt="image-20201207135924557" style="zoom:50%;"></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex&gt;=endIndex)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> partition = partition2(arrays, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort2(arrays,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">    quickSort2(arrays,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span> []arrays ,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arrays[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= startIndex+<span class="number">1</span>;i&lt;=endIndex;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrays[i]&lt; pivot)&#123;</span><br><span class="line">        mark++;</span><br><span class="line">        <span class="keyword">int</span> temp = arrays[mark];</span><br><span class="line">        arrays[mark] = arrays[i];</span><br><span class="line">        arrays[i] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arrays[startIndex] = arrays[mark];</span><br><span class="line">    arrays[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用一个集合栈来代替递归的函数栈 </span></span><br><span class="line">  Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">  <span class="comment">// 整个数列的起止下标，以哈希的形式入栈 </span></span><br><span class="line">  Map rootParam = <span class="keyword">new</span> HashMap();</span><br><span class="line">  rootParam.put(<span class="string">&quot;startIndex&quot;</span>, startIndex);</span><br><span class="line">  rootParam.put(<span class="string">&quot;endIndex&quot;</span>, endIndex);</span><br><span class="line">  quickSortStack.push(rootParam);</span><br><span class="line">  <span class="comment">// 循环结束条件：栈为空时 </span></span><br><span class="line">  <span class="keyword">while</span> (!quickSortStack.isEmpty()) &#123; </span><br><span class="line">    <span class="comment">// 栈顶元素出栈，得到起止下标 </span></span><br><span class="line">    Map&lt;String, Integer&gt; param = quickSortStack.pop(); </span><br><span class="line">    <span class="comment">// 得到基准元素位置 </span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, param.get(<span class="string">&quot;startIndex&quot;</span>), param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">    <span class="comment">// 根据基准元素分成两部分, 把每一部分的起止下标入栈 </span></span><br><span class="line">    <span class="keyword">if</span> (param.get(<span class="string">&quot;startIndex&quot;</span>) &lt; pivotIndex - <span class="number">1</span>) &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">      leftParam.put(<span class="string">&quot;startIndex&quot;</span>, param.get(<span class="string">&quot;startIndex&quot;</span>));</span><br><span class="line">      leftParam.put(<span class="string">&quot;endIndex&quot;</span>, pivotIndex - <span class="number">1</span>);</span><br><span class="line">      quickSortStack.push(leftParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pivotIndex + <span class="number">1</span> &lt; param.get(<span class="string">&quot;endIndex&quot;</span>)) &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">      rightParam.put(<span class="string">&quot;startIndex&quot;</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">      rightParam.put(<span class="string">&quot;endIndex&quot;</span>, param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">      quickSortStack.push(rightParam);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（七）之排序算法</title>
      <link href="2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2020/12/04/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法时间复杂度对比"><a href="#排序算法时间复杂度对比" class="headerlink" title="排序算法时间复杂度对比"></a>排序算法时间复杂度对比</h2><table><thead><tr><th>排序算法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2^)</td></tr><tr><td>选择排序</td><td>O(n^2^)</td></tr><tr><td>插入排序</td><td>O(n^2^)</td></tr><tr><td>希尔排序</td><td>性能略优于O(n^2^),但又比不上O(nlog<del>2</del>n)</td></tr><tr><td>快速排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>归并排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>堆排序</td><td>O(nlog<del>2</del>n)</td></tr><tr><td>计数排序</td><td>O(n)</td></tr><tr><td>桶排序</td><td>O(n)</td></tr><tr><td>基数排序</td><td>O(n)</td></tr></tbody></table><h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环次数，要做多少次比较，找到最大值，找到第二大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//标记是否已排序完成</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//真实比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          <span class="comment">//值进行交互则说明排序未完成</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 更新为最后一次交换元素的位置</span></span><br><span class="line">          lastExchangeIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortBorder = lastExchangeIndex;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    bubbleSort2(array);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>排序过程就像钟摆一样，第1轮从左到右，第2轮从右到左，第3轮再从左到右……</p><p>在大部分元素已经有序的情况下能发挥优势，减少排序的回合数；代码量几乎增加了1倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">      <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">          array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 有元素交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在偶数轮之前，将isSorted重新标记为true</span></span><br><span class="line">      isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 偶数轮，从右向左比较和交换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length - i - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          tmp = array[j];</span><br><span class="line">          array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">          array[j - <span class="number">1</span>] = tmp;</span><br><span class="line">          <span class="comment">// 因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一轮：从左到右，先从2开始比较，找到最大值</span></span><br><span class="line">    <span class="comment">//第二轮：从右到左，从8开始比较，找到最小值</span></span><br><span class="line">    <span class="comment">//之后轮询继续比较</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（六）之二叉堆实现优先级队列</title>
      <link href="2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的特点是先进先出（FIFO）。 </p><ul><li>入队列，将新元素置于队尾。</li><li>出队列，队头元素最先被移出。</li></ul><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列不再遵循先入先出的原则，而是分为两种情况。</p><ul><li>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 </li><li>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队 </li></ul><h2 id="优先队列实现"><a href="#优先队列实现" class="headerlink" title="优先队列实现"></a>优先队列实现</h2><p>利用线性数据结构并非不能实现，但是时间复杂度较高。因此可以利用二叉堆的特性来实现优先队列。最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。</p><p><strong>二叉堆的特性</strong>：</p><ul><li><p>最大堆的堆顶是整个堆中的最大元素。 </p></li><li><p>最小堆的堆顶是整个堆中的最小元素。 </p></li></ul><p><strong>二叉堆的时间复杂度</strong>：</p><p>插入和删除操作都是O(logn)，构建二叉堆的时间复杂度为O(n)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列初始长度为</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队 * <span class="doctag">@param</span> key 入队元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列长度超出范围，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= array.length) &#123;</span><br><span class="line">      resize();</span><br><span class="line">    &#125;</span><br><span class="line">    array[size++] = key;</span><br><span class="line">    upAdjust();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;the queue is empty !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取堆顶元素</span></span><br><span class="line">    <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 让最后一个元素移动到堆顶</span></span><br><span class="line">    array[<span class="number">0</span>] = array[--size];</span><br><span class="line">    downAdjust();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “上浮”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex]) &#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childIndex] = array[parentIndex];</span><br><span class="line">      childIndex = parentIndex;</span><br><span class="line">      parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * “下沉”调整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp 保存父节点的值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">        childIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点大于任何一个孩子的值，直接跳出</span></span><br><span class="line">      <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childIndex];</span><br><span class="line">      parentIndex = childIndex;</span><br><span class="line">      childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 队列扩容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列容量翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">    priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">    System.out.println(<span class="string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（五）之二叉堆</title>
      <link href="2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
      <url>2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆本质上是一种完全二叉树，它分为两个类型。 </p><ol><li><p>最大堆。 最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值</p></li><li><p>最小堆。最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200307460.png" alt="image-20201203200307460" style="zoom:80%;"></li></ol><p>二叉堆的根节点叫作<strong>堆顶</strong>。最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>插入节点：单一节点上浮，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li><li>删除节点：单一节点下沉，平均交换次数都是堆高度的一半，所以时间复杂度是O(log<del>2</del>n)</li><li>构建二叉堆：要所有非叶子节点依次“下沉”，时间复杂度是O(n)</li></ul><p><strong>时间复杂度推导</strong></p><p>n为节点数，level为层级</p><ul><li>插入和删除：f(n) = level-1; n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=log<del>2</del>(n+1)-1，所以时间复杂度为O(log<del>2</del>n)</li><li>构建二叉堆：满二叉树堆则f(n) = 2^level-1^；n = 2^level^-1；推导出：level = log<del>2</del>(n+1)，因此f(n)=2^log(n+1)^-2=n-1,所以为O(n)</li></ul><h2 id="自我调整"><a href="#自我调整" class="headerlink" title="自我调整"></a>自我调整</h2><p>这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。</p><ol><li>插入节点 </li></ol><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是 0。这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节点“上浮”，和父节点交换位置。继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。继续比较，最终新节点0“上浮”到了堆顶位置。<br><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203105517492.png" alt="image-20201203105517492"></p><ol start="2"><li>删除节点 </li></ol><p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点。例如删除最小堆的堆顶节点1。这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到原本堆顶的位置。接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果左、右孩子节点中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203194844232.png" alt="image-20201203194844232"><ol start="3"><li>构建二叉堆</li></ol><p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，**<font color="red">本质就是让所有 非叶子节点依次“下沉”</font>**。</p><p>如下图的无序完全二叉树，找到第一个非叶子节点即10，与其子节点比较，节点6与节点10交互位置。数组方式存储，则下一个节点为节点3，与其子节点比较，节点3与节点2交互位置。下一个节点为1，与字节点比较，不用交换位置。最后一个节点为7，与其子节点比较，节点7下沉，与节点1交互位置，继续与子节点比较，子节点为6和5，最后于5节点交换位置。</p><img src="/2020/12/03/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86/image-20201203200122412.png" alt="image-20201203200122412" style="zoom:80%;"><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childrenIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&gt;<span class="number">0</span> &amp;&amp; temp&lt;array[parentIndex])&#123;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[childrenIndex] = array[parentIndex];</span><br><span class="line">      childrenIndex = parentIndex;</span><br><span class="line">      parentIndex = (childrenIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childrenIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> array  待调整的堆</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parentIndex  要“下沉”的父节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> parentIndex,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">while</span> (childrenIndex&lt;length)&#123;</span><br><span class="line">      <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">      <span class="keyword">if</span>(childrenIndex+<span class="number">1</span>&lt;length &amp;&amp; array[childrenIndex+<span class="number">1</span>]&lt;array[childrenIndex])&#123;</span><br><span class="line">        childrenIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">      <span class="keyword">if</span>(temp&lt;array[childrenIndex])&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">      array[parentIndex] = array[childrenIndex];</span><br><span class="line">      parentIndex = childrenIndex;</span><br><span class="line">      childrenIndex = <span class="number">2</span>*parentIndex+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeapTree</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">      downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    upAdjust(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    buildHeapTree(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除是用最后一个节点值替换要删除的节点，之后再下沉自我调整</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    downAdjust(array,<span class="number">1</span>,array.length);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉堆的使用场景"><a href="#二叉堆的使用场景" class="headerlink" title="二叉堆的使用场景"></a>二叉堆的使用场景</h2><p>二叉堆是实现<strong>堆排序</strong>及<strong>优先队列</strong>的基础</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（四）之树及二叉树和遍历</title>
      <link href="2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/"/>
      <url>2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="树概念"><a href="#树概念" class="headerlink" title="树概念"></a>树概念</h2><p>树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。 </p><ol><li>有且仅有一个特定的称为根的节点。</li><li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 <img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134605336.png" alt="image-20201201134605336" style="zoom: 33%;"></li></ol><p>在上图中，节点1是根节点（root）；节点5、6、7、8是树的末端，没有“孩子”，被称为叶子节点（leaf）。图中的虚线部分，是根节点1的其中一个子树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201134818417.png" alt="image-20201201134818417" style="zoom: 33%;"></p><p>树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如下。</p><p>在上图中，节点4的上一级节点，是节点4的<strong>父节点（parent）</strong>；从节点4衍生出来的节点，是节点4的<strong>孩子节点（child）</strong>；和节点4同级，由同一个父节点衍生出来的节点，是节点4的<strong>兄弟节点（sibling）</strong></p><p>树的最大层级数，被称为树的高度或深度。显然，上图这个树的高度是4。</p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135228229.png" alt="image-20201201135228229" style="zoom: 33%;"><br>二叉树节点的两个孩子节点，一个被称为<strong>左孩子（left child）</strong>，一个被称为<strong>右孩子（right child）</strong>。这两个孩子节点的顺序是固定的，就像人的左手就是左手，右手就是右手，不能够颠倒或混淆。</p><p>二叉树还有两种特殊形式，一个叫作<strong>满二叉树</strong>，另一个叫作<strong>完全二叉树</strong></p><h3 id="什么是满二叉树"><a href="#什么是满二叉树" class="headerlink" title="什么是满二叉树"></a>什么是满二叉树</h3><p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。简单点说，满二叉树的每一个分支都是满的。一棵深度为k且有2^K^-1个节点的二叉树称为满二叉树。满二叉树每一层的结点个数都达到了最大值, 即满二叉树的第i层上有2^i-1^个节点（i&gt;=1）<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135513962.png" alt="image-20201201135513962" style="zoom:33%;"></p><h3 id="什么是完全二叉树"><a href="#什么是完全二叉树" class="headerlink" title="什么是完全二叉树"></a>什么是完全二叉树</h3><p>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201135646991.png" alt="image-20201201135646991" style="zoom:33%;"><br>在上图中，二叉树编号从1到12的12个节点，和前面满二叉树编号从1到12的节点位置完全对应。因此这个树是完全二叉树。<br>完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树</p><h3 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h3><p>链式存储结构。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140333971.png" alt="image-20201201140333971" style="zoom:25%;"></p><ul><li>存储数据的data变量 </li><li>指向左孩子的left指针 </li><li>指向右孩子的right指针</li></ul><p>数组。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201140524048.png" alt="image-20201201140524048" style="zoom:25%;"><br>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p><p><strong>为什么这样设计</strong><br>因为这样可以更方便地在数组中定位二叉树的孩子节点和 父节点。</p><p>假设一个父节点的下标是parent，那么它的左孩子节点下标就是2×parent +1；右孩子节点下标就是2×parent + 2。<br>反过来，假设一个左孩子节点的下标是leftChild，那么它的父节点下标就是（leftChild-1）/ 2。<br>假如节点4在数组中的下标是3，节点4是节点2的左孩子，节点2的下标可以直接<br>通过计算得出。节点2的下标 = (3-1)/2 = 1 </p><p>显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p><p><strong>什么样的二叉树最适合用数组表示呢？</strong></p><p>一种特殊的完全二叉树，就是用数组来存储的。</p><h3 id="二叉树应用"><a href="#二叉树应用" class="headerlink" title="二叉树应用"></a>二叉树应用</h3><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行<strong>查找操作和维持相对顺序</strong>这两个方面。 </p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>二叉树的树形结构使它很适合扮演索引的角色。 <strong>二叉查找树（binary search tree）</strong>主要作用就是进行查找操作</p><p><strong>二叉查找树</strong><br>二叉查找树在二叉树的基础上增加了以下几个条件。 <font color="red"><strong>为了查找方便</strong></font>。</p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值 </li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值 </li><li>左、右子树也都是二叉查找树<img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141125488.png" alt="image-20201201141125488" style="zoom:25%;">对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度是一样的。这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。 #### **维持相对顺序**二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。因此二叉查找树还有另一个名字——二叉排序树（binary sort tree）。 </li></ul><h4 id="二叉查找树（二叉排序树）的问题"><a href="#二叉查找树（二叉排序树）的问题" class="headerlink" title="二叉查找树（二叉排序树）的问题"></a>二叉查找树（二叉排序树）的问题</h4><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201141637961.png" alt="image-20201201141637961" style="zoom:25%;">在根节点为10的节点情况下，插入9、8、7节点时，会出现如图的情况。查询节点的时间复杂度退化成O(n)。<h4 id="二叉树自平衡"><a href="#二叉树自平衡" class="headerlink" title="二叉树自平衡"></a>二叉树自平衡</h4><p>二叉树自平衡的方式有多种，如红黑树、AVL树、树堆等</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>从节点之间位置关系的角度来看，二叉树的遍历分为4种</p><ul><li><p><strong>前序遍历</strong>：输出顺序是根节点、左子树、右子树。</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200256982.png" alt="image-20201201200256982" style="zoom:25%;"></li><li><p><strong>中序遍历</strong>：输出顺序是左子树、根节点、右子树</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200341762.png" alt="image-20201201200341762" style="zoom:25%;"></li><li><p><strong>后序遍历</strong>：输出顺序是左子树、右子树、根节点</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201201200417902.png" alt="image-20201201200417902" style="zoom:25%;"></li><li><p>层序遍历。层级输出</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86/image-20201202112654756.png" alt="image-20201202112654756" style="zoom:25%;"></li></ul><p>从更宏观的角度来看，二叉树的遍历归结为两大类。</p><ul><li><p>深度优先遍历（前序遍历、中序遍历、后序遍历）。 所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。</p></li><li><p>广度优先遍历（层序遍历）。就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点 。</p><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。 </p></li></ul><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(LinkedList list)</span> </span>&#123;</span><br><span class="line">    TreeNode treeNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(list) || list.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object o = list.removeFirst();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(o)) &#123;</span><br><span class="line">      treeNode = <span class="keyword">new</span> TreeNode();</span><br><span class="line">      treeNode.date = o;</span><br><span class="line">      treeNode.leftNode = createTree(list);</span><br><span class="line">      treeNode.rightNode = createTree(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderForeachWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode treeNode = root;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (treeNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        stack.push(treeNode.leftNode);</span><br><span class="line">        treeNode = treeNode.leftNode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop != <span class="keyword">null</span>) &#123;</span><br><span class="line">          treeNode = pop.rightNode;</span><br><span class="line">          stack.push(treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderForeach</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(treeNode)) &#123;</span><br><span class="line">      preOrderForeach(treeNode.leftNode);</span><br><span class="line">      preOrderForeach(treeNode.rightNode);</span><br><span class="line">      System.out.print(treeNode.date + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    Object date;</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList list = <span class="keyword">new</span> LinkedList(Arrays</span><br><span class="line">        .asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">7</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">10</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="number">4</span>&#125;));</span><br><span class="line">    TreeNode treeNode = createTree(list);</span><br><span class="line">    preOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    preOrderForeachWithStack(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    inOrderForeach(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    postOrderForeach(treeNode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderForeach</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">    TreeNode treeNode = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(treeNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.print(treeNode.date+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(treeNode.leftNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.leftNode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(treeNode.rightNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(treeNode.rightNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之数据结构线性结构和非线性结构</title>
      <link href="2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://www.cnblogs.com/mr-wuxiansheng/">Mr_伍先生</a></p><p>出处：<a href="https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html">https://www.cnblogs.com/mr-wuxiansheng/p/8688946.html</a></p><h2 id="线性结构："><a href="#线性结构：" class="headerlink" title="线性结构："></a>线性结构：</h2><p>一、概念</p><ol><li><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</p></li><li><p>线性结构拥有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</p></li><li><p>线性结构中存在两种操作受限的使用场景，即队列和栈。栈的操作只能在线性表的一端进行，就是我们常说的先进后出（FILO），队列的插入操作在线性表的一端进行而其他操作在线性表的另一端进行，先进先出（FIFO），由于线性结构存在两种存储结构，因 此队列和栈各存在两个实现方式。</p></li></ol><p>二、部分实现</p><ol><li><p>顺序表（顺序存储）</p><p>　　按照我们的习惯，存放东西时，一般是找一块空间，然后将需要存放的东西依次摆放，这就是顺序存储。计算机中的顺序存储是指在内存中用一块地址连续的空间依次存放数据元素，用这种方式存储的线性表叫顺序表其特点是表中相邻的数据元素在内存中存储位置也相邻，如下图：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809140928262-492338500.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置线性表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     T tmp = <span class="keyword">default</span>(T);</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> len = GetLength() - <span class="number">1</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (i.Equals(len - i))</span><br><span class="line"><span class="number">10</span>         &#123;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>         tmp = data[i];</span><br><span class="line"><span class="number">15</span>         data[i] = data[len - i];</span><br><span class="line"><span class="number">16</span>         data[len - i] = tmp;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>链表（链式存储）</p><p>　　假如我们现在要存放一些物品，但是没有足够大的空间将所有的物品一次性放下（电脑中使用链式存储不是因为内存不够先事先说明一下…，具体原因后续会说到），同时设定我们因为脑容量很小，为了节省空间，只能记住一件物品位置。此时我们很机智的找到了解决方案：存放物品时每放置一件物品就在物品上贴一个小纸条，标明下一件物品放在那里，只记住第一件物品的位置，寻找的时候从第一件物品开始寻找，通过小纸条我们可以找到所有的物品，这就是链式存储。链表实现的时候不再像线性表一样只存储数据即可，还有下一个数据元素的地址，因此先定义一个节点类(Node)，记录物品信息和下一件物品的位置，我们把物品本身叫做数据域，存储下一件物品地址信息的小纸条称为引用域。链表结构示意图如下：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809143506652-1333091670.png" alt="img"></p><p>　　寻找物品的时候发现了一个问题，我们从一件物品找下一件物品的时候很容易，但是如果要找上一件物品就得从头开始找，真的很麻烦。为了解决这个问题我们又机智了一把，模仿之前的做法，在存放物品的时候多放置一个小纸条记录上一件物品的位置，这样就可以很快的找到上一件物品了。我们把这种方式我们称为双向链表，前面只放置一张小纸条的方式称为单向链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 倒置单链表</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; oldHead = Head;</span><br><span class="line"> <span class="number">5</span>     Node&lt;T&gt; tmp ;</span><br><span class="line"> <span class="number">6</span>     Head = <span class="keyword">null</span>;    <span class="comment">//清空链表，解除Head跟oldHead之间的相同引用</span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="keyword">while</span> (oldHead != <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">9</span>     &#123;</span><br><span class="line"><span class="number">10</span>         tmp = Head;</span><br><span class="line"><span class="number">11</span>         Head = oldHead;</span><br><span class="line"><span class="number">12</span>         <span class="comment">//解除Head跟oldHead之间的相同引用</span></span><br><span class="line"><span class="number">13</span>         oldHead = oldHead.Next;</span><br><span class="line"><span class="number">14</span>         Head.Next = tmp;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure><p>　　由于数据存储结构不同导致使用场景上的巨大差异，顺序表由于元素连续具有随机存储的特点，所以查找数据很方便效率很高，但是插入、删除操作为了确保数据元素连续，需要移动大量的数据导致效率很低。而链表由于存储空间不要求连续，插入、删除只需修改相邻元素的引用域地址即可，所以效率很高，但查询需要从头引用开始遍历链表，效率很低。因此，如果只是进行查找操作而不经常插入、删除线性表中的数据元素，则使用顺序存储结构，反之，使用链式存储结构。</p></li><li><p>栈</p><p>　　其实成功完成顺序表和链表之后，栈已经没太多可说的了，主要是逻辑上的不同，毕竟栈也是一种特殊的线性结构。栈是一种操作限定在表尾部进行的线性表，表尾称为栈顶（Top），另一端固定不动，称为栈底（Bottom）。进栈、出栈示意图如下：</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809151153090-1514548602.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链栈入驻</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; tmp = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Top == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Top = tmp;</span><br><span class="line"> <span class="number">8</span>     &#125;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>     &#123;</span><br><span class="line"><span class="number">11</span>         tmp.Next = Top;</span><br><span class="line"><span class="number">12</span>         Top = tmp;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     Num++;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">//顺序栈入栈</span></span><br><span class="line"><span class="number">18</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">19 </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">21</span>     &#123;</span><br><span class="line"><span class="number">22</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"><span class="number">25</span>     data[++Top] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>队列</p><p>　　队列与栈类似，仅仅是逻辑有一丢丢不同。队列是一种插入操作限定在表尾其他操作限定在表头的线性表。把进行插入操作的表尾称为队尾（Rear）,把进行其它操作的头部称为队首（Front）。入队、出队示意图如下：</p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160809152906777-1048463470.png" alt="img" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//链队入队</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span> (Rear == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">6</span>     &#123;</span><br><span class="line"> <span class="number">7</span>         Rear = node;</span><br><span class="line"> <span class="number">8</span>         Front = Rear;</span><br><span class="line"> <span class="number">9</span>     &#125;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">11</span>     &#123;</span><br><span class="line"><span class="number">12</span>         Rear.Next = node;</span><br><span class="line"><span class="number">13</span>         Rear = Rear.Next;</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     ++num;</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span> <span class="comment">//循环队列入队</span></span><br><span class="line"><span class="number">19</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function">20 </span>&#123;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">if</span> (IsFull())</span><br><span class="line"><span class="number">22</span>     &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Queue is full&quot;</span>);</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span>     data[++Rear] = item;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="非线性结构："><a href="#非线性结构：" class="headerlink" title="非线性结构："></a>非线性结构：</h2><h3 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a><strong>一、相关概念</strong></h3><p>　　树作为一种应用广泛的一对多非线性数据结构，不仅有数据间的指向关系，还有层级关系，示例见图一。因树的结构比较复杂，为了简化操作及存储，我们一般将树转换为二叉树处理，因此本文主要讨论二叉树。</p><ol><li><p><strong>二叉树</strong><br>　　二叉树是每个节点最多拥有两个子节点的树结构，若移除根节点则其余节点会被分成两个互不相交的子树，分别称为左子树和右子树。二叉树是有序树，左右子树有严格的次序，若颠倒则成为一棵不一样的二叉树。</p></li><li><p><strong>满二叉树</strong>　　</p><p>​       满二叉树，顾名思义除叶子节点外所有节点都拥有两个孩子，且叶子节点在同一层的二叉树，示例见图二。</p></li><li><p><strong>完全二叉树</strong>　　</p><p>​        完全二叉树，移除最后一层节点后是满二叉树，且最后一层的节点都连续集中在最左面，示例见图三。<img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812141855625-736751376.png" alt="img"></p></li></ol><h3 id="二、二叉树存储结构"><a href="#二、二叉树存储结构" class="headerlink" title="二、二叉树存储结构"></a>二、二叉树存储结构</h3><ol><li><p><strong>顺序存储</strong>　　</p><p>​        根据完全二叉树的特性，可以计算出任意节点n的双亲节点及左右孩子节点的序号，因此完全二叉树的节点可以按照从上到下从左到右的顺序依次存储到一维数组中。非完全二叉树存储时应先将其改造为完全二叉树，以空替代不存在的节点，比较浪费存储空间，存储示意图见图四。</p></li><li><p><strong>链式存储</strong></p><p>　　树结构链式存储类似线性结构链式存储，先定义包含数据域和引用域的节点(Node)，然后通过引用域存储节点之间的关系。根据二叉树的结构来看，节点Node至少包含数据域(Data)，引用域(左孩子LChild、右孩子RChild)，为了方便通过孩子节点查找父节点，引用域中可以考虑添加父节点引用(Parent)，存储示意图见图五。</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812161601265-1301764954.png" alt="img"> </p></li></ol><h3 id="三、树与二叉树的转换"><a href="#三、树与二叉树的转换" class="headerlink" title="三、树与二叉树的转换"></a>三、树与二叉树的转换</h3><ol><li><p>树转二叉树</p><p><strong>加线</strong>，所有兄弟结点之间加一条连线。<br><strong>抹线</strong>，对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。</p><p><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812155626000-1300189010.png" alt="img"></p></li><li><p>二叉树转树</p><p><strong>加线</strong>，若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来。<br><strong>抹线</strong>，删除原二叉树中所有结点与其右孩子结点的连线。<br><strong>整理</strong>，整理前两步得到的树，使之结构层次分明。<br><img src="/2020/12/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/629960-20160812160125515-698914833.png" alt="img"></p></li></ol><h3 id="四、树遍历实现"><a href="#四、树遍历实现" class="headerlink" title="四、树遍历实现"></a>四、树遍历实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"> <span class="number">2</span> <span class="comment">/// 先序遍历（DLR）</span></span><br><span class="line"> <span class="number">3</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"> <span class="number">4</span> <span class="comment">/// &lt;![CDATA[首先访问跟节点，然后遍历左子树，最后右子树]]&gt;</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function"> 6 </span>&#123;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">8</span>     &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     Print(root);</span><br><span class="line"><span class="number">13</span>     PreOrder(root.LChild);</span><br><span class="line"><span class="number">14</span>     PreOrder(root.RChild);</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/// 中序遍历（LDR）</span></span><br><span class="line"><span class="number">19</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">20</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后根节点，最后遍历右子树]]&gt;</span></span><br><span class="line"><span class="number">21</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">22 </span>&#123;</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">24</span>     &#123;</span><br><span class="line"><span class="number">25</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     InOrder(root.LChild);</span><br><span class="line"><span class="number">29</span>     Print(root);</span><br><span class="line"><span class="number">30</span>     InOrder(root.RChild);</span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">34</span> <span class="comment">/// 后序遍历（LRD）</span></span><br><span class="line"><span class="number">35</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">36</span> <span class="comment">/// &lt;![CDATA[先遍历左子树，然后遍历右子树，最后遍历根节点]]&gt;</span></span><br><span class="line"><span class="number">37</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">38 </span>&#123;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">40</span>     &#123;</span><br><span class="line"><span class="number">41</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">42</span>     &#125;</span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>     PostOrder(root.LChild);</span><br><span class="line"><span class="number">45</span>     PostOrder(root.RChild);</span><br><span class="line"><span class="number">46</span>     Print(root);</span><br><span class="line"><span class="number">47</span> &#125;</span><br><span class="line"><span class="number">48</span> </span><br><span class="line"><span class="number">49</span> <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="number">50</span> <span class="comment">/// 层序遍历</span></span><br><span class="line"><span class="number">51</span> <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="number">52</span> <span class="comment">/// &lt;![CDATA[从上向下从左到右]]&gt;</span></span><br><span class="line"><span class="number">53</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(Node&lt;<span class="keyword">char</span>&gt; root)</span></span></span><br><span class="line"><span class="function">54 </span>&#123;</span><br><span class="line"><span class="number">55</span>     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">56</span>     &#123;</span><br><span class="line"><span class="number">57</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">58</span>     &#125;</span><br><span class="line"><span class="number">59</span>     CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt; sq = <span class="keyword">new</span> CSeqQueue&lt;Node&lt;<span class="keyword">char</span>&gt;&gt;(<span class="number">50</span>);</span><br><span class="line"><span class="number">60</span>     sq.In(root);</span><br><span class="line"><span class="number">61</span>     <span class="keyword">while</span> (!sq.IsEmpty())</span><br><span class="line"><span class="number">62</span>     &#123;</span><br><span class="line"><span class="number">63</span>         Node&lt;<span class="keyword">char</span>&gt; tmp = sq.Out();</span><br><span class="line"><span class="number">64</span>         Print(tmp);</span><br><span class="line"><span class="number">65</span> </span><br><span class="line"><span class="number">66</span>         <span class="keyword">if</span> (tmp.LChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">67</span>         &#123;</span><br><span class="line"><span class="number">68</span>             sq.In(tmp.LChild);</span><br><span class="line"><span class="number">69</span>         &#125;</span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">71</span>         <span class="keyword">if</span> (tmp.RChild != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">72</span>         &#123;</span><br><span class="line"><span class="number">73</span>             sq.In(tmp.RChild);</span><br><span class="line"><span class="number">74</span>         &#125;</span><br><span class="line"><span class="number">75</span>     &#125;</span><br><span class="line"><span class="number">76</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程池</title>
      <link href="2020/11/30/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/11/30/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发集合</title>
      <link href="2020/11/30/java%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/"/>
      <url>2020/11/30/java%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="2020/11/30/java%E9%9B%86%E5%90%88/"/>
      <url>2020/11/30/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><strong>数组</strong></p><p>​    开辟连续内存地址空间，数组长度固定，不能进行扩容，顺序存储。</p><hr><p><strong>List集合</strong></p><p>​    list集合可以使用数组或链表存储数据。</p><ul><li><p>ArrayList 使用数组进行存储。查找、更新效率高，插入、删除效率低，顺序存储，扩容为旧数组</p></li><li><p>LinkedList 使用双向链表进行存储。查找、更新效率低，插入、删除效率高，随机存储，不需要考虑扩容。<font color="red">使用二分查找法</font></p></li><li><p>Vector 使用数组进行存储，使用synchronized保证线程安全</p></li></ul><hr><p><strong>Map哈希表</strong></p><ul><li><p>HashMap 1.7使用数组+单链表  1.8使用数组+单链表/红黑树(提升插入和查找的效率)，原容量的二倍扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_INITIAL_CAPACITY <span class="comment">//初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</span></span><br><span class="line">MAXIMUM_CAPACITY <span class="comment">//哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</span></span><br><span class="line">DEFAULT_LOAD_FACTOR <span class="comment">//默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span></span><br><span class="line">TREEIFY_THRESHOLD <span class="comment">//如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此 Java 的处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。</span></span><br><span class="line">UNTREEIFY_THRESHOLD <span class="comment">// 在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。</span></span><br><span class="line">MIN_TREEIFY_CAPACITY <span class="comment">//在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash <span class="comment">//计算下标</span></span><br></pre></td></tr></table></figure></li><li><p>LinkedHashMap  继承HashMap,多了二个自定义的继承HashMap的Node(增加了Entry&lt;K,V&gt; before, after)类的Entry类型的变量head、tail。通过head和tail节点记录数据的<font color="red">插入顺序或者访问顺序。</font>默认是插入顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head; <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail; <span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">//访问顺序，默认为false</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TreeMap  使用红黑树，可以自定义<font color="red">比较器</font>。自动通过key比较大小，如果key相等，则覆盖value的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//根节点</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WeakHashMap 弱键值对，与HashMap类似，使用的是数组+单链表，涉及到扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;(); <span class="comment">//弱引用队列</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弱引用——&gt;回收之后会存入引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashTable 线程安全的，与HashMap类似，使用数组+单链表，涉及到扩容。使用同步块synchronized，保证线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">//节点数组</span></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EnumMap</p></li></ul><hr><p><strong>Set集合</strong></p><ul><li><p>HashSet 使用的是HashMap进行数据存储，value为Object对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LinkedHashSet 继承HashSet，使用LinkedHashMap进行数据存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TreeSet 成员变量m的类型为TreeMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>Stack栈</strong> 先进后出（FILO），synchronized同步块保证线程安全，继承Vector，底层使用数组保存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Vector,线程同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>BitSet位图</strong> 使用数组存储，每位存储的值为0或者1，使用位运算。二倍原数组长度扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] words;</span><br><span class="line"><span class="comment">//计算value[值为0,1]在那个数组里下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;  <span class="comment">//ADDRESS_BITS_PER_WORD=6,&gt;&gt;6表示除以2的6次方即64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算bitIndex的值 1L&lt;&lt;64 还是等于为1</span></span><br><span class="line">(words[wordIndex] &amp; (<span class="number">1L</span> &lt;&lt; bitIndex)) != <span class="number">0</span></span><br><span class="line"><span class="comment">//设置bitIndex的值为1</span></span><br><span class="line">words[wordIndex] |= (<span class="number">1L</span> &lt;&lt; bitIndex);</span><br></pre></td></tr></table></figure><hr><p><strong>Queue队列</strong></p><ul><li><p>ArrayDeque 双端队列</p></li><li><p>PriorityQueue 优先级队列</p></li><li><p>BlockingQueue 堵塞队列</p><ul><li><p><strong>LinkedBlockingQueue</strong> 的容量是没有上限的（说的不准确，在不指定时容量为Integer.MAX_VALUE，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。</p></li><li><p><strong>ArrayBlockingQueue</strong> 在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序。</p></li><li><p><strong>DelayQueue</strong>（基于PriorityQueue来实现的）是一个存放Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。 </p></li><li><p><strong>PriorityBlockingQueue</strong> 是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。</p></li><li><p><strong>SynchronousQueue</strong> 一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没 有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null 元素。</p><p>同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p><p> 看起来很有意思吧。队列竟然是没有内部容量的。这个队列其实是BlockingQueue的一种实现。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。它给我们提供了在线程之间交换单一元素的极轻量级方法</p></li></ul></li></ul><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><strong>add</strong></td><td>增加一个元索           如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td></tr><tr><td><strong>remove</strong></td><td>移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td><strong>element</strong></td><td>返回队列头部的元素 ，如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td><strong>offer</strong></td><td>添加一个元素并返回true    如果队列已满，则返回false</td></tr><tr><td><strong>poll</strong></td><td>移除并返问队列头部的元素  如果队列为空，则返回null</td></tr><tr><td><strong>peek</strong></td><td>返回队列头部的元素       如果队列为空，则返回null</td></tr><tr><td><strong>put</strong></td><td>添加一个元素           如果队列满，则阻塞</td></tr><tr><td><strong>take</strong></td><td>移除并返回队列头部的元素   如果队列为空，则阻塞</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s之调度器和调度过程</title>
      <link href="2020/11/30/k8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/"/>
      <url>2020/11/30/k8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本文作者</strong>：**<a href="https://www.cnblogs.com/xzkzzz/p/9963511.html">大胖猴</a>**<br><strong>本文链接</strong>：<a href="https://www.cnblogs.com/xzkzzz/p/9963511.html">https://www.cnblogs.com/xzkzzz/p/9963511.html</a></p><h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><p>当Scheduler通过API server 的watch接口监听到新建Pod副本的信息后，它会检查所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。Scheduler在整个系统中承担了承上启下的作用，承上是负责接收创建的新Pod，为安排一个落脚的地（Node）,启下是安置工作完成后，目标Node上的kubelet服务进程接管后继工作，负责Pod生命周期的后半生。具体来说，Scheduler的作用是将待调度的Pod安装特定的调度算法和调度策略绑定到集群中的某个合适的Node上，并将绑定信息传给API server 写入etcd中。整个调度过程中涉及三个对象，分别是：待调度的Pod列表，可以的Node列表，以及调度算法和策略。</p><p>Kubernetes Scheduler 提供的调度流程分三步：</p><ol><li>预选策略(predicate) 遍历nodelist，选择出符合要求的候选节点，Kubernetes内置了多种预选规则供用户选择。</li><li>优选策略(priority) 在选择出符合要求的候选节点中，采用优选规则计算出每个节点的积分，最后选择得分最高的。</li><li>选定(select) 如果最高得分有好几个节点，select就会从中随机选择一个节点。</li></ol><p>如图：</p><p><img src="/2020/11/30/k8s%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/1076553-20181115142949847-1134192119.png" alt="img"></p><p>预选策略算法的集合在<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithm/predicates/predicates.go">官方源码</a></p><h3 id="常用的预选策略（代码里的策略不一定都会被使用）"><a href="#常用的预选策略（代码里的策略不一定都会被使用）" class="headerlink" title="常用的预选策略（代码里的策略不一定都会被使用）"></a>常用的预选策略（代码里的策略不一定都会被使用）</h3><ul><li>CheckNodeConditionPred 检查节点是否正常</li><li>GeneralPred HostName(如果pod定义hostname属性，会检查节点是否匹配。pod.spec.hostname)、PodFitsHostPorts（检查pod要暴露的hostpors是否被占用。pod.spec.containers.ports.hostPort）</li><li>MatchNodeSelector pod.spec.nodeSelector 看节点标签能否适配pod定义的nodeSelector</li><li>PodFitsResources 判断节点的资源能够满足Pod的定义（如果一个pod定义最少需要2C4G node上的低于此资源的将不被调度。用kubectl describe node NODE名称 可以查看资源使用情况）</li><li>NoDiskConflict 判断pod定义的存储是否在node节点上使用。（默认没有启用）</li><li>PodToleratesNodeTaints 检查pod上Tolerates的能否容忍污点（pod.spec.tolerations）</li><li>CheckNodeLabelPresence 检查节点上的标志是否存在 （默认没有启动）</li><li>CheckServiceAffinity 根据pod所属的service。将相同service上的pod尽量放到同一个节点（默认没有启动）</li><li>CheckVolumeBinding 检查是否可以绑定（默认没有启动）</li><li>NoVolumeZoneConflict 检查是否在一起区域（默认没有启动）</li><li>CheckNodeMemoryPressure 检查内存是否存在压力</li><li>CheckNodeDiskPressure  检查磁盘IO压力是否过大</li><li>CheckNodePIDPressure 检查pid资源是否过大</li></ul><h3 id="优选策略"><a href="#优选策略" class="headerlink" title="优选策略"></a>优选策略</h3><ul><li>least_requested 选择消耗最小的节点（根据空闲比率评估 cpu(总容量-sum(已使用)*10/总容量) ）**<br>**</li><li>balanced_resource_allocation 从节点列表中选出各项资源使用率最均衡的节点（CPU和内存）</li><li>node_prefer_avoid_pods 节点倾向</li><li>taint_toleration 将pod对象的spec.toleration与节点的taints列表项进行匹配度检查，匹配的条目越多，得分越低。</li><li>selector_spreading 与services上其他pod尽量不在同一个节点上，节点上通一个service的pod越少得分越高。</li><li>interpod_affinity 遍历node上的亲和性条目，匹配项越多的得分越高</li><li>most_requested 选择消耗最大的节点上（尽量将一个节点上的资源用完）</li><li>node_label 根据节点标签得分，存在标签既得分，没有标签没得分。标签越多 得分越高。</li><li>image_locality 节点上有所需要的镜像既得分，所需镜像越多得分越高。（根据已有镜像体积大小之和）</li></ul><h2 id="高级调度方式"><a href="#高级调度方式" class="headerlink" title="高级调度方式"></a>高级调度方式</h2><p>当我们想把调度到预期的节点，我们可以使用高级调度分为：</p><ul><li>节点选择器： nodeSelector、nodeName</li><li>节点亲和性调度： nodeAffinity</li><li>Pod亲和性调度：PodAffinity</li><li>Pod反亲和性调度：podAntiAffinity</li></ul><h3 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h3><p>我们定义一个pod,让其选择带有node=ssd这个标签的节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-1</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  nodeSelector:</span><br><span class="line">    node: ssdkubectl apply -f test.yaml</span><br></pre></td></tr></table></figure><p>查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#get一下pod 一直处于Pending状态</span><br><span class="line">$ kubectl get pod </span><br><span class="line">NAME      READY     STATUS    RESTARTS   AGE</span><br><span class="line">pod-1     0&#x2F;1       Pending   0          7s</span><br><span class="line">#查看详细信息,是没有可用的selector</span><br><span class="line">$ kubectl describe pod pod-1</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  9s (x14 over 36s)  default-scheduler  0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line">#我们给node2打上这个标签</span><br><span class="line">$  kubectl label node k8s-node02 node&#x3D;ssd</span><br><span class="line">node&#x2F;k8s-node02 labeled</span><br><span class="line">#Pod正常启动</span><br><span class="line">$  kubectl describe pod pod-1</span><br><span class="line">....</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From                 Message</span><br><span class="line">  ----     ------            ----               ----                 -------</span><br><span class="line">  Warning  FailedScheduling  2m (x122 over 8m)  default-scheduler    0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line">  Normal   Pulled            7s                 kubelet, k8s-node02  Container image &quot;ikubernetes&#x2F;myapp:v1&quot; already present on machine</span><br><span class="line">  Normal   Created           7s                 kubelet, k8s-node02  Created container</span><br><span class="line">  Normal   Started           7s                 kubelet, k8s-node02  Started container</span><br></pre></td></tr></table></figure><h3 id="nodeAffinity"><a href="#nodeAffinity" class="headerlink" title="nodeAffinity"></a>nodeAffinity</h3><p>kubectl explain pod.spec.affinity.nodeAffinity </p><ul><li>requiredDuringSchedulingIgnoredDuringExecution 硬亲和性 必须满足亲和性。<ul><li>matchExpressions 匹配表达式,这个标签可以指定一段，例如pod中定义的key为zone，operator为In(包含那些)，values为 foo和bar。就是在node节点中包含foo和bar的标签中调度</li><li>matchFields 匹配字段 和上面的意思 不过他可以不定义标签值，可以定义</li></ul></li><li>preferredDuringSchedulingIgnoredDuringExecution  软亲和性 能满足最好，不满足也没关系。<ul><li>preference 优先级</li><li>weight 权重1-100范围内，对于满足所有调度要求的每个节点，调度程序将通过迭代此字段的元素计算总和，并在节点与对应的节点匹配时将“权重”添加到总和。</li></ul></li></ul><p>运算符包含：<code>In</code>，<code>NotIn</code>，<code>Exists</code>，<code>DoesNotExist</code>，<code>Gt</code>，<code>Lt</code>。可以使用<code>NotIn</code>和<code>DoesNotExist</code>实现节点反关联行为。</p><p>硬亲和性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - foo</span><br><span class="line">            - bar</span><br><span class="line">$ kubectl apply -f pod-affinity-demo.yaml </span><br><span class="line">$ kubectl describe pod node-affinity-pod </span><br><span class="line">.....</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  33s (x25 over 1m)  default-scheduler  0&#x2F;4 nodes are available: 4 node(s) didn&#39;t match node selector.</span><br><span class="line"># 给其中一个node打上foo的标签</span><br><span class="line">$ kubectl label node k8s-node03 zone&#x3D;foo</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                READY     STATUS    RESTARTS   AGE</span><br><span class="line">node-affinity-pod   1&#x2F;1       Running   0          8m</span><br></pre></td></tr></table></figure><p> 软亲和性：</p><p>与requiredDuringSchedulingIgnoredDuringExecution比较，这里需要注意的是preferredDuringSchedulingIgnoredDuringExecution是个列表项，而preference不是一个列表项了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod-2</span><br><span class="line">  labels:</span><br><span class="line">    name: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 50</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: zone</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - foo</span><br><span class="line">            - bar$ kubectl get pod -o wide NAME                  READY     STATUS    RESTARTS   AGE       IP           NODEnode-affinity-pod     1&#x2F;1       Running   0          3h        10.244.3.2   k8s-node03node-affinity-pod-2   1&#x2F;1       Running   0          1m        10.244.3.3   k8s-node03</span><br></pre></td></tr></table></figure><h3 id="podAffinity"><a href="#podAffinity" class="headerlink" title="podAffinity"></a>podAffinity</h3><p>Pod亲和性场景，我们的k8s集群的节点分布在不同的区域或者不同的机房，当服务A和服务B要求部署在同一个区域或者同一机房的时候，我们就需要亲和性调度了。</p><p>kubectl explain pod.spec.affinity.podAffinity 和NodeAffinity是一样的，都是有硬亲和性和软亲和性</p><p>硬亲和性：</p><ul><li>labelSelector 选择跟那组Pod亲和</li><li>namespaces 选择哪个命名空间</li><li>topologyKey 指定节点上的哪个键</li></ul><p>样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod1</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: service</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod2</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: front</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - podaffinity-myapp</span><br><span class="line">        topologyKey: kubernetes.io&#x2F;hostname </span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide </span><br><span class="line">NAME                  READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">node-affinity-pod1    1&#x2F;1       Running   0          12s       10.244.2.6   k8s-node02</span><br><span class="line">node-affinity-pod2    1&#x2F;1       Running   0          12s       10.244.2.5   k8s-node02</span><br></pre></td></tr></table></figure><h3 id="podAntiAffinity"><a href="#podAntiAffinity" class="headerlink" title="podAntiAffinity"></a>podAntiAffinity</h3><p>Pod反亲和性场景，当应用服务A和数据库服务B要求尽量不要在同一台节点上的时候。</p><p> kubectl explain pod.spec.affinity.podAntiAffinity 也分为硬反亲和性和软反亲和性调度（和podAffinity一样的配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#首先把两个node打上同一个标签。</span><br><span class="line">kubectl label node k8s-node02 zone&#x3D;foo </span><br><span class="line">kubectl label node k8s-node03 zone&#x3D;foo</span><br><span class="line">#反硬亲和调度</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod1</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: service</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: node-affinity-pod2</span><br><span class="line">  labels:</span><br><span class="line">    name: podaffinity-myapp</span><br><span class="line">    tier: front</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes&#x2F;myapp:v1</span><br><span class="line">  affinity:</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - podaffinity-myapp</span><br><span class="line">        topologyKey: zone</span><br></pre></td></tr></table></figure><p>查看一下(因为zone这个key在每个node都有会，所以第二个Pod没有办法调度，所以一直Pending状态)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get  pod </span><br><span class="line">NAME                 READY     STATUS    RESTARTS   AGE</span><br><span class="line">node-affinity-pod1   1&#x2F;1       Running   0          11s</span><br><span class="line">node-affinity-pod2   0&#x2F;1       Pending   0          11s</span><br></pre></td></tr></table></figure><h3 id="污点容忍调度（Taint和Toleration）"><a href="#污点容忍调度（Taint和Toleration）" class="headerlink" title="污点容忍调度（Taint和Toleration）"></a>污点容忍调度（Taint和Toleration）</h3><p>前两种方式都是pod选择那个pod，而污点调度是node选择的pod，污点就是定义在节点上的键值属性数据。举要作用是让节点拒绝pod，拒绝不合法node规则的pod。Taint（污点）和 Toleration（容忍）是相互配合的，可以用来避免 pod 被分配到不合适的节点上,每个节点上都可以应用<strong>一个或多个</strong> taint ，这表示对于那些不能容忍这些 taint 的 pod，是不会被该节点接受的。</p><h4 id="Taint"><a href="#Taint" class="headerlink" title="Taint"></a>Taint</h4><p>Taint是节点上属性，我们看一下Taints如何定义</p><p>kubectl explain node.spec.taints（对象列表）</p><ul><li>key 定义一个key</li><li>value 定义一个值</li><li>effect pod不能容忍这个污点时，他的行为是什么，行为分为三种：NoSchedule 仅影响调度过程，对现存的pod不影响。PreferNoSchedule 系统将<em>尽量</em>避免放置不容忍节点上污点的pod，但这不是必需的。就是软版的NoSchedule NoExecute 既影响调度过程，也影响现存的pod，不满足的pod将被驱逐。</li></ul><h4 id="node-打-taint"><a href="#node-打-taint" class="headerlink" title="node 打 taint"></a>node 打 taint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint NODE NAME KEY_1&#x3D;VAL_1:TAINT_EFFECT_1 ... KEY_N&#x3D;VAL_N:TAINT_EFFECT_N [options]</span><br><span class="line">增加taint</span><br><span class="line">kubectl  taint node k8s-node02 node-type&#x3D;prod:NoSchedule</span><br><span class="line">删除taint</span><br><span class="line">kubectl  taint node k8s-node02 node-type:NoSchedule-</span><br></pre></td></tr></table></figure><h4 id="tolerations"><a href="#tolerations" class="headerlink" title="tolerations"></a>tolerations</h4><ul><li>key 被容忍的key</li><li>tolerationSeconds 被驱逐的宽限时间，默认是0 就是立即被驱逐</li><li>value 被容忍key的值</li><li>operator Exists只要key在就可以调度，Equal（等值比较）必须是值要相同</li><li>effect 节点调度后的操作</li></ul><p>创建一个容忍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-deploy</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: myapp</span><br><span class="line">      release: dev</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myapp</span><br><span class="line">        release: dev</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myapp-containers</span><br><span class="line">        image: ikubernetes&#x2F;myapp:v2</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: &quot;node-type&quot;</span><br><span class="line">        operator: &quot;Equal&quot;</span><br><span class="line">        value: &quot;prod&quot;</span><br><span class="line">        effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s控制台rancher</title>
      <link href="2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0rancher/"/>
      <url>2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0rancher/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> rancher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s控制台Dashboard</title>
      <link href="2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/"/>
      <url>2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.51cto.com/happylab">Happy老师</a></p><p>出处：[<a href="https://blog.51cto.com/happylab/2496756]">https://blog.51cto.com/happylab/2496756]</a>(</p><h2 id="kubernetes-dashboard简介"><a href="#kubernetes-dashboard简介" class="headerlink" title="kubernetes-dashboard简介"></a>kubernetes-dashboard简介</h2><p>kubernetes中管理集群中资源的方式通常有四种：命令行、YAML、API和图形界面，四种不同的方式适用于不同的人群和场景，对比如下：</p><ul><li>命令行kubectl，kubectl提供了命令行管理kubernetes资源<ul><li>优点：使用方便、便捷、快速管理集群资源</li><li>缺点：功能相对有限，部分操作无法支持，有一定的门槛</li></ul></li><li>YAML资源定义，kubernetes中最终转换形式，推荐使用方式<ul><li>优点：功能齐备，能够定义kubernetes的所有对象和资源</li><li>缺点：门槛较高，需要具备专业技术能力，使用排障难度大</li></ul></li><li>API管理接入，提供各种编程语言SDK接口，方便各种编程语言应用程序接入<ul><li>优点：适配各种编程语言，如Java，Go，Python，C等，方便开发kubernetes</li><li>缺点：门槛较高，适用于开发人员</li></ul></li><li>图形kubernetes-dashboard，提供图形化管理界面，能够利用metric-server实现node和pod的监控<ul><li>优点：使用简单，便捷，适合大众。</li><li>缺点：功能相对简单，功能原生，适用于demo</li></ul></li></ul><h2 id="kubernetes-dashboard安装"><a href="#kubernetes-dashboard安装" class="headerlink" title="**kubernetes-**dashboard安装"></a>**kubernetes-**dashboard安装</h2><p>社区提供了kubernetes-dashbaord的YAML资源定义文件，直接下载YAML文件安装即可实现dashboard的安装接入，需要准备条件如下：</p><ul><li>已安装好的kubernetes集群，本文环境为1.15.3</li><li>metric-server监控，node监控和pod监控视图需依赖于监控系统</li><li>RBAC认证授权，设置好账户并授予访问权限</li></ul><p>1、下载kubernetes-dashboard安装文件并应用YAML资源定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard configured</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard unchanged</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br></pre></td></tr></table></figure><p>安装文件中定义了dashboard相关的资源，可以查阅YAML文件，资源包含有：</p><ul><li>kubernetes-dashboard命名空间</li><li>ServiceAccount访问用户</li><li>Service服务访问应用，默认为ClusterIP</li><li>Secrets，存放有kubernetes-dashboard-certs，kubernetes-dashboard-csrf，kubernetes-dashboard-key-holder证书</li><li>ConfigMap配置文件</li><li>RBAC认证授权，包含有Role，ClusterRole，RoleBinding，ClusterRoleBinding</li><li>Deployments应用，kubernetes-dashboard核心镜像，还有一个和监控集成的dashboard-metrics-scraper</li></ul><p>2、校验资源的安装情况，kubernetes-dashbaord的资源都安装在kubernetes-dashboard命名空间下,包含有Deployments，Services，Secrets，ConfigMap等</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/1.gif"></p><p>3、kubernetes-dashbaord安装完毕后，kubernetes-dashboard默认service的类型为ClusterIP，为了从外部访问控制面板，开放为NodePort类型</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/2.gif"></p><p>4、此时通过https协议访问30433端口即可打开dashboard的控制台，为了保护数据安全性，集群默认开启了RBAC认证授权，需要授予权限的用户才可以访问到kubernetes集群，因此需要授权用户访问集群，集群中已定有了cluster-admin的角色和相关的Role，ClusterRole和ClusterRoleBinding角色，定义ServiceAccount将其关联即可，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# cat dashboard-rbac.yaml </span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: happycloudlab </span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: happycloudlab</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: happycloudlab</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>5、应用RBAC规则，创建一个happycloudlab的用户，并和cluster-admin的角色关联</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node-1 ~]# kubectl apply -f dashboard-rbac.yaml </span><br><span class="line">serviceaccount/happycloudlab created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/happylau created</span><br><span class="line">[root@node-1 ~]# kubectl get serviceaccounts -n kubernetes-dashboard </span><br><span class="line">NAME                   SECRETS   AGE</span><br><span class="line"><span class="keyword">default</span>                <span class="number">1</span>         <span class="number">114</span>m</span><br><span class="line">happycloudlab   <span class="number">1</span>         <span class="number">8</span>s</span><br><span class="line">kubernetes-dashboard   <span class="number">1</span>         <span class="number">114</span>m</span><br></pre></td></tr></table></figure><p>6、此时通过kubernetes-dashboard-csrf服务会自动创建一个和用户名关联的Secrets，通过token字段来登陆，token通过base64加密，解密后即可登录，如下演示登录的过程<img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/3.gif"></p><p>自此，kubernetes-dashboard安装完毕，通过RBAC认证授权特定用户访问集群权限，接下来一起探索dashboard带来的魔力吧。</p><h2 id="探索kubernetes-dashboard"><a href="#探索kubernetes-dashboard" class="headerlink" title="探索kubernetes-dashboard"></a>探索<strong>kubernetes-dashboard</strong></h2><p>kubernetes-dashboard图形工具能提供以下功能：</p><ul><li>查看kubernetes中的资源对象，包含kubernetes中各种资源<ul><li>Cluster 集群级别的资源，如命名空间，节点，PV，StorageClass，ClusterRole等</li><li>Workloads，不同类型的工作负载，包含Deployments，StatefulSets，DaemonSets，Jobs等</li><li>Discovery and LoadBalancing，服务发现和负载均衡，包含service和ingress</li><li>ConfigMap and Storage，包含ConfigMap，Secrets和PVC</li><li>Costom Resource Definition，自定义资源定义</li></ul></li><li>kubernetes资源监控，调用metric-server监控系统，实现Cluster集群，Workloads应用负载，存储等资源的监控</li><li>管理资源对象，包含创建，编辑yaml，删除负载等，主要是以Deployments等应用为主的管理</li></ul><p>1、查看集群整体概览资源，可以看到整体集群，应用负载，Pod资源的资源使用情况</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/4.gif" alt="资源概览"></p><p>2、Cluster集群资源管理，包含还有Nodes，Namespace，StorageClass等，提供在线编辑yaml方式</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/5.gif" alt="集群资源"></p><p>3、查看应用工作负载Workloads，包含各种不同的工作负载如Deployments，StatefulSets，Jobs等</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/6.gif" alt="工作负载"></p><p>4、部署Deployments工作负载，支持从YAML文件输入，YAML文件加载和图形界面部署应用</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/7.gif" alt="部署工作负载"></p><p>5、工作负载管理，扩展工作负载副本数目，滚动更新等</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/8.gif" alt="扩展副本+滚动更新"></p><p>6、远程登录容器和查看容器日志</p><p><img src="/2020/11/30/k8s%E6%8E%A7%E5%88%B6%E5%8F%B0Dashboard/9.gif" alt="登录容器和查看日志"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>kubernetes-dashboard提供了原生的k8s管理工具，提供一个便捷的可视化界面，方便使用控制台管理k8s资源，dashboard提供的功能相对原生，企业可以根据公司的需求通过api进行二次开发，以满足需求。对于k8s管理员而言，一般以使用命令行或yaml文件为主。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>dashboard安装手册：<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p><p>RBAC认证授权：<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络</title>
      <link href="2020/11/30/k8s%E7%BD%91%E7%BB%9C/"/>
      <url>2020/11/30/k8s%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s基础</title>
      <link href="2020/11/30/k8s%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/30/k8s%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://blog.51cto.com/happylab">Happy老师</a></p><p>出处：<a href="https://blog.51cto.com/happylab/2496756">https://blog.51cto.com/happylab/2496756</a></p><h2 id="kubernetes简介与功能"><a href="#kubernetes简介与功能" class="headerlink" title="kubernetes简介与功能"></a>kubernetes简介与功能</h2><p>Kubernetes是google开源的一套微服务，容器化的编排引擎，提供容器话应用的自动化部署，横向扩展和管理，是google内部容器十多年实战沉淀的结晶，已战胜Swarm，Mesos成为容器编排的行业标准。</p><p>三大容器编排引擎：</p><ul><li>Swarm Docker原生提供的容器化编排引擎，随着docker支持kubernetes逐渐废弃</li><li>Mesos 结合Marathon提供容器调度编排的能力，还能提供其他framwork的调度</li><li>Kubernetes 已成为容器编排引擎的唯一标准，越来越多程序支持kubernetes。</li></ul><p>kuberntes内置有很多非常优秀的特性使开发者专注于业务本身，其包含的功能如下：</p><p><img src="/2020/11/30/k8s%E5%9F%BA%E7%A1%80/c23e352655b2ddd6d7e9fffd224accc9.png" alt="kubernetes入门到实战（一）初窥kubernetes全貌"></p><ul><li>Service discovery and load balancing，服务发现和负载均衡，通过DNS实现内部解析，service实现负载均衡</li><li>Storage orchestration，存储编排，通过plungin的形式支持多种存储，如本地，nfs，ceph，公有云快存储等</li><li>Automated rollouts and rollbacks，自动发布与回滚，通过匹配当前状态与目标状态一致，更新失败时可回滚</li><li>Automatic bin packing，自动资源调度，可以设置pod调度的所需（requests）资源和限制资源（limits）</li><li>Self-healing，内置的健康检查策略，自动发现和处理集群内的异常，更换，需重启的pod节点</li><li>Secret and configuration management，密钥和配置管理，对于敏感信息如密码，账号的那个通过secret存储，应用的配置文件通过configmap存储，避免将配置文件固定在镜像中，增加容器编排的灵活性</li><li>Batch execution，批处理执行，通过job和cronjob提供单次批处理任务和循环计划任务功能的实现</li><li>Horizontal scaling,横向扩展功能，包含有HPA和AS，即应用的基于CPU利用率的弹性伸缩和基于平台级的弹性伸缩，如自动增加node和删除nodes节点。</li></ul><h2 id="kubernetes架构解析"><a href="#kubernetes架构解析" class="headerlink" title="kubernetes架构解析"></a>kubernetes架构解析</h2><p><img src="/2020/11/30/k8s%E5%9F%BA%E7%A1%80/9b512f2d62081a5fa35d8266f5c03a78.png" alt="kubernetes组件"></p><p>kubernetes包含两种角色：master节点和node节点，master节点是集群的控制管理节点，作为整个k8s集群的大脑。</p><ul><li>负责集群所有接入请求(kube-apiserver)，在整个集群的入口；</li><li>集群资源调度(kube-controller-scheduler)，通过watch监视pod的创建，负责将pod调度到合适的node节点；</li><li>集群状态的一致性(kube-controller-manager)，通过多种控制器确保集群的一致性，包含有Node Controller，Replication Controller，Endpoints Controller等；</li><li>元数据信息存储(etcd)，数据持久存储化，存储集群中包括node，pod，rc，service等数据；</li></ul><p>node节点是实际的工作节点，负责集群负载的实际运行，即pod运行的载体，其通常包含三个组件：Container Runtime，kubelet和kube-proxy</p><ul><li>Container Runtime是容器运行时，负责实现container生命周期管理，如docker，containerd，rktlet；</li><li>kubelet负责镜像和pod的管理，</li><li>kube-proxy是service服务实现的抽象，负责维护和转发pod的路由，实现集群内部和外部网络的访问。</li></ul><p>其他组件还包括：</p><ul><li>cloud-controller-manager，用于公有云的接入实现，提供节点管理(node)，路由管理，服务管理(LoadBalancer和Ingress)，存储管理(Volume，如云盘，NAS接入)，需要由公有云厂商实现具体的细节，kubernetes提供实现接口的接入，如腾讯云目前提供CVM的node管理，节点的弹性伸缩(AS),负载均衡的接入(CLB),存储的管理(CBS和CFS)等产品的集成；</li><li>DNS组件由kube-dns或coredns实现集群内的名称解析；</li><li>kubernetes-dashboard用于图形界面管理；</li><li>kubectl命令行工具进行API交互；</li><li>服务外部接入，通过ingress实现七层接入，由多种controller控制器组成<ul><li>traefik</li><li>nginx ingress controller</li><li>haproxy ingress controller</li><li>公有云厂商ingress controller</li></ul></li><li>监控系统用于采集node和pod的监控数据<ul><li>metric-server 核心指标监控</li><li>prometheus 自定义指标监控，提供丰富功能</li><li>heapster+influxdb+grafana 旧核心指标监控方案，现已废弃</li></ul></li><li>日志采集系统，用于收集容器的业务数据,实现日志的采集，存储和展示，由EFK实现<ul><li>Fluentd 日志采集</li><li>ElasticSearch 日志存储+检索</li><li>Kiabana 数据展示</li></ul></li></ul><h2 id="kubernetes生态"><a href="#kubernetes生态" class="headerlink" title="kubernetes生态"></a>kubernetes生态</h2><p><a href="https://landscape.cncf.io/">https://landscape.cncf.io/</a></p><h2 id="kubernetes高可用架构"><a href="#kubernetes高可用架构" class="headerlink" title="kubernetes高可用架构"></a>kubernetes高可用架构</h2><p>kubernetes高可用集群通常由3或5个节点组成高可用集群，需要保障各个节点的高可用性</p><ul><li>etcd 内置集群机制，保障数据持久存储</li><li>kube-apiserver 无状态api服务，有负载均衡调度器做负载分发，如haproxy或nginx</li><li>kube-scheduler 内置选举机制，保障调度器高可用，确保同个时刻一个leader节点工作，其他处于阻塞，防止脑裂</li><li>kube-controller-manager 内置的选举机制保障控制器高可用，机制和kube-scheduler一致。<br><img src="/2020/11/30/k8s%E5%9F%BA%E7%A1%80/61235bc58859458922f5ab4f6484ed99.jpg" alt="kubernetes入门到实战（一）初窥kubernetes全貌"></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li>kubernetes功能介绍，<a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></li><li>kubernetes组件介绍<a href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker网络</title>
      <link href="2020/11/30/docker%E7%BD%91%E7%BB%9C/"/>
      <url>2020/11/30/docker%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="docker网络知识"><a href="#docker网络知识" class="headerlink" title="docker网络知识"></a>docker网络知识</h2><h3 id="docker网络类型（–network指定网络）"><a href="#docker网络类型（–network指定网络）" class="headerlink" title="docker网络类型（–network指定网络）"></a>docker网络类型（–network指定网络）</h3><ul><li><p>bridge  默认连接到docker0这个网桥上</p></li><li><p>none 容器只能使用127.0.0.1的本机网络</p></li><li><p>host 与宿主机共享ip</p></li><li><p>link  docker run -it –name vm5 –link vm1:db1 ubuntu 创建一个容器vm5，并使用link方式连接vm1,此时的vm1的是容器名，db1是容器的别名</p></li><li><p>container 网络模式，必须同一个宿主机</p></li><li><p>自定义网络模式：</p><ul><li>bridge network  可以通过容器名互通，单一主机上运行一个相对小的网络，使用桥接网络</li><li>overlay network  创建一个大网络，可以通过overlay 网络来实现</li><li>MACVLAN network</li><li>network plugin</li><li>remote network</li></ul></li><li><p>跨主机docker容器通信方案介绍（就是自定义网络下的方案，除开bridge）</p><ul><li><p>隧道（Overlay Networking）方案：</p><ul><li>  Weave：UDP广播，本机建立新的BR，通过PCAP互通。</li><li>  Open vSwitch(OVS)：基于VxLAN和GRE协议，但是性能方面损失比较严重。</li><li>  Flannel：UDP广播，VxLan。  </li></ul></li><li><p>路由方案</p><ul><li>  Calico：基于BGP协议的路由方案，支持很细致的ACL控制，对混合云亲和度比较高。</li><li>  Macvlan：从逻辑和Kernel层来看隔离性和性能最优的方案，基于二层隔离，所以需要二层路由器支持，大多数云服务商不支持，所以混合云上比较难以实现。</li></ul></li></ul></li></ul><p><code>    隧道方案在IaaS层的网络中应用也比较多，大家共识是随着节点规模的增长复杂度会提升，而且出了网络问题跟踪起来比较麻烦，大规模集群情况下这是需要考虑的一个点。</code></p><p><code>    路由方案一般是从3层或者2层实现隔离和跨主机容器互通的，出了问题也很容易排查。</code></p><h5 id="bridge-模式的网络。其特点如下："><a href="#bridge-模式的网络。其特点如下：" class="headerlink" title="bridge 模式的网络。其特点如下："></a>bridge 模式的网络。其特点如下：</h5><ul><li>  使用一个 linux bridge，默认为 docker0</li><li>  使用 veth 对，一头在容器的网络 namespace 中，一头在 docker0 上</li><li>  该模式下Docker Container不具有一个公有IP，因为宿主机的IP地址与vethpair的 IP地址不在同一个网段内</li><li>  Docker采用NAT网络地址转换(Network Address Translation)方式，将容器内部的服务监听的端口与宿主机的某一个端口port 进行“绑定”，使得宿主机以外的世界可以主动将网络报文发送至容器内部</li><li>  外界访问容器内的服务时，需要访问宿主机的 IP 以及宿主机的端口 port</li><li>  NAT 模式由于是在三层网络上的实现手段，故肯定会影响网络的传输效率。</li><li>容器拥有独立、隔离的网络栈；让容器和宿主机以外的世界通过NAT建立通信<br>  <img src="/2020/11/30/docker%E7%BD%91%E7%BB%9C/bridge_20201013104542.png" alt="输入图片描述"></li></ul><h5 id="主要使用的网络模式"><a href="#主要使用的网络模式" class="headerlink" title="主要使用的网络模式"></a>主要使用的网络模式</h5><ul><li>Libnetwork 从Docker核心代码中分离出去，形成一个单独的库</li><li>Flannel CoreOS团队针对Kubernetes设计的一个重载网络工具，它的主要思路是：预先留出一个网段，每个主机使用其中一部分，然后每个容器被分配不同的ip；让所有的容器认为大家在同一个直连的网络，底层通过UDP/VxLAN等进行报文的封装和转发</li><li>Calico 是一个纯3层的数据中心网络方案，而且无缝集成像OpenStack这种IaaS云架构，能够提供可控的VM、容器、裸机之间的IP通信</li></ul><p><a href="https://www.jianshu.com/p/d84cdfe2ea86">详细网络知识</a><br><a href="https://blog.csdn.net/dhaiuda/article/details/82824333">docker的overlay网络</a></p><h3 id="docker网络操作"><a href="#docker网络操作" class="headerlink" title="docker网络操作"></a>docker网络操作</h3><ul><li>docker network ls            查看docker网卡</li><li>docker network rm 网卡id    删除docker网卡</li><li>docker network inspect 网卡id   查看docker网卡的相关详细信息</li><li>创建网络，如下使用–subnet创建网络（用来指定ip段），–gateway（用来指定网关），my_net3为创建的名字：<br>docker network create –driver bridge –subnet 172.22.1.0/24 –gateway 172.22.1.1 my_net3</li></ul><h3 id="设置主机名和DNS"><a href="#设置主机名和DNS" class="headerlink" title="设置主机名和DNS"></a>设置主机名和DNS</h3><p>docker run -it –name mycon -h lion –dns=8.8.8.8 ubuntu:14.04</p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="2020/11/30/docker%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/30/docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Docker提供了一种将应用程序安全，隔离运行的一种方式，能够将应用程序依赖和库文件打包在一个容器中，后续再任何地方运行起来即可，其包含了应用程序所依赖相关环境，一次构建，任意运行（build once，run anywhere）</p><h2 id="Docker-包括三个基本概念"><a href="#Docker-包括三个基本概念" class="headerlink" title="Docker 包括三个基本概念"></a>Docker 包括三个基本概念</h2><ul><li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。<br>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li></ul><p>Docker容器通过Docker镜像来创建。</p><h2 id="Docker原理"><a href="#Docker原理" class="headerlink" title="Docker原理"></a>Docker原理</h2><img src="/2020/11/30/docker%E5%9F%BA%E7%A1%80/6d20ecb467fa6d571d7dd74fe0187f07.png" alt="docker架构" style="zoom: 50%;"><table><thead><tr><th align="left">概念</th><th>说明</th></tr></thead><tbody><tr><td align="left">Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td align="left">Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td align="left">Docker Daemon</td><td>容器管理组件，守护进程，负载容器，镜像，存储，网络等管理</td></tr><tr><td align="left">Docker 客户端(Client)</td><td>Docker客户端通过命令行或者其他工具使用 <a href="https://docs.docker.com/develop/sdk/">Docker SDK </a> 与Docker的守护进程（Docker Daemon）通信</td></tr><tr><td align="left">Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="left">Docker Registry</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。容器镜像仓库，负责存储，分发，打包</td></tr><tr><td align="left">Docker Object</td><td>容器对象，主要包含container和images</td></tr><tr><td align="left">Docker Machine</td><td>是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，<br>比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr><tr><td align="left">docker swarm</td><td>Swarm 集群中每台 Docker 主机称为一个节点。集群管理，容器编排项目</td></tr><tr><td align="left">docker compose</td><td>容器编排项目，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具</td></tr></tbody></table><p><a href="https://hub.docker.com/">Docker Hub</a> 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><h2 id="容器优缺点"><a href="#容器优缺点" class="headerlink" title="容器优缺点"></a>容器优缺点</h2><p>容器给应用程序开发环境带来很大的便利，从根本上解决了容器的环境依赖，打包等问题，然而，Docker带来的容器打包的便利，同时也带来了以下的挑战：</p><ul><li><p>容器如何调度，分发</p></li><li><p>多台机器如何协同工作</p></li><li><p>Docker主机故障时应用如何恢复</p></li><li><p>如何保障应用高可用，横向扩展，动态伸缩</p></li></ul><img src="/2020/11/30/docker%E5%9F%BA%E7%A1%80/875f955cc9bb7b51036b58e59a2763bb.png" alt="容器挑战" style="zoom:50%;"><h2 id="docker容器命令"><a href="#docker容器命令" class="headerlink" title="docker容器命令"></a>docker容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -q </span><br><span class="line">docker container stop|start|rm nginx</span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx-test -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it nginx sh|bash</span><br></pre></td></tr></table></figure><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p><a href="https://www.runoob.com/docker/docker-dockerfile.html" title="dockerfile描述文件细节">如何写dockerfile文件</a></p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>容器编排工具 <a href="https://www.runoob.com/docker/docker-compose.html" title="docker-compose描述文件细节">如何写docker-compose.yml</a></p><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d //后台运行</span><br><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h2 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker swarm"></a>docker swarm</h2><p>Swarm 集群中每台 Docker 主机称为一个节点。其中主动初始化一个 Swarm 集群的节点称为管理节点（Manager），加入一个Swarm 集群的节点称为工作节点（Worker Node）。工作节点是任务执行节点，管理节点将任务下发至工作节点执行。管理节点默认也作为工作节点。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader</p><p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p><p>swarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。<br>work node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</p><h4 id="基本实用命令"><a href="#基本实用命令" class="headerlink" title="基本实用命令"></a>基本实用命令</h4><ul><li>docker swarm init –advertise-addr 192.168.58.144</li><li>docker swarm join 。。。</li><li>docker swarm leave –f</li><li>docker node ls</li><li>docker node ls –filter role=worker</li><li>docker node ls –filter role=manager</li><li>docker node update swarm02 –role=worker //将swarm02节点降级为worker节点</li><li>docker service inspect mynginx</li><li>docker service create –replicas 3 -p 8888:80 –name mynginx nginx</li><li>docker service rm mynginx</li><li>docker stack rm getstartedlab</li><li>docker stack deploy -c docker-compose.yml getstartedlab</li></ul><h4 id="docker-service"><a href="#docker-service" class="headerlink" title="docker service"></a>docker service</h4><p>与docker swarm一起使用，docker service部署的是单个服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 3 -p 8888:80 --name mynginx nginx</span><br></pre></td></tr></table></figure><h4 id="Docker-Stack"><a href="#Docker-Stack" class="headerlink" title="Docker Stack"></a>Docker Stack</h4><p>与docker swarm一起使用，使用docker-compose.yml配置文件，进行多服务编排部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stack  deploy -c docker-compose1.yml phpadmin</span><br><span class="line"></span><br><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure><h4 id="Swarm-Service网络模型"><a href="#Swarm-Service网络模型" class="headerlink" title="Swarm Service网络模型"></a>Swarm Service网络模型</h4><ul><li><strong>Overlay networks</strong> 管理 Swarm 中 Docker 守护进程间的通信。你可以将服务附加到一个或多个已存在的 overlay 网络上，使得服务与服务之间能够通信。</li><li><strong>ingress network</strong> 是一个特殊的 overlay 网络，用于服务节点间的负载均衡。当任何 Swarm 节点在发布的端口上接收到请求时，它将该请求交给一个名为 IPVS 的模块。IPVS 跟踪参与该服务的所有IP地址，选择其中的一个，并通过 ingress 网络将请求路由到它。<br>初始化或加入 Swarm 集群时会自动创建 ingress 网络，大多数情况下，用户不需要自定义配置，但是 docker 17.05 和更高版本允许你自定义。</li><li><strong>docker_gwbridge</strong>是一种桥接网络，将 overlay 网络（包括 ingress 网络）连接到一个单独的 Docker 守护进程的物理网络。默认情况下，服务正在运行的每个容器都连接到本地 Docker 守护进程主机的 docker_gwbridge 网络。<br>docker_gwbridge 网络在初始化或加入 Swarm 时自动创建。大多数情况下，用户不需要自定义配置，但是 Docker 允许自定义。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create</span><br><span class="line">docker network connect</span><br><span class="line">docker network ls</span><br><span class="line">docker network rm</span><br><span class="line">docker network disconnect</span><br><span class="line">docker network inspect</span><br><span class="line">docker run --rm --network=host alpine ifconfig</span><br></pre></td></tr></table></figure><h4 id="swarm编排工具的控制台docker-portainer"><a href="#swarm编排工具的控制台docker-portainer" class="headerlink" title="swarm编排工具的控制台docker portainer"></a>swarm编排工具的控制台docker portainer</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--constraint &#x27;node.role == manager&#x27; \</span><br><span class="line">--mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><h2 id="docker-compose与docker-swarm区别"><a href="#docker-compose与docker-swarm区别" class="headerlink" title="docker compose与docker swarm区别"></a>docker compose与docker swarm区别</h2><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合</p><h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>创建Docker主机（开放远程2375端口 安装docker）</p><ul><li>docker-machine create -d hyperv –hyperv-virtual-switch “myswitch” myvm2</li><li>docker-machine env myvm3</li><li>docker-machine ssh myvm1</li><li>docker-machine ls</li><li>docker-machine stop</li><li>docker-machine start</li><li>docker-machine env</li><li>docker-machine regenerate-certs</li></ul><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基础</title>
      <link href="2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>消息队列可以实现流量削峰、降低系统耦合度、提高系统性能等。</p><p><strong>RabbitMQ</strong>是一个实现了AMQP协议（Advanced Message Queue Protocol）的消息队列。</p><h2 id="RabbitMQ中的概念"><a href="#RabbitMQ中的概念" class="headerlink" title="RabbitMQ中的概念"></a><strong>RabbitMQ中的概念</strong></h2><ul><li><strong>producer</strong>： producer 是一个发送消息的应用</li><li><strong>exchange</strong>：producer并不会直接将消息发送到 queue 上，而是将消息发送给exchange，由exchange按照一定规则转发给指定queue</li><li><strong>queue</strong>： queue 用来存储 producer 发送的消息</li><li><strong>consumer</strong>： consumer是接收并处理消息的应用</li><li><strong>routing key</strong>：发送消息时绑定的路由key</li><li><strong>binding key</strong>：队列与交换机绑定的key</li><li><strong>consumerTag</strong>: 消费者标签，同一个会话， consumerTag 是固定的 可以做此会话的名字。</li><li><strong>consumer</strong>：消费者，extends DefaultConsumer。一个channel上可以配置多个consumer，真正的接收消息类，有处理消息的方法</li><li><strong>Envelope</strong>：可以获取交换机及routingKey信息和deliveryTag</li><li><strong>deliveryTag</strong>： deliveryTag 每次接收消息+1，可以做此消息处理通道的名字。用来回传告诉 rabbitmq 这个消息处理成功 清除此消息</li><li><strong>BasicProperties</strong>：基本属性，如Header中的信息。</li><li><strong>Delivery</strong>：封装了Envelope，BasicProperties及字节数组消息</li></ul><h2 id="Exchanges交换机"><a href="#Exchanges交换机" class="headerlink" title="Exchanges交换机"></a>Exchanges交换机</h2><p><strong>默认Exchange</strong>：比较Message的routing key和Queue的名字，完全匹配时，Message才会发送到该Queue<br><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/640" alt="img" style="zoom:80%;"><br><strong>Direct Exchange</strong>：比较Message的routing key和Queue的binding key，完全匹配时，Message才会发送到该Queue<br><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/2.gif" style="zoom:80%;"><br><strong>Fanout Exchange</strong>：忽略key对比，发送Message到Exchange下游绑定的所有Queue<br><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/1.gif" style="zoom: 80%;"><br><strong>Topic Exchange</strong>：比较Message的routing key和Queue的binding key，按规则匹配成功时，Message才会发送到该Queue</p><ul><li><strong>routing key命名规则</strong>：用”.”分割的字母或数字</li><li><strong>匹配规则</strong>：<ul><li>*：匹配单个字母或数字</li><li>#：匹配0~多个字母或数字</li><li>比如：*.stock.#与usd.stock、eur.stock.db匹配；但与stock.nasdaq不匹配<br><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/640" alt="img"></li></ul></li></ul><h2 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h2><p>存放消息</p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><ul><li>生产者指定Message的routing key，并指定Message发送到哪个Exchange</li><li>Queue会通过binding key绑定到指定的Exchange</li><li>Exchange根据对比Message的routing key和Queue的binding key，然后按一定的分发路由规则，决定Message发送到哪个Queue</li></ul><h2 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h2><p>​    监听指定队列，消息push到消费者端。spring的监听注解会自动创建不存在的交换机，队列，及绑定key。</p><h3 id="消息队列有两种工作方式"><a href="#消息队列有两种工作方式" class="headerlink" title="消息队列有两种工作方式"></a>消息队列有两种工作方式</h3><ul><li><p>轮询分发(默认)默认Spring是获取250个数据，RabbitMQ官方建议是30</p></li><li><p>公平分发即当某个消费者没有消费完成之前不用再分发消息。当执行时间增长的时候验证是否正确</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者每次从队列获取的消息数量。此属性当不设置时为：轮询分发，设置为1为：公平分发</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = &#123;@QueueBinding(value = @Queue(value = &quot;direct.queue&quot;), exchange = @Exchange(value = &quot;direct.exchange&quot;), key = &quot;HelloWorld&quot;)&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDirectMessage</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 模拟异常</span></span><br><span class="line">            String is = <span class="keyword">null</span>;</span><br><span class="line">            is.toString();</span><br><span class="line">            <span class="comment">// 确认收到消息，false只确认当前consumer一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已重复处理失败,拒绝再次接收&quot;</span> + user.getName());</span><br><span class="line">                <span class="comment">// 拒绝消息，requeue=false 表示不再重新入队，如果配置了死信队列则进入死信队列</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息即将再次返回队列处理&quot;</span> + user.getName());</span><br><span class="line">                <span class="comment">// requeue为是否重新回到队列，true重新入队</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDirectMessageCopy</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;--jxb--MQConsumer--getDirectMessageCopy：&quot;</span> + user.toString());</span><br><span class="line">            <span class="comment">// 确认收到消息，false只确认当前consumer一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已重复处理失败,拒绝再次接收！&quot;</span>);</span><br><span class="line">                <span class="comment">// 拒绝消息，requeue=false 表示不再重新入队，如果配置了死信队列则进入死信队列</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息即将再次返回队列处理！&quot;</span>);</span><br><span class="line">                <span class="comment">// requeue为是否重新回到队列，true重新入队</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h2><p>​    主动拉取队列里的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(ConnectionUtils.QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h2 id="基本AIPI"><a href="#基本AIPI" class="headerlink" title="基本AIPI"></a>基本AIPI</h2><p><strong>channel.exchangeDeclare()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type：有direct、fanout、topic三种</span><br><span class="line">durable：true：服务器重启会保留下来Exchange。警告：仅设置此选项，不代表消息持久化。即不保证重启后消息还在。</span><br><span class="line">autoDelete: true:当已经没有消费者时，服务器是否可以删除该Exchange。</span><br></pre></td></tr></table></figure><p><strong>chanel.exchangeBind()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);</span><br><span class="line">用于通过绑定bindingKey将queue到Exchange，之后便可以进行消息接收</span><br></pre></td></tr></table></figure><p><strong>channel.queueDeclare(QUEUE_NAME, false, false, false, null);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">durable：true：在服务器重启时，能够存活</span><br><span class="line">exclusive ：是否为当前连接的专用队列，在连接断开后，会自动删除该队列，生产环境中应该很少用到吧。</span><br><span class="line">autodelete：当没有任何消费者使用时，自动删除该队列。this means that the queue will be deleted when there are no more processes consuming messages from it.</span><br></pre></td></tr></table></figure><p><strong>chanel.basicQos()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prefetchSize：0 目前好像没有作用，至少rabbitmq3.8.5不能使用，报错</span><br><span class="line">prefetchCount：会告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack。是服务端属性，通过rpc方法调用，存在服务端，客户端不需要使用</span><br><span class="line">global：true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别的还是consumer级别。如果true并且prefetchCount为4，有二个消费者，此时每个消费者可以读取到二条。如果为fasle，每个消费者获取到4条数据</span><br></pre></td></tr></table></figure><p><strong>channel.basicPublish()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routingKey：路由键，#匹配0个或多个单词，*匹配一个单词，在topic exchange做消息转发用</span><br><span class="line">mandatory：true：如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue，那么会调用basic.return方法将消息返还给生产者。false：出现上述情形broker会直接将消息扔掉</span><br><span class="line">immediate：true：如果exchange在将消息route到queue(s)时发现对应的queue上没有消费者，那么这条消息不会放入队列中。当与消息routeKey关联的所有queue(一个或多个)都没有消费者时，该消息会通过basic.return方法返还给生产者。</span><br><span class="line">BasicProperties ：需要注意的是BasicProperties.deliveryMode，0:不持久化 1：持久化 这里指的是消息的持久化，配合channel(durable&#x3D;true),queue(durable)可以实现，即使服务器宕机，消息仍然保留</span><br><span class="line">简单来说：mandatory标志告诉服务器至少将该消息route到一个队列中，否则将消息返还给生产者；immediate标志告诉服务器如果该消息关联的queue上有消费者，则马上将消息投递给它，如果所有queue都没有消费者，直接把消息返还给生产者，不用将消息入队列等待消费者了。</span><br></pre></td></tr></table></figure><p><strong>channel.basicAck();</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息。</span><br></pre></td></tr></table></figure><p><strong>channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">multiple：是否批量.true:将一次性拒绝所有小于deliveryTag的消息。</span><br><span class="line">requeue：被拒绝的是否重新入队列</span><br></pre></td></tr></table></figure><p><strong>channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deliveryTag:该消息的index</span><br><span class="line">requeue：被拒绝的是否重新入队列</span><br><span class="line">channel.basicNack 与 channel.basicReject 的区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</span><br></pre></td></tr></table></figure><p><strong>channel.basicConsume(QUEUE_NAME, true, consumer);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</span><br></pre></td></tr></table></figure><p><strong>channel.basicGet(ConnectionUtils.QUEUE_NAME, false);</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><strong>Connection与Channel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createChannel();</span><br></pre></td></tr></table></figure><p>一个连接可以创建多个Channel</p><p><strong>Channel与消费者Consume</strong></p><p>一个Channel上可以设置多个Consume,因此可以设置最大值，Spring中通过设置concurrency和max-concurrency配置消费者个数</p><p><strong>prefetchSize、prefetchCount、Global</strong></p><p>spring中有prefetch即prefetchCount，batch-size。取最大值设置为prefetchCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue</span><br><span class="line"><span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">InternalConsumer consumer = <span class="keyword">new</span> InternalConsumer(<span class="keyword">this</span>.channel, queue);</span><br><span class="line">String consumerTag = <span class="keyword">this</span>.channel.basicConsume(queue, <span class="keyword">this</span>.acknowledgeMode.isAutoAck(),</span><br><span class="line">                                               (<span class="keyword">this</span>.tagStrategy != <span class="keyword">null</span> ? <span class="keyword">this</span>.tagStrategy.createConsumerTag(queue) : <span class="string">&quot;&quot;</span>), <span class="keyword">this</span>.noLocal,</span><br><span class="line">                                               <span class="keyword">this</span>.exclusive, <span class="keyword">this</span>.consumerArgs,</span><br><span class="line">                                               consumer);</span><br></pre></td></tr></table></figure><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="/2020/11/27/RabbitMQ%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（三）之数据结构总章</title>
      <link href="2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/"/>
      <url>2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><p>数组（数组、循环数组）查找、更新可以通过下标，时间复杂度为O(1);插入、删除需要移动数据在数组的位置O(n)</p><p><strong>基本操作</strong>：读取元素，更新元素，插入元素，删除元素（涉及数组元素移动位置，取巧方式：将最后一个元素更新删除元素）</p></li><li><p>链表（单向链表、双向链表、循环链表）查找需要一直向下查找，时间复杂度为O(n);插入、删除、更新指针变动即可O(1)</p><p><strong>基本操作</strong>：查找节点，更新节点，插入节点，删除节点</p><p><img src="/2020/11/25/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%AB%A0/image-20201201102615715.png" alt="image-20201201102615715"></p></li><li><p>栈（Stack）：FILO（First In Last Out，先入后出），最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作栈顶（top）。可以使用数组或链表来实现。时间复杂度都是O(1)</p><p><strong>基本操作</strong>：入栈push（从栈顶压入元素），出栈pop（从栈顶弹出元素）</p></li><li><p>队列（queue，单向队列，双端队列，优先队列，堵塞队列）：FIFO（First In First Out，先进先出），队列的出口端叫作队头（front），队列的入口端叫作队尾（rear）。可以使用数组或链表来实现。时间复杂度都是O(1)。数组实现队列会导致空间越来越小，可以使用循环数组。</p><p><strong>基本操作</strong>：入队enqueue（从队尾插入元素），出队dequeue（从对头移出元素）</p><table><thead><tr><th>对比项</th><th>作用及示例</th></tr></thead><tbody><tr><td>栈的应用</td><td>栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。<br>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。<br>栈还有一个著名的应用场景是面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面。</td></tr><tr><td>队列的应用</td><td>队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。<br>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。<br>再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的</td></tr></tbody></table><p><font color="red"><strong>双端队列（deque）</strong></font>：既可以先入先出，也可以先入后出。从队头一端可以入队或出队，从队尾一端也可以入队或出队</p><p><font color="red"><strong>优先队列</strong></font>：它遵循的不是先入先出，而是谁的优先级最高，谁先出队。优先队列已经<strong>不属于线性数据结构的范畴</strong>了，它是<strong>基于二叉堆来实现的</strong></p></li><li><p>散列表：也叫哈希表（Hash table），提供了键（Key）和值（Value）的映射关系,只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于O(1)。<font color="red">散列表可以说是数组和链表的结合。</font></p><p><strong>基本操作</strong>：写操作put,读操作get,扩容resize</p><p><strong>哈希冲突（哈希碰撞）</strong>解决方法：</p><p>​        <strong>开放寻址法</strong>：当一个Key通过哈希函数获得对应的数组下标已被占用时，我们可以“另谋高就”，寻找下一个空档位置，一直向下找。在Java中，ThreadLocal所使用的就是开放寻址法</p><p>​        <strong>链表法</strong>：应用在了Java的集合类HashMap当中，数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可</p></li><li><p>树（tree,二叉树、二叉查找树（排序树）、平衡二叉树、红黑树、B-树、B+树）是n（n≥0）个节点的有限集。当n=0时，称为空树。</p><p>树–&gt;二叉树–&gt;完全二叉树–&gt;满二叉树–&gt;二叉堆–&gt;二叉查找树（排序树）</p></li><li><p>图（？）</p></li></ul><h2 id="java数据结构"><a href="#java数据结构" class="headerlink" title="java数据结构"></a>java数据结构</h2><p>见java集合文章</p><h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序 存储，访问方式是随机访问。利用下标查找数组元素的时间复杂度是O(1)，中间插入、删除数组元素的时间复杂度是O(n)。 </p><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查找链表节点的时间 复杂度是O(n)，中间插入、删除节点的时间复杂度是O(1)。 </p><h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p>栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和 出栈操作，遵循先入后出的原则（FILO）。 </p><h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。 </p><h2 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h2><p>散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作。散列表通过哈希函数实现Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突</p><h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><p>树是n个节点的有限集，有且仅有一个特定的称为根的节点。当n&gt;1时，其余节点可分为m个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 </p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点。二叉树包含完全二叉树和满二叉树两种特殊形式。 </p><h2 id="二叉树的遍历方式有几种"><a href="#二叉树的遍历方式有几种" class="headerlink" title="二叉树的遍历方式有几种"></a>二叉树的遍历方式有几种</h2><p>根据遍历节点之间的关系，可以分为前序遍历、中序遍历、后序遍历、层序遍历这4种方式；从更宏观的角度划分，可以划分为深度优先遍历和广度优先遍历两大类。</p><h2 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h2><p>二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。<br>在最大堆中，任何一个父节点的值，都大于或等于它左、右孩子节点的值。<br>在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的值。 </p><h2 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h2><p>优先队列分为最大优先队列和最小优先队列。<br>在最大优先队列中，无论入队顺序如何，当前最大的元素都会优先出队，这是基于最大堆实现的。<br>在最小优先队列中，无论入队顺序如何，当前最小的元素都会优先出队，这是基于最小堆实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（二）</title>
      <link href="2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211111476.png" alt="img" style="zoom: 67%;"><h2 id="数据结构内容"><a href="#数据结构内容" class="headerlink" title="数据结构内容"></a>数据结构内容</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211129378.png" alt="img" style="zoom: 67%;"><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/201901212111451.png" alt="img" style="zoom: 67%;"><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201124212642358.png" alt="image-20201124212642358" style="zoom:50%;"><h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><p>大多数以数组和链表作为存储方式，因此物理结构为：</p><ul><li>顺序存储结构 （一段连续的内存空间。随机访问效率高；插入删除效率低，大小固定，可以扩容）</li><li>链式存储结构（不连续的内存空间。大小动态扩展，插入删除效率高；不能随机访问）</li><li>散列存储结构（为了方便查找，整体无序，但索引块之间有序，需要额外空间，存储索引表。对顺序查找的一种改进，查找效率高；需额外空间存储索引）</li><li>索引存储结构（选取某个函数，数据元素根据函数计算存储位置可能存在多个数据元素存储在同一位置，引起地址冲。查找基于数据本身即可找到，查找效率高，存取效率高。存取随机，不便于顺序查找）</li></ul><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是抽象的概念，它依赖于物理结构而存在。是对数据元素之间存在的逻辑关系的描述。分为二大类：线性结构和非线性结构。细分为四种：</p><ul><li><p>线性结构（线性结构中的数据元素之间是一对一的关系。注意：<font color="red">重点在一对一</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103023829.png" alt="image-20201125103023829" style="zoom: 33%;"></li><li><p>集合结构（就是数据元素同属一个集合，单个数据元素之间<font color="red">没有任何关系</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125102951179.png" alt="image-20201125102951179" style="zoom: 33%;"></li><li><p>树形结构（树形结构中的数据元素之间存在一对多的关系。各元素及元素关系所组成图形类似于树状图。注意：<font color="red">关系为一对多</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103039123.png" alt="image-20201125103039123" style="zoom: 33%;"></li><li><p>图形结构（数据元素之间是<font color="red">多对多的关系</font>）</p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20201125103056213.png" alt="image-20201125103056213" style="zoom: 33%;"></li></ul><p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211307827.png" alt="img"></p><p><img src="/2020/11/24/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/20190121211350180.png" alt="img"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_39385118/article/details/80835048">数据结构之逻辑结构与物理结构（存储结构）</a></p><p><a href="https://blog.csdn.net/qq_41523096/article/details/86566982">《数据结构》| 第一章 绪论 知识梳理</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（一）</title>
      <link href="2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>在数学领域里，算法是用于解决某一类问题的公式和思想。</li><li>在计算机科学领域，算法的本质是一系列程序指令，用于解决特定的运算和逻辑问题。是对特定问题求解方法（步骤）的一种描述，是指令的有限序列，其中每一条指令表示一个或多个操作。</li></ul><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125100745940.png" alt="image-20201125100745940"></p><h2 id="算法的设计目标"><a href="#算法的设计目标" class="headerlink" title="算法的设计目标"></a>算法的设计目标</h2><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125101019149.png" alt="image-20201125101019149"></p><h2 id="算法标准"><a href="#算法标准" class="headerlink" title="算法标准"></a>算法标准</h2><p>在计算机领域，我们同样会遇到各种高效和拙劣的算法。衡量算法好坏的重要标准有两个。 </p><ul><li>时间复杂度</li><li>空间复杂度</li></ul><h2 id="算法的应用领域"><a href="#算法的应用领域" class="headerlink" title="算法的应用领域"></a>算法的应用领域</h2><p>算法可以应用在很多不同的领域中，其应用场景更是多种多样。</p><ul><li>运算（如最大公约数）</li><li>查找（搜索引擎，Mysql查询）</li><li>排序（电商商品排序，排名）。排序算法是实现诸多复杂程序的基石</li><li>最优决策（如找出最佳路线，有限背包存价值最高物品使用动态规划算法）</li><li>面试（主要时为了它，不然学它干嘛）</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构，对应的英文单词是data structure，是数据的组织、管理和存储格式， 其使用目的是为了高效地访问和修改数据。</p><h2 id="数据结构组成方式"><a href="#数据结构组成方式" class="headerlink" title="数据结构组成方式"></a>数据结构组成方式</h2><ul><li>线性结构（最简单的数据结构，包含数组，链表及由它们衍生的栈、队列、哈希表）</li><li>树（树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构）</li><li>图（图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系）</li><li>其他数据结构（除上述基本数据结构外，还有其它千奇百怪的数据结构。由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等）</li></ul><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>有了数据结构这个舞台，算法才可以尽情舞蹈。在解决问题时，不同的算法会选用不同的数据结构。例如排序算法中的堆排序，利用的就是二叉堆这样一种数据结构；再如缓存淘汰算法LRU（Least Recently Used，最近最少使用），利用的就是特殊数据结构哈希链表。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>基本操作执行次数的函数T(n),若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。 <font color="red">因为渐进时间复杂度用大写O来表示，所以也被称为大O表示法。</font> </p><p>直白地讲，时间复杂度就是把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是n、n2、n3等。</p><p>时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作T(n)=O(f(n))。</p><p><img src="/2020/11/23/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20201125101210140.png" alt="image-20201125101210140"></p><h2 id="推导出时间复杂度原则"><a href="#推导出时间复杂度原则" class="headerlink" title="推导出时间复杂度原则"></a>推导出时间复杂度原则</h2><ul><li><p>如果运行时间是常数量级，则用常数1表示 </p></li><li><p>只保留时间函数中的最高阶项 </p></li><li><p>如果最高阶项存在，则省去最高阶项前面的系数</p></li></ul><h2 id="不同时间复杂度"><a href="#不同时间复杂度" class="headerlink" title="不同时间复杂度"></a>不同时间复杂度</h2><ul><li><p>多项式时间算法的时间复杂度：O(1)&lt;O(log<del>2</del>n)&lt;O(n)&lt;O(nlog<del>2</del>n)&lt;O(n^2^) &lt;O(n^3^)</p></li><li><p>指数时间算法的时间复杂度：O(2^n^)&lt;O(n!)&lt;O(n^n^)</p></li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中<font color="red"><strong>临时占用存储空间大小的量度</strong></font>，它同样使用了大O表示法。程序占用空间大小的计算公式记作S(n)=O(f(n))，其中n为问题的规模，f(n)为算法所占存储空间的函数。 <font color="red">空间复杂度就离不开数据结构。</font></p><h2 id="不同空间复杂度"><a href="#不同空间复杂度" class="headerlink" title="不同空间复杂度"></a>不同空间复杂度</h2><ul><li><p>常量空间（当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1)）</p></li><li><p>线性空间（当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];&#125;</span><br></pre></td></tr></table></figure></li><li><p>二维空间（当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n^2^)）</p></li><li><p>递归空间（递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。空间复杂度就是O(n)）</p></li></ul><h2 id="时间与空间的取舍"><a href="#时间与空间的取舍" class="headerlink" title="时间与空间的取舍"></a>时间与空间的取舍</h2><p>在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间，也要提升程序的执行速度。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataSource介绍及对比</title>
      <link href="2020/11/23/DataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/"/>
      <url>2020/11/23/DataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>DriverManager通过getConnection方法获取的连接，<font color="red">是建立与数据库的连接</font>。但是建立与数据库的连接是一项较耗资源的工作，频繁的进行数据库连接建立操作会产生较大的系统开销。</p><p>随着企业级应用复杂度的提升以及对性能要求的提高，这一点是难以接受的。</p><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p><strong>既然每次使用时都重新建立与数据库之间的连接，会产生较大的系统开销。是否可以事先创建一些连接备用，当需要时，从这些连接中选择一个提供出去；当连接使用完毕后，并不是真正的关闭，而是将这些数据状态还原，然后继续等待下一个人使用</strong></p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>DriverManager只是建立与数据库之间的连接，如何才能将连接池的概念应用其中？</p><p><strong>一种很自然的方式就是提供一个薄层的封装，建立一个中间层，这个中间层将DriverManager生成的连接，组织到连接池中，然后从池中提供连接</strong></p><p><img src="/2020/11/23/DataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/897393-20190125140250476-31357459.png" alt="img"></p><p><strong>Data Source就是DriverManager的一种替代角色，对外呈现就类似于一个DriverManager，拥有对外提供连接的能力</strong></p><p>直接使用DriverManager，驱动程序与管理器是“服务者—管理者”的形式，借助于管理者才能提供服务。</p><p>Data Source将驱动程序的概念淡化了，突出驱动程序能够提供的服务与能力，将驱动程序提供的服务与能力抽象为Data Source数据源这一角色。</p><p><img src="/2020/11/23/DataSource%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94/897393-20190125140251236-665240055.png" alt="img"></p><p><strong>DataSource中获取的连接来自于连接池中，而池中的连接根本也还是从DriverManager获取而来</strong></p><p>有了数据源这一中间层，就可以实现连接池和分布式事务的管理。</p><p><strong>对外呈现DataSource就是类似于DriverManager的一个存在。</strong></p><p><strong>DataSource的形式是JNDI （Java Naming Directory Interface）</strong></p><p>DataSource是JNDI资源的一种，那么到底什么是JNDI呢</p><p>此处不过多解释，可以简单认为JNDI是类似这样一个东西：</p><p>一个哈希表，类型为&lt;String，Object&gt;</p><p>JNDI的两个最主要操作：bind和lookup。bind操作负责往哈希表里存对象，lookup则根据这个键值字符串往外取对象。</p><p>开发人员可以使用键值——也就是一个字符串名称——来获取某个对象。</p><p><strong>简言之就是可以给一个对象命名，然后可以通过名称找到这个对象。</strong></p><p><strong>数据源的概念在应用程序与数据库连接之间插入了一个中间层，进而可以实现连接池以及事务管理，并且以JNDI的形式，也能够以非常方便的形式使用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> DataSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC原理分析</title>
      <link href="2020/11/20/JDBC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>2020/11/20/JDBC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JDBC（Java Database Connection）,java提供的一套操作数据库的api。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><strong>java.sql包主要接口</strong></p><ul><li>DriverManager ：驱动管理，可以加载驱动，获取Connection（通过Driver），高版本自动加载驱动Driver</li><li>Driver ：获取Connection</li><li>Connection: 创建Statement </li><li>Statement: Statement为一条Sql语句生成执行计划</li><li>PreparedStatement: 预编译sql语句，更安全，字符串参数会自动被驱动器忽略；PreparedStatement用于使用绑定变量重用执行计划，对于批量处理可以大大提高效率，但是如果是一次性存取操作性能开销更大。</li><li>ResultSet：Statement调用执行方法返回的结果</li><li><font color="red">Warapper</font>: 重点，<strong>适配器类</strong>，提供的扩展接口，方法unwrap返回未适配的对象， 方法isWrapperFor返回是否适配 。Connetion，Statement，ResultSet都继承Warapper接口。把一个由第三方供应商提供的、非 JDBC 标准的接口包装成标准接口</li></ul><p><strong>javax.sql包主要接口</strong></p><ul><li>DataSource：基本数据源接口，返回普通Connection</li><li>ConnectionPoolDataSource：连接池数据源接口，返回连接池连接（PooledConnection）</li><li>XADataSource：XA事务数据源，分布式事务，返回XA事务连接池连接（XAConnection 继承PooledConnection）</li><li>PooledConnection：连接池连接</li><li>XAConnection：XA事务连接池连接</li><li>RowSet：继承ResultSet</li><li>RowSetEvent，RowSetListener</li><li>StatementEvent,StatementEventListener</li><li>ConnectionEvent,ConnectionEventListener</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Driver loaded&quot;</span>);</span><br><span class="line">        Connection connection = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost/javabook&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Databases connected&quot;</span>);</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(</span><br><span class="line">                <span class="string">&quot;select ?, ?, ? from Student where lastName = ?&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;firstName&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, <span class="string">&quot;mi&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">3</span>, <span class="string">&quot;lastName&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">4</span>, <span class="string">&quot;Smith&quot;</span>);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="number">1</span>) + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                    resultSet.getString(<span class="number">2</span>) + <span class="string">&quot;\t&quot;</span> + resultSet.getString(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> DataSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java获取ip地址</title>
      <link href="2020/11/19/java%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80/"/>
      <url>2020/11/19/java%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="获取服务器本地ip"><a href="#获取服务器本地ip" class="headerlink" title="获取服务器本地ip"></a>获取服务器本地ip</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getHostAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String hostAddress = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">      hostAddress = address.getHostAddress();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hostAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Enumeration&lt;NetworkInterface&gt; allNetInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">      InetAddress ip = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (allNetInterfaces.hasMoreElements()) &#123;</span><br><span class="line">        NetworkInterface netInterface = allNetInterfaces.nextElement();</span><br><span class="line">        <span class="keyword">if</span> (netInterface.isLoopback() || netInterface.isVirtual() || !netInterface.isUp()) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Enumeration&lt;InetAddress&gt; addresses = netInterface.getInetAddresses();</span><br><span class="line">        <span class="keyword">while</span> (addresses.hasMoreElements()) &#123;</span><br><span class="line">          ip = addresses.nextElement();</span><br><span class="line">          <span class="keyword">if</span> (ip != <span class="keyword">null</span> &amp;&amp; ip <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">            <span class="keyword">return</span> ip.getHostAddress();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;IP地址获取失败&quot;</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取http请求的ip地址"><a href="#获取http请求的ip地址" class="headerlink" title="获取http请求的ip地址"></a>获取http请求的ip地址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIpAddr</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String ipAddress = request.getHeader(<span class="string">&quot;x-forwarded-for&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">      ipAddress = request.getRemoteAddr();</span><br><span class="line">      <span class="keyword">if</span> (ipAddress.equals(<span class="string">&quot;127.0.0.1&quot;</span>) || ipAddress.equals(<span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//根据网卡取本机配置的IP</span></span><br><span class="line">        InetAddress inet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inet = InetAddress.getLocalHost();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ipAddress = inet.getHostAddress();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割</span></span><br><span class="line">    <span class="keyword">if</span> (ipAddress != <span class="keyword">null</span> &amp;&amp; ipAddress.length() &gt; <span class="number">15</span>) &#123; <span class="comment">//&quot;***.***.***.***&quot;.length() = 15</span></span><br><span class="line">      <span class="keyword">if</span> (ipAddress.indexOf(<span class="string">&quot;,&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipAddress = ipAddress.substring(<span class="number">0</span>, ipAddress.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ipAddress;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon自定义负载规则</title>
      <link href="2020/11/19/Ribbon%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99/"/>
      <url>2020/11/19/Ribbon%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="配置Ribbon，指定每个服务使用的配置"><a href="#配置Ribbon，指定每个服务使用的配置" class="headerlink" title="配置Ribbon，指定每个服务使用的配置"></a>配置Ribbon，指定每个服务使用的配置</h2><p>java注解方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(value = &#123;</span></span><br><span class="line"><span class="meta">    @RibbonClient(name = &quot;order-service&quot;,configuration = RibbonLoadbalancerConfiguration.class)</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">,defaultConfiguration = RibbonLoadbalancerConfiguration.class)</span></span><br></pre></td></tr></table></figure><p>也可以使用配置文件，相比java配置，优先级更高</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">order-service:</span> <span class="comment">#指定服务配置</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NIWSServerListClass:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span> <span class="comment">#指定ServerList的实现类</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#指定IRule的实现类</span></span><br><span class="line"><span class="attr">ribbon:</span> <span class="comment">#全局配置</span></span><br><span class="line"><span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">RibbonLoadbalancerConfiguration</span> <span class="comment">#指定IRule的实现类</span></span><br></pre></td></tr></table></figure><h2 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeRibbonRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">        <span class="comment">// 获取所有的服务</span></span><br><span class="line">        List&lt;Server&gt; servers = lb.getAllServers();</span><br><span class="line">        servers.forEach(server -&gt; logger.info(<span class="string">&quot;服务器端口号：&#123;&#125;&quot;</span>,server.getHostPort()));</span><br><span class="line">        String host = getIpAddress(); <span class="comment">//本机ip</span></span><br><span class="line">        <span class="keyword">return</span> servers.stream().filter(server -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> server.getHost().equals(host);</span><br><span class="line">        &#125;).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora高亮及快捷键设置</title>
      <link href="2020/11/19/typora%E9%AB%98%E4%BA%AE%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE/"/>
      <url>2020/11/19/typora%E9%AB%98%E4%BA%AE%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Typora的高亮模式默认是关闭的（需手动打开）"><a href="#1、Typora的高亮模式默认是关闭的（需手动打开）" class="headerlink" title="1、Typora的高亮模式默认是关闭的（需手动打开）"></a>1、Typora的高亮模式默认是关闭的（需手动打开）</h2><p>打开方式：文件 &gt; 偏好设置 &gt; Markdown &gt; Markdown扩展语法中把 <strong>高亮</strong> 选中 &gt; <strong>重启Typora</strong><br><img src="https://img-blog.csdnimg.cn/20200920101054257.gif#pic_left" alt="在这里插入图片描述"></p><h2 id="2、如何更改高亮配色？（高亮默认颜色是黄色-D3D40E）"><a href="#2、如何更改高亮配色？（高亮默认颜色是黄色-D3D40E）" class="headerlink" title="2、如何更改高亮配色？（高亮默认颜色是黄色#D3D40E）"></a>2、如何更改高亮配色？（高亮默认颜色是黄色#D3D40E）</h2><p>打开方式：文件 &gt; 偏好设置 &gt; 外观 &gt; 打开主题文件夹 &gt; <em>night.css</em>文件 &gt; Ctrl+F 搜索 mark &gt; 修改喜欢的 background(背景颜色) 和 color(字体颜色) 保存<br><img src="https://img-blog.csdnimg.cn/20200920104332324.gif#pic_left" alt="在这里插入图片描述"></p><h2 id="3、如何设置高亮快捷键"><a href="#3、如何设置高亮快捷键" class="headerlink" title="3、如何设置高亮快捷键"></a>3、如何设置高亮快捷键</h2><p>设置方式：文件 &gt; 偏好设置 &gt; 通用 &gt; 打开高级设置 &gt; 会看到两个<em>json</em>文件，打开其中一个 &gt; 在 “keyBinding” 中添加 <strong>“Highlight”:“Ctrl+Shift+H”</strong>&gt; 保存 &gt; 另一个json文件也在 “keyBinding” 中添加 <strong>“Highlight”:“Ctrl+Shift+H”</strong> &gt; 保存<br><img src="https://img-blog.csdnimg.cn/20200920110453114.gif#pic_left" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora字体设置颜色</title>
      <link href="2020/11/19/typora%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/"/>
      <url>2020/11/19/typora%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://ispotu.blog.csdn.net/">ispotu</a></p><p>出处：<a href="https://blog.csdn.net/superit401/article/details/106344453/">https://blog.csdn.net/superit401/article/details/106344453/</a></p><p>typora没有直接设置字体颜色的功能，不能像word一样，选中字体直接设置想要的颜色。</p><p>下面第一种方法需安装软件AutoHotKey，操作还算简单；后两种方法都是偏技术的，对于非技术的小白可能有点困难。</p><h2 id="方案一：安装软件AutoHotKey（较简单）"><a href="#方案一：安装软件AutoHotKey（较简单）" class="headerlink" title="方案一：安装软件AutoHotKey（较简单）"></a>方案一：安装软件AutoHotKey（较简单）</h2><p>AutoHotKey是一款著名的windows系统快捷键设置的软件，轻便小巧。</p><p>官方下载: <a href="https://autohotkey.com/download/ahk-install.exe">https://autohotkey.com/download/ahk-install.exe</a></p><p> （1）先安装AutoHotKey</p><p>（2）打开记事本，把如下内容复制粘贴进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; Typora</span><br><span class="line">; 快捷增加字体颜色</span><br><span class="line">; SendInput &#123;Text&#125; 解决中文输入法问题</span><br><span class="line"></span><br><span class="line">#IfWinActive ahk_exe Typora.exe&#123;</span><br><span class="line">    ; Ctrl+Alt+O 橙色</span><br><span class="line">    ^!o::addFontColor(&quot;orange&quot;)</span><br><span class="line">    ; Ctrl+Alt+R 红色</span><br><span class="line">    ^!r::addFontColor(&quot;red&quot;)</span><br><span class="line">    ; Ctrl+Alt+B 浅蓝色</span><br><span class="line">    ^!b::addFontColor(&quot;cornflowerblue&quot;)</span><br><span class="line">&#125;</span><br><span class="line">; 快捷增加字体颜色</span><br><span class="line">addFontColor(color)&#123;</span><br><span class="line">    clipboard :&#x3D; &quot;&quot; ; 清空剪切板</span><br><span class="line">    Send &#123;ctrl down&#125;c&#123;ctrl up&#125; ; 复制</span><br><span class="line">    SendInput &#123;TEXT&#125;&lt;font color&#x3D;&#39;%color%&#39;&gt;</span><br><span class="line">    SendInput &#123;ctrl down&#125;v&#123;ctrl up&#125; ; 粘贴</span><br><span class="line">    If(clipboard &#x3D; &quot;&quot;)&#123;</span><br><span class="line">        SendInput &#123;TEXT&#125;&lt;&#x2F;font&gt; ; Typora 在这不会自动补充</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        SendInput &#123;TEXT&#125;&lt;&#x2F; ; Typora中自动补全标签</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）将文件保存为ahk后缀的文件，如TyporaHotKey.ahk</p><p>(4)双击运行</p><p>（5）在Typora软件里就可以使用快捷键：如按<code>Ctrl+Alt+O</code>添加橙色，Ctrl+Alt+R 红色，按<code>Ctrl+\</code>取消样式！</p><p>也可以右键 <code>MyHotkeyScript.ahk</code> 脚本文件，点击<code>Compile Script</code>编译脚本成<code>exe</code>程序，就可以不用下载<code>Autohotkey</code>在其他电脑上运行了。</p><p>上面脚本只写了橙色、红色、浅蓝三种颜色，你可以按需照例增加其他颜色或快捷方式！</p><h2 id="方案二：改html代码（懂前端技术超简单）"><a href="#方案二：改html代码（懂前端技术超简单）" class="headerlink" title="方案二：改html代码（懂前端技术超简单）"></a>方案二：改html代码（懂前端技术超简单）</h2><p>视图——开发者工具（Shift+F12），打开html代码调试模式</p><p> 按快捷键Shift+F12（可能还需要同时按住Fn）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;&quot;</span>&gt;</span>你要改色的文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照这个模板，改字体的style属性即可。</p><p>示例：</p><p>style=”color:red”</p><p>style=”color:maroon”</p><p>style=”color:fuchsia”</p><p>style=”color:brown”</p><p>style=”color:blue”</p><p>style=”color:aqua”</p><p>style=”color:green”</p><p>style=”color:orange”</p><p>style=”color:purple”</p><p>style=”color:white;background:black;”</p><p>style=”background:yellow”</p><p>style=”background:red”</p><p>style=”background:orange”</p><p>style=”color:white;background:green”</p><p>style=”color:white;background:blue”</p><p><img src="https://img-blog.csdnimg.cn/20200525225939274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyaXQ0MDE=,size_16,color_FFFFFF,t_70" alt="img"></p><h1 id="方案三：使用内联公式（复杂）"><a href="#方案三：使用内联公式（复杂）" class="headerlink" title="方案三：使用内联公式（复杂）"></a>方案三：使用内联公式（复杂）</h1><p><strong>1.开启使用内联公式</strong></p><p>文件——偏好设置（Ctrl+逗号）——Markdown——勾选“内联公式”——重启Typora</p><p><img src="https://img-blog.csdnimg.cn/20200525230147618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyaXQ0MDE=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>2.输入公式代码设置颜色</strong></p><p>输入$，按Esc键会自动在后面加上一个$，然后在这两个$之间输入公式。</p><p>如：</p><p><img src="https://img-blog.csdnimg.cn/20200525231636600.png" alt="img"></p><p>直接在typora里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;Magenta&#125;&#123;洋红色&#125; $:设置颜色为$\textcolor&#123;RedOrange&#125;&#123;橙红色&#125; $，设置字体颜色为$\textcolor&#123;Blue&#125;&#123;蓝色&#125; $。数学公式里各元素也能分别设置颜色：</span><br><span class="line">$\textcolor&#123;red&#125;&#123;\int_a^b&#125;\textcolor&#123;blue&#125;&#123;f(x)&#125;\textcolor&#123;green&#125;&#123;dx&#125;\textcolor&#123;brown&#125;&#123;&#x3D;c&#125;$</span><br></pre></td></tr></table></figure><p>文本颜色设置公式：</p><p><font color="red"><strong>$\textcolor{red}{这里输入你要改变颜色的文字} $</strong></font></p><h3 id="颜色公式代码大全："><a href="#颜色公式代码大全：" class="headerlink" title="颜色公式代码大全："></a>颜色公式代码大全：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;GreenYellow&#125;&#123;GreenYellow&#125; $</span><br><span class="line">$\textcolor&#123;Yellow&#125;&#123;Yellow&#125;$</span><br><span class="line">$\textcolor&#123;Goldenrod&#125;&#123;Goldenrod&#125; $</span><br><span class="line">$\textcolor&#123;Dandelion&#125;&#123;Dandelion&#125;$</span><br><span class="line">$\textcolor&#123;Apricot&#125;&#123;Apricot&#125; $</span><br><span class="line">$\textcolor&#123;Peach&#125;&#123;Peach&#125;$</span><br><span class="line">$\textcolor&#123;Melon&#125;&#123;Melon&#125; $</span><br><span class="line">$\textcolor&#123;YellowOrange&#125;&#123;YellowOrange&#125;$</span><br><span class="line">$\textcolor&#123;Orange&#125;&#123;Orange&#125; $</span><br><span class="line">$\textcolor&#123;BurntOrange&#125;&#123;BurntOrange&#125;$</span><br><span class="line">$\textcolor&#123;Bittersweet&#125;&#123;Bittersweet&#125;$</span><br><span class="line">$\textcolor&#123;RedOrange&#125;&#123;RedOrange&#125; $</span><br><span class="line">$\textcolor&#123;Mahogany&#125;&#123;Mahogany&#125;$</span><br><span class="line">$\textcolor&#123;Maroon&#125;&#123;Maroon&#125; $</span><br><span class="line">$\textcolor&#123;BrickRed&#125;&#123;BrickRed&#125;$</span><br><span class="line">$\textcolor&#123;Red&#125;&#123;Red&#125; $</span><br><span class="line">$\textcolor&#123;OrangeRed&#125;&#123;OrangeRed&#125;$</span><br><span class="line">$\textcolor&#123;RubineRed&#125;&#123;RubineRed&#125;$</span><br><span class="line">$\textcolor&#123;WildStrawberry&#125;&#123;WildStrawberry&#125;$</span><br><span class="line">$\textcolor&#123;Salmon&#125;&#123;Salmon&#125;$</span><br><span class="line">$\textcolor&#123;CarnationPink&#125;&#123;CarnationPink&#125;$</span><br><span class="line">$\textcolor&#123;Magenta&#125;&#123;Magenta&#125; $</span><br><span class="line">$\textcolor&#123;VioletRed&#125;&#123;VioletRed&#125;$</span><br><span class="line">$\textcolor&#123;Rhodamine&#125;&#123;Rhodamine&#125; $</span><br><span class="line">$\textcolor&#123;Mulberry&#125;&#123;Mulberry&#125;$</span><br><span class="line">$\textcolor&#123;RedViolet&#125;&#123;RedViolet&#125; $</span><br><span class="line">$\textcolor&#123;Fuchsia&#125;&#123;Fuchsia&#125;$</span><br><span class="line">$\textcolor&#123;Lavender&#125;&#123;Lavender&#125; $</span><br><span class="line">$\textcolor&#123;Thistle&#125;&#123;Thistle&#125;$</span><br><span class="line">$\textcolor&#123;Orchid&#125;&#123;Orchid&#125; $</span><br><span class="line">$\textcolor&#123;DarkOrchid&#125;&#123;DarkOrchid&#125;$</span><br><span class="line">$\textcolor&#123;Purple&#125;&#123;Purple&#125; $</span><br><span class="line">$\textcolor&#123;Plum&#125;&#123;Plum&#125;$</span><br><span class="line">$\textcolor&#123;Violet&#125;&#123;Violet&#125; $</span><br><span class="line">$\textcolor&#123;RoyalPurple&#125;&#123;RoyalPurple&#125;$</span><br><span class="line">$\textcolor&#123;BlueViolet&#125;&#123;BlueViolet&#125;$</span><br><span class="line">$\textcolor&#123;Periwinkle&#125;&#123;Periwinkle&#125;$</span><br><span class="line">$\textcolor&#123;CadetBlue&#125;&#123;CadetBlue&#125;$</span><br><span class="line">$\textcolor&#123;CornflowerBlue&#125;&#123;CornflowerBlue&#125;$</span><br><span class="line">$\textcolor&#123;MidnightBlue&#125;&#123;MidnightBlue&#125;$</span><br><span class="line">$\textcolor&#123;NavyBlue&#125;&#123;NavyBlue&#125; $</span><br><span class="line">$\textcolor&#123;RoyalBlue&#125;&#123;RoyalBlue&#125;$</span><br><span class="line">$\textcolor&#123;Blue&#125;&#123;Blue&#125; $</span><br><span class="line">$\textcolor&#123;Cerulean&#125;&#123;Cerulean&#125;$</span><br><span class="line">$\textcolor&#123;Cyan&#125;&#123;Cyan&#125; $</span><br><span class="line">$\textcolor&#123;ProcessBlue&#125;&#123;ProcessBlue&#125;$</span><br><span class="line">$\textcolor&#123;SkyBlue&#125;&#123;SkyBlue&#125; $</span><br><span class="line">$\textcolor&#123;Turquoise&#125;&#123;Turquoise&#125;$</span><br><span class="line">$\textcolor&#123;TealBlue&#125;&#123;TealBlue&#125; $</span><br><span class="line">$\textcolor&#123;Aquamarine&#125;&#123;Aquamarine&#125;$</span><br><span class="line">$\textcolor&#123;BlueGreen&#125;&#123;BlueGreen&#125; $</span><br><span class="line">$\textcolor&#123;Emerald&#125;&#123;Emerald&#125;$</span><br><span class="line">$\textcolor&#123;JungleGreen&#125;&#123;JungleGreen&#125;$</span><br><span class="line">$\textcolor&#123;SeaGreen&#125;&#123;SeaGreen&#125; $</span><br><span class="line">$\textcolor&#123;Green&#125;&#123;Green&#125;$</span><br><span class="line">$\textcolor&#123;ForestGreen&#125;&#123;ForestGreen&#125;$</span><br><span class="line">$\textcolor&#123;PineGreen&#125;&#123;PineGreen&#125; $</span><br><span class="line">$\textcolor&#123;LimeGreen&#125;&#123;LimeGreen&#125;$</span><br><span class="line">$\textcolor&#123;YellowGreen&#125;&#123;YellowGreen&#125;$</span><br><span class="line">$\textcolor&#123;SpringGreen&#125;&#123;SpringGreen&#125;$</span><br><span class="line">$\textcolor&#123;OliveGreen&#125;&#123;OliveGreen&#125;$</span><br><span class="line">$\textcolor&#123;RawSienna&#125;&#123;RawSienna&#125; $</span><br><span class="line">$\textcolor&#123;Sepia&#125;&#123;Sepia&#125;$</span><br><span class="line">$\textcolor&#123;Brown&#125;&#123;Brown&#125; $</span><br><span class="line">$\textcolor&#123;Tan&#125;&#123;Tan&#125;$</span><br><span class="line">$\textcolor&#123;Gray&#125;&#123;Gray&#125; $</span><br><span class="line">$\textcolor&#123;Black&#125;&#123;Black&#125;$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用next主题</title>
      <link href="2020/11/17/hexo%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98/"/>
      <url>2020/11/17/hexo%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="主题next"><a href="#主题next" class="headerlink" title="主题next"></a>主题next</h2><p><strong>下载next主题</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p><strong>根据要求修改主题下_config.yml配置</strong></p><p><a href="https://theme-next.js.org/docs/theme-settings/">next文档</a></p><h2 id="更复杂的自定义优化可以参考如下文章"><a href="#更复杂的自定义优化可以参考如下文章" class="headerlink" title="更复杂的自定义优化可以参考如下文章"></a>更复杂的自定义优化可以参考如下文章</h2><p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">Hexo博客优化之Next主题美化</a></p><p><a href="https://theme-next.js.org/docs/tag-plugins/mermaid.html">可以生成图形</a></p><p><a href="https://www.cnblogs.com/whiremapple/p/12419097.html">Hexo博客主题安装和优化（一）</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql进阶操作</title>
      <link href="2020/11/17/mysql%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/17/mysql%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="转储操作"><a href="#转储操作" class="headerlink" title="转储操作"></a>转储操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE table t_a (SELECT * from o_order limit 10);</span><br><span class="line">INSERT into t_a SELECT *,5 FROM o_order limit 10;</span><br></pre></td></tr></table></figure><p><strong>区别</strong></p><ol><li>第一个sql执行的时候，表t_a不能存在</li><li>第二个sql执行时，表必须存在，可以设置指定常量字段即二个表字段有差异</li></ol><h2 id="插入操作（可忽略或更新已存在）"><a href="#插入操作（可忽略或更新已存在）" class="headerlink" title="插入操作（可忽略或更新已存在）"></a>插入操作（可忽略或更新已存在）</h2><p><strong>1. insert into</strong>表示插入数据，数据库会检查主键（PrimaryKey）或者unique索引，如果出现重复会报错；</p><p><strong>2. insert ignore into</strong> table(name)  select  name from table2; 根据主键（PrimaryKey）或者unique索引判断，如果已存在则忽略数据，否则插入数据</p><p><strong>3. replace into</strong>表示插入替换数据，需求表中有PrimaryKey，或者unique索引的话，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样；</p><p>REPLACE语句会返回一个数，来指示受影响的行的数目。该数是被删除和被插入的行数的和。如果对于一个单行REPLACE该数为1，则一行被插入，同时没有行被删除。<br>如果该数大于1，则在新行被插入前，有一个或多个旧行被删除。如果表包含多个唯一索引，并且新行复制了在不同的唯一索引中的不同旧行的值，则有可能是一个单一行替换了多个旧行</p><p><strong>4. insert into … ON DUPLICATE KEY UPDATE</strong></p><p><strong>如果你插入的记录导致一个UNIQUE索引或者primary key(主键)出现重复，那么就会认为该条记录存在，则执行update语句而不是insert语句，反之，则执行insert语句而不是更新语句</strong></p><p>如果行作为新记录被插入，则受影响行的值为1；如果原有的记录被更新，则受影响行的值为2，如果更新的数据和已有的数据一模一样，则受影响的行数是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table testtb(</span><br><span class="line">  id int not null primary key,</span><br><span class="line">  name varchar(50),</span><br><span class="line">  age int</span><br><span class="line">);</span><br><span class="line">insert into testtb(id,name,age)values(1,&quot;bb&quot;,13);</span><br><span class="line">select * from testtb;</span><br><span class="line">insert ignore into testtb(id,name,age)values(1,&quot;aa&quot;,13);</span><br><span class="line">select * from testtb;&#x2F;&#x2F;仍是1，“bb”,13，因为id是主键，出现主键重复但使用了ignore则错误被忽略</span><br><span class="line">replace into testtb(id,name,age)values(1,&quot;aa&quot;,12);</span><br><span class="line">select * from testtb; &#x2F;&#x2F;数据变为1,&quot;aa&quot;,12</span><br><span class="line">insert into testtb(id, name, age) values (1,&#39;hui&#39;,30) ON DUPLICATE KEY UPDATE age &#x3D; age + 50; </span><br><span class="line">select * from testtb; &#x2F;&#x2F;数据变成1,&quot;aa&quot;,62</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本操作</title>
      <link href="2020/11/17/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/17/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h2><p>是一个代码审查管理工具，可以进行代码走读，审核入库，基于Git</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>开发人员和管理人员只需操作gerrit 就能完成所有的代码管理，提高开发和上线效率</p><h2 id="用户组分类"><a href="#用户组分类" class="headerlink" title="用户组分类"></a>用户组分类</h2><ul><li>backend-developers</li><li>backend-leaders</li></ul><blockquote><p>backend-developers组用户权限：<br>1, master分支代码查看，push, review +1 -2, abandon 自己的review。<br>2，自己定义分支全部控制权限</p></blockquote><blockquote><p>backend-leaders组用户权限：<br>1 ,master分支代码查看，push, review +2 -2, abandon , submit,<br>2, release 分支代码查看，push,  review +2 , -2, abandon, push merge, push without review<br>3，自己定义分支全部控制权限</p></blockquote><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><ul><li>master分支</li><li>release分支</li><li>个人分支或者长期功能开发分支</li></ul><ol><li>master分支主要作为代码review, 代码开发主分支</li><li>release分支只对leaders可见，里面包含敏感的配置文件信息，release分支同时作为一个长期稳定的上线版本分支，每一次上线后都需要打一个tag</li><li>一般开发任务不需要在gerrit上创建自己的分支，除非有长期的协同大功能开发。</li></ol><h3 id="开发人员前期环境准备"><a href="#开发人员前期环境准备" class="headerlink" title="开发人员前期环境准备"></a>开发人员前期环境准备</h3><blockquote><p>这里假定大家对git 常用命令 已经熟悉，这里只做gerrit部分的设置步骤</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">假定developer有了gerrit账号并设置了免密ssh,登录gerrit ，</span><br><span class="line"></span><br><span class="line">1, 找到Projects-&gt;List-&gt;BKD_quixmart2 , 复制 项目clone命令：</span><br><span class="line">&gt; git clone ssh:&#x2F;&#x2F;xxxx@192.168.16.81:29418&#x2F;BKD_quixmart2 &amp;&amp; scp -p -P 29418 xxxx@192.168.16.81:hooks&#x2F;commit-msg BKD_quixmart2&#x2F;.git&#x2F;hooks&#x2F;</span><br><span class="line">&gt; cd BKD_quixmart2</span><br><span class="line">&gt; git remote update</span><br><span class="line"></span><br><span class="line">clone下来的项目普通开发人员只能看到一个master分支，leaders可以看到master 和 relase分支.</span><br><span class="line"></span><br><span class="line">2, 设置Alas</span><br><span class="line">在~&#x2F;.gitconfig文件中添加：</span><br><span class="line">[alias]</span><br><span class="line">push-release &#x3D; push origin HEAD:refs&#x2F;for&#x2F;release</span><br><span class="line">push-review &#x3D; push origin HEAD:refs&#x2F;for&#x2F;master</span><br><span class="line">unpushed &#x3D; lo --branches --not --remotes --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative</span><br><span class="line">lg &#x3D; log --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative</span><br><span class="line">ca &#x3D; commit -a</span><br><span class="line">ci &#x3D; commit</span><br><span class="line">st &#x3D; status</span><br><span class="line">co &#x3D; checkout</span><br><span class="line">br &#x3D; branch </span><br></pre></td></tr></table></figure><h3 id="commit-message-格式"><a href="#commit-message-格式" class="headerlink" title="commit message 格式"></a>commit message 格式</h3><p>所有commit 格式都应该如下：</p><p>QUIX2-12: quixmart2.0 后台系统设备管理，设备监控开发</p><p>Change-Id: I6be1be65a4d9839555a7c27a217cdd063d1ad99b</p><h3 id="开发人员代码review步骤"><a href="#开发人员代码review步骤" class="headerlink" title="开发人员代码review步骤"></a>开发人员代码review步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">开发人员：</span><br><span class="line">&gt;git remote update</span><br><span class="line">&gt;git co master</span><br><span class="line">&gt;git fetch &amp;&amp; git rebase master     (不要用git pull)</span><br><span class="line">&gt;git checkout -b bugfix-QUIX2-12</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx1.java</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx2.java</span><br><span class="line">&gt;git commit -m &quot;QUIX2-12: quixmart2.0 后台系统设备管理，设备监控开发&quot;</span><br><span class="line">&gt;git push-review     （会自动提到gerrit的master分支）</span><br><span class="line">如果有修改内容</span><br><span class="line">&gt;git add src&#x2F;com&#x2F;deepblue&#x2F;xxx&#x2F;xxx&#x2F;xxx2.java</span><br><span class="line">&gt;git commit --amend</span><br><span class="line">&gt;git push-review</span><br><span class="line"></span><br><span class="line">到gerrit web 界面要求相关开发进行代码review,也可以自己-2，这样可以不被submit. review完成后leader可以进行submit</span><br><span class="line"></span><br><span class="line">如果是紧急hotfix, 在开发人员 master gerrit submit成功后，leader需要将这个commit 在gerrit上cherry-pick到release 分支并完成上线</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="稳定master代码同步到release分支"><a href="#稳定master代码同步到release分支" class="headerlink" title="稳定master代码同步到release分支"></a>稳定master代码同步到release分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;git co master</span><br><span class="line">&gt;git fetch &amp;&amp; git rebase</span><br><span class="line">&gt;git co release</span><br><span class="line">&gt;git merge master</span><br><span class="line">&gt;git push-release</span><br><span class="line">添加相关人员代码review,然后submit到gitlab仓库</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>禁止用  ‘git add .’   ， 必须用’git add src/xxx/xxx.xxx’</li><li>要修改新的代码前先更新master分支，然后通过master分支checkout 一个其他分支</li><li>尽量不要在本地的master上直接改代码，每次在改代码之前先更新本地master分支，然后  git checkout -b featrure-QUIX2-xxx, 在本地的feature-QUIX2-xxx 改完后再merge 到master 分支，如果在feature-QUIX2-xxx 分支有多次commit, merge 时如果想把所有commit 变成一个commit, 用git merge –squash feature-QUIX2-xxx , 否则正常merge 用 git merge –no-ff -m “merge with no-ff” feature-QUIX2-xxx ，或者直接在当前分支用git push-review 会自动推到gerrit 的master分支</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>git st 查看当前git 仓库状态</li><li>git lg 查看commit  (经常用，结合git reset 来回切换历史commit)</li><li>git unpushed 查看哪些还没有push到gitlab仓库,(用之前应该更新代码)</li><li>git fetch &amp;&amp; git rebase  master 更新代码及分支信息</li><li>git reset –hard origin 还原成远端git库最新代码</li><li>git reset –hard xxx 还原到指定commit </li><li>git branch</li><li>git clone</li></ul><h3 id="本地目录到暂存区操作"><a href="#本地目录到暂存区操作" class="headerlink" title="本地目录到暂存区操作"></a>本地目录到暂存区操作</h3><ul><li>git restore file|.   将不在暂存区的文件撤销更改</li><li>git restore –staged 将文件从暂存区撤出，但不会撤销文件的更改</li><li>git add 命令可将该本地区下文件添加到暂存区</li></ul><h3 id="暂存区到本地版本库操作"><a href="#暂存区到本地版本库操作" class="headerlink" title="暂存区到本地版本库操作"></a>暂存区到本地版本库操作</h3><ul><li>git commit 主要是将暂存区里的改动给提交到本地的版本库</li><li>git commit –amend 继续提交</li></ul><h3 id="本地版本库到远程库操作-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt"><a href="#本地版本库到远程库操作-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt" class="headerlink" title="本地版本库到远程库操作(git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;)"></a>本地版本库到远程库操作(git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;)</h3><ul><li>git push origin HEAD:refs/for/release</li><li>git push origin HEAD:refs/for/master</li><li>refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要</li></ul><h3 id="远程库到本地版本库操作"><a href="#远程库到本地版本库操作" class="headerlink" title="远程库到本地版本库操作"></a>远程库到本地版本库操作</h3><ul><li><p>git revert  commit-id-a  归还，复原，回退，这个操作是会改变分支记录的，因为产生了新的提交。git revert 是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西</p></li><li><p>git reset –hard origin 还原成远端git库最新代码，之后的日志记录被删除</p></li><li><p>git reset –hard xxx 还原到指定commit</p></li><li><p>git reset –soft 被回退的那些版本的修改会被放在暂存区，可以再次提交</p></li><li><p>git reset –mixed 默认选项，被回退的那些版本的修改会放在工作目录，可以先加到暂存区，然后再提交。</p></li><li><p>git cherry-pick</p></li><li><p>git checkout</p></li></ul><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><ul><li>git reset HEAD^ –soft         –soft 表示保留当前commit，重新commit</li><li>git reset HEAD^ –hard       –hard 表示丢弃当前add，重新add、commit</li><li>git reset –hard HEAD~x解决，x表示的就是在这之前已经有多少次的提交，这句命令的意思就是直接回退到x 个commit之前</li></ul><h2 id="git-fork"><a href="#git-fork" class="headerlink" title="git fork"></a>git fork</h2><p><strong>git remote -v</strong> 先clone项目到本地，此时查看项目的远程信息<br><strong>git remote add upstream</strong>  [fork的远程地址]   添加远程地址<br><strong>git pull|fetch upstream master</strong>  从fork远程更新<br><strong>git merge upstream/master</strong>  合并到本地master分支<br><strong>git push origin master</strong>  上传到自己git上</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin异常处理</title>
      <link href="2020/11/17/Fegin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2020/11/17/Fegin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://my.oschina.net/xiaominmin">xiaomin0322</a></p><p>出处：<a href="https://my.oschina.net/xiaominmin/blog/2986631">https://my.oschina.net/xiaominmin/blog/2986631</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近在项目开发中，使用 Feign 调用服务，当触发熔断机制时，遇到了以下问题：</p><ul><li>异常信息形如：<code>TestService#addRecord(ParamVO) failed and no fallback available.</code>；</li><li>获取不到服务提供方抛出的原始异常信息；</li><li>实现某些业务方法不进入熔断，直接往外抛出异常；</li></ul><p>接下来将一一解决上述问题。</p><p>对于<code>failed and no fallback available.</code>这种异常信息，是因为项目开启了熔断：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">feign.hystrix.enabled</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><p>当调用服务时抛出了异常，却没有定义<code>fallback</code>方法，就会抛出上述异常。由此引出了第一个解决方式。</p><h3 id="FeignClient加上fallback方法，并获取异常信息"><a href="#FeignClient加上fallback方法，并获取异常信息" class="headerlink" title="@FeignClient加上fallback方法，并获取异常信息"></a><code>@FeignClient</code>加上<code>fallback</code>方法，并获取异常信息</h3><p>为<code>@FeignClient</code>修饰的接口加上<code>fallback</code>方法有两种方式，由于要获取异常信息，所以使用<code>fallbackFactory</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;serviceId&quot;, fallbackFactory = TestServiceFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">Result <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>@FeignClient</code>注解中指定<code>fallbackFactory</code>，上面例子中是<code>TestServiceFallback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceFallback</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">TestService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(TestServiceFallback.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERR_MSG = <span class="string">&quot;Test接口暂时不可用: &quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        String msg = throwable == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : throwable.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(msg)) &#123;</span><br><span class="line">            LOG.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ResultBuilder.unsuccess(ERR_MSG + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现<code>FallbackFactory</code>,可以在<code>create</code>方法中获取到服务抛出的异常。但是请注意，这里的异常是被<code>Feign</code>封装过的异常，不能直接在异常信息中看出原始方法抛出的异常。这时得到的异常信息形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">status 500 reading TestService#addRecord(ParamVO); content:</span><br><span class="line">&#123;<span class="string">&quot;success&quot;</span>:<span class="keyword">false</span>,<span class="string">&quot;resultCode&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;/ by zero&quot;</span>,<span class="string">&quot;model&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;models&quot;</span>:[],<span class="string">&quot;pageInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;timelineInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;extra&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;validationMessages&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;valid&quot;</span>:<span class="keyword">false</span>&#125;</span><br></pre></td></tr></table></figure><p>说明一下，本例子中，服务提供者的接口返回信息会统一封装在自定义类<code>Result</code>中，内容就是上述的<code>content</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;success&quot;</span>:<span class="keyword">false</span>,<span class="string">&quot;resultCode&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;/ by zero&quot;</span>,<span class="string">&quot;model&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;models&quot;</span>:[],<span class="string">&quot;pageInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;timelineInfo&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;extra&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;validationMessages&quot;</span>:<span class="keyword">null</span>,<span class="string">&quot;valid&quot;</span>:<span class="keyword">false</span>&#125;</span><br></pre></td></tr></table></figure><p>因此，异常信息我希望是<code>message</code>的内容：<code>/ by zero</code>，这样打日志时能够方便识别异常。</p><h3 id="保留原始异常信息"><a href="#保留原始异常信息" class="headerlink" title="保留原始异常信息"></a>保留原始异常信息</h3><p>当调用服务时，如果服务返回的状态码不是200，就会进入到<code>Feign</code>的<code>ErrorDecoder</code>中，因此如果我们要解析异常信息，就要重写<code>ErrorDecoder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> feign.Util;</span><br><span class="line"><span class="keyword">import</span> feign.codec.ErrorDecoder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: CipherCui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 保留 feign 服务异常信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 1:29 2018/6/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepErrMsgConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorDecoder <span class="title">errorDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserErrorDecoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserErrorDecoder</span> <span class="keyword">implements</span> <span class="title">ErrorDecoder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Exception <span class="title">decode</span><span class="params">(String methodKey, Response response)</span> </span>&#123;</span><br><span class="line">            Exception exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取原始的返回内容</span></span><br><span class="line">                String json = Util.toString(response.body().asReader());</span><br><span class="line">                exception = <span class="keyword">new</span> RuntimeException(json);</span><br><span class="line">                <span class="comment">// 将返回内容反序列化为Result，这里应根据自身项目作修改</span></span><br><span class="line">                Result result = JsonMapper.nonEmptyMapper().fromJson(json, Result.class);</span><br><span class="line">                <span class="comment">// 业务异常抛出简单的 RuntimeException，保留原来错误信息</span></span><br><span class="line">                <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">                    exception = <span class="keyword">new</span> RuntimeException(result.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                logger.error(ex.getMessage(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个例子，原理是根据<code>response.body()</code>反序列化为自定义的<code>Result</code>类，提取出里面的<code>message</code>信息，然后抛出<code>RuntimeException</code>，这样当进入到熔断方法中时，获取到的异常就是我们处理过的<code>RuntimeException</code>。</p><p>注意上面的例子并不是通用的，但原理是相通的，大家要结合自身的项目作相应的修改。</p><p>要使上面代码发挥作用，还需要在<code>@FeignClient</code>注解中指定<code>configuration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;serviceId&quot;, fallbackFactory = TestServiceFallback.class, configuration = &#123;KeepErrMsgConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不进入熔断，直接抛出异常"><a href="#不进入熔断，直接抛出异常" class="headerlink" title="不进入熔断，直接抛出异常"></a>不进入熔断，直接抛出异常</h3><p>有时我们并不希望方法进入熔断逻辑，只是把异常原样往外抛。这种情况我们只需要捉住两个点：<strong>不进入熔断</strong>、<strong>原样</strong>。</p><p>原样就是获取原始的异常，上面已经介绍过了，而不进入熔断，需要把异常封装成<code>HystrixBadRequestException</code>，对于<code>HystrixBadRequestException</code>，<code>Feign</code>会直接抛出，不进入熔断方法。</p><p>因此我们只需要在上述<code>KeepErrMsgConfiguration</code>的基础上作一点修改即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: CipherCui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: feign 服务异常不进入熔断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 1:29 2018/6/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotBreakerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorDecoder <span class="title">errorDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserErrorDecoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserErrorDecoder</span> <span class="keyword">implements</span> <span class="title">ErrorDecoder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Exception <span class="title">decode</span><span class="params">(String methodKey, Response response)</span> </span>&#123;</span><br><span class="line">            Exception exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String json = Util.toString(response.body().asReader());</span><br><span class="line">                exception = <span class="keyword">new</span> RuntimeException(json);</span><br><span class="line">                Result result = JsonMapper.nonEmptyMapper().fromJson(json, Result.class);</span><br><span class="line">                <span class="comment">// 业务异常包装成 HystrixBadRequestException，不进入熔断逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">                    exception = <span class="keyword">new</span> HystrixBadRequestException(result.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                logger.error(ex.getMessage(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了更好的达到熔断效果，我们应该为每个接口指定<code>fallback</code>方法。而根据自身的业务特点，可以灵活的配置上述的<code>KeepErrMsgConfiguration</code>和<code>NotBreakerConfiguration</code>，或自己编写<code>Configuration</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fegin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin与Hystrix及Ribbon关系</title>
      <link href="2020/11/17/Fegin%E4%B8%8EHystrix%E5%8F%8ARibbon%E5%85%B3%E7%B3%BB/"/>
      <url>2020/11/17/Fegin%E4%B8%8EHystrix%E5%8F%8ARibbon%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="https://home.cnblogs.com/u/crazymakercircle/">疯狂创客圈</a><br>出处：<a href="https://www.cnblogs.com/crazymakercircle/p/11664812.html">https://www.cnblogs.com/crazymakercircle/p/11664812.html</a></p><h3 id="Springcloud-高并发-配置-简介"><a href="#Springcloud-高并发-配置-简介" class="headerlink" title="Springcloud 高并发 配置 简介"></a>Springcloud 高并发 配置 简介</h3><p>在微服务架构的应用中， Feign、Hystrix，Ribbon三者都是必不可少的，可以说已经成为铁三角。</p><p><strong>疯狂创客圈</strong>（笔者尼恩创建的高并发研习社群）中，有不少小伙伴问到尼恩，关于Feign、Hystrix，Ribbon三者之间的关系，以及三者的超时配置。截止目前，全网没有篇文章介绍清楚的，故，尼恩特写一篇详细一点的文章，剖析一下。</p><h3 id="Feign介绍"><a href="#Feign介绍" class="headerlink" title="Feign介绍"></a>Feign介绍</h3><p>Feign是一款Java语言编写的HttpClient绑定器，在Spring Cloud微服务中用于实现微服务之间的声明式调用。Feign 可以定义请求到其他服务的接口，用于微服务间的调用，不用自己再写http请求，在客户端实现，调用此接口就像远程调用其他服务一样，当请求出错时可以调用接口的实现类来返回</p><p>Feign是一个声明式的web service客户端，它使得编写web service客户端更为容易。创建接口，为接口添加注解，即可使用Feign。Feign可以使用Feign注解或者JAX-RS注解，还支持热插拔的编码器和解码器。Spring Cloud为Feign添加了Spring MVC的注解支持，并整合了Ribbon和Eureka来为使用Feign时提供负载均衡。</p><p>feign源码的github地址：</p><p><a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><h3 id="Ribbon介绍"><a href="#Ribbon介绍" class="headerlink" title="Ribbon介绍"></a>Ribbon介绍</h3><p>Ribbon 作为负载均衡，在客户端实现，服务段可以启动两个端口不同但servername一样的服务</p><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。简单地说，Ribbon是一个客户端负载均衡器。</p><p>Ribbon工作时分为两步：第一步先选择 Eureka Server, 它优先选择在同一个Zone且负载较少的Server；第二步再根据用户指定的策略，在从Server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略，例如轮询、随机、根据响应时间加权等。</p><p>ribbon源码的github地址：</p><p><a href="https://github.com/Netflix/ribbon">https://github.com/Netflix/ribbon</a></p><h3 id="Hystrix介绍"><a href="#Hystrix介绍" class="headerlink" title="Hystrix介绍"></a>Hystrix介绍</h3><p>Hystrix作为熔断流量控制，在客户端实现，在方法上注解，当请求出错时可以调用注解中的方法返回</p><p>Hystrix熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。</p><p>Hystrix源码的github地址：</p><p><a href="https://github.com/Netflix/hystrix">https://github.com/Netflix/hystrix</a></p><h3 id="重点：-三者之间的关系图"><a href="#重点：-三者之间的关系图" class="headerlink" title="重点： 三者之间的关系图"></a>重点： 三者之间的关系图</h3><p>如果微服务项目加上了spring-cloud-starter-netflix-hystrix依赖，那么，feign会通过代理模式， 自动将所有的方法用 hystrix 进行包装。</p><p>在Spring Cloud微服务体系下，微服务之间的互相调用可以通过Feign进行声明式调用，在这个服务调用过程中Feign会通过Ribbon从服务注册中心获取目标微服务的服务器地址列表，之后在网络请求的过程中Ribbon就会将请求以负载均衡的方式打到微服务的不同实例上，从而实现Spring Cloud微服务架构中最为关键的功能即服务发现及客户端负载均衡调用。</p><p>另一方面微服务在互相调用的过程中，为了防止某个微服务的故障消耗掉整个系统所有微服务的连接资源，所以在实施微服务调用的过程中我们会要求在调用方实施针对被调用微服务的熔断逻辑。而要实现这个逻辑场景在Spring Cloud微服务框架下我们是通过Hystrix这个框架来实现的。</p><p>调用方会针对被调用微服务设置调用超时时间，一旦超时就会进入熔断逻辑，而这个故障指标信息也会返回给Hystrix组件，Hystrix组件会根据熔断情况判断被调微服务的故障情况从而打开熔断器，之后所有针对该微服务的请求就会直接进入熔断逻辑，直到被调微服务故障恢复，Hystrix断路器关闭为止。</p><p>三者之间的关系图，大致如下：</p><p><a href="https://img-blog.csdnimg.cn/20191012221343851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20191012221343851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p><h3 id="Feign典型配置说明"><a href="#Feign典型配置说明" class="headerlink" title="Feign典型配置说明"></a>Feign典型配置说明</h3><p>Feign自身可以支持多种HttpClient工具包，例如OkHttp及Apache HttpClient，针对Apache HttpClient的典型配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment">#替换掉JDK默认HttpURLConnection实现的 Http Client</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">       <span class="comment">#连接超时时间</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">       <span class="comment">#读取超时时间</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="Hystrix配置说明"><a href="#Hystrix配置说明" class="headerlink" title="Hystrix配置说明"></a>Hystrix配置说明</h3><p>在Spring Cloud微服务体系中Hystrix主要被用于实现实现微服务之间网络调用故障的熔断、过载保护及资源隔离等功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">propagate:</span></span><br><span class="line">    <span class="attr">request-attribute:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="comment">#全局默认配置</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="comment">#线程隔离相关</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">timeout:</span></span><br><span class="line">          <span class="comment">#是否给方法执行设置超时时间，默认为true。一般我们不要改。</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="comment">#配置请求隔离的方式，这里是默认的线程池方式。还有一种信号量的方式semaphore，使用比较少。</span></span><br><span class="line">          <span class="attr">strategy:</span> <span class="string">threadPool</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="comment">#方式执行的超时时间，默认为1000毫秒，在实际场景中需要根据情况设置</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">10000</span></span><br><span class="line">            <span class="comment">#发生超时时是否中断方法的执行，默认值为true。不要改。</span></span><br><span class="line">            <span class="attr">interruptOnTimeout:</span> <span class="literal">true</span></span><br><span class="line">            <span class="comment">#是否在方法执行被取消时中断方法，默认值为false。没有实际意义，默认就好！</span></span><br><span class="line">            <span class="attr">interruptOnCancel:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">circuitBreaker:</span>   <span class="comment">#熔断器相关配置</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#是否启动熔断器，默认为true，false表示不要引入Hystrix。</span></span><br><span class="line">    <span class="attr">requestVolumeThreshold:</span> <span class="number">20</span>     <span class="comment">#启用熔断器功能窗口时间内的最小请求数，假设我们设置的窗口时间为10秒，</span></span><br><span class="line">    <span class="attr">sleepWindowInMilliseconds:</span> <span class="number">5000</span>    <span class="comment">#所以此配置的作用是指定熔断器打开后多长时间内允许一次请求尝试执行，官方默认配置为5秒。</span></span><br><span class="line">    <span class="attr">errorThresholdPercentage:</span> <span class="number">50</span>   <span class="comment">#窗口时间内超过50%的请求失败后就会打开熔断器将后续请求快速失败掉,默认配置为50</span></span><br></pre></td></tr></table></figure><h3 id="Ribbon配置说明"><a href="#Ribbon配置说明" class="headerlink" title="Ribbon配置说明"></a>Ribbon配置说明</h3><p>Ribbon在Spring Cloud中对于支持微服之间的通信发挥着非常关键的作用，其主要功能包括客户端负载均衡器及用于中间层通信的客户端。在基于Feign的微服务通信中无论是否开启Hystrix，Ribbon都是必不可少的，Ribbon的配置参数主要如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#说明：同一台实例的最大自动重试次数，默认为1次，不包括首次</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment">#说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment">#说明：是否所有的操作都重试，默认为true</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒</span></span><br><span class="line">  <span class="attr">ServerListRefreshInterval:</span> <span class="number">2000</span></span><br><span class="line">  <span class="comment">#说明：使用Apache HttpClient连接超时时间，单位为毫秒</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">3000</span></span><br><span class="line">  <span class="comment">#说明：使用Apache HttpClient读取的超时时间，单位为毫秒</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>如上图所示，在Spring Cloud中使用Feign进行微服务调用分为两层：<strong>Hystrix的调用和Ribbon的调用，Feign自身的配置会被覆盖</strong>。</p><p>而如果<strong>开启了Hystrix，那么Ribbon的超时时间配置与Hystrix的超时时间配置则存在依赖关系</strong>，因为涉及到Ribbon的重试机制，所以一般情况下都是Ribbon的超时时间小于Hystrix的超时时间，否则会出现以下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">12</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">20</span>,<span class="number">208</span>   <span class="number">111231</span> [http-nio-<span class="number">8084</span>-exec-<span class="number">2</span>] WARN    o.s.c.n.z.f.r.s.AbstractRibbonCommand - The Hystrix timeout of <span class="number">10000</span>ms   <span class="keyword">for</span> the command operation is set lower than the combination of the Ribbon   read and connect timeout, <span class="number">24000</span>ms. </span><br></pre></td></tr></table></figure><h3 id="Ribbon和Hystrix的超时时间配置的关系"><a href="#Ribbon和Hystrix的超时时间配置的关系" class="headerlink" title="Ribbon和Hystrix的超时时间配置的关系"></a>Ribbon和Hystrix的超时时间配置的关系</h3><p><strong>那么Ribbon和Hystrix的超时时间配置的关系具体是什么呢？如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hystrix的超时时间=Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout)</span><br></pre></td></tr></table></figure><p><strong>而Ribbon的重试次数的计算方式为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ribbon重试次数(包含首次)= <span class="number">1</span> + ribbon.MaxAutoRetries  +  ribbon.MaxAutoRetriesNextServer  +  (ribbon.MaxAutoRetries * ribbon.MaxAutoRetriesNextServer)</span><br></pre></td></tr></table></figure><p>以上图中的Ribbon配置为例子，Ribbon的重试次数=1+(1+1+1)=4，所以Hystrix的超时配置应该&gt;=4*(3000+3000)=24000毫秒。在Ribbon超时但Hystrix没有超时的情况下，Ribbon便会采取重试机制；而重试期间如果时间超过了Hystrix的超时配置则会立即被熔断（fallback）。</p><p>如果不配置Ribbon的重试次数，则Ribbon默认会重试一次，加上第一次调用Ribbon，总的的重试次数为2次，以上述配置参数为例，Hystrix超时时间配置为2*6000=12000，由于很多情况下，大家一般不会主动配置Ribbon的重试次数，所以这里需要注意下！强调下，以上超时配置的值只是示范，超时配置有点大不太合适实际的线上场景，大家根据实际情况设置即可！</p><p>说明下，<strong>如果不启用Hystrix，Feign的超时时间则是Ribbon的超时时间，Feign自身的配置也会被覆盖</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> Fegin </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fegin</title>
      <link href="2020/11/17/Fegin/"/>
      <url>2020/11/17/Fegin/</url>
      
        <content type="html"><![CDATA[<h2 id="Fegin客户端"><a href="#Fegin客户端" class="headerlink" title="Fegin客户端"></a>Fegin客户端</h2><p><strong>GET：</strong></p><ol><li>客户端对象不加@RequesetParam,控制类使用对象接收，时间格式会出现转换失败【string转date异常】</li><li>客户端对象不增加@RequesetParam，控制类使用@RequesetParam对象接收，参数miss【orderSource=TAKEGO&amp;logicDelete=0&amp;pageSize=20&amp;startTime=2020-11-04T16:00:00.000+0000&amp;<br>  endTime=2020-11-05T15:59:59.059+0000&amp;pageNum=1 】</li><li>客户端对象增加@RequesetParam,控制类使用对象接收，【consumerOrderSearchVO=ConsumerOrderSearchVO%28startTime%3DThu%20Nov%2005%2000%3A00%3A00%20CST%202020%2C%20endTime%3DThu%20Nov%2005%2023%3A59%3A59%20CST%202020%2C%20orderSource%3DTAKEGO%2C%20logicDelete%3D0%29 】</li><li>客户端对象增加@RequesetParam，控制类也使用@RequesetParam对象接收，异常【Cannot convert value of type ‘java.lang.String’ to required type ‘io.deepblueai.order.api.vo.ConsumerOrderSearchVO’】</li><li>客户端对象使用@RequestBody,控制类使用@RequestBody，【Required request body is missing】</li></ol><p><strong>POST:</strong> </p><p>​    使用@RequestBody</p><p><strong>List 数组</strong></p><pre><code>1. @RequestParam(&quot;ids&quot;);  2. 使用json</code></pre><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>@RequesetParam(name=”vo”) 把参数转换成了vo=””格式,{对象传递不应该增加此注解}，用于当key名称不对应时指定key名称，或者指定value是否为空，默认不为空</p><h2 id="Fegin使用GET方法，Body请求异常"><a href="#Fegin使用GET方法，Body请求异常" class="headerlink" title="Fegin使用GET方法，Body请求异常"></a>Fegin使用GET方法，Body请求异常</h2><p>HttpClientFeignLoadBalancedConfiguration&gt;OkHttpFeignLoadBalancedConfiguration&gt;DefaultFeignLoadBalancedConfiguration,对应的底层http工具：httpclient&gt;okhttp&gt;HttpURLConnection</p><p>根据http协议定义是支持@RequestBody+ RequestMethod.GET的，那么具体就得看工具包实现的不同的，查看源码发现<strong>okhttp和HttpURLConnection都不支持（报错），只有httpclient支持。（默认走HttpURLConnection会报错）</strong></p><p>我们知道只有httpclient支持@RequestBody+ RequestMethod.GET，所以我们必须满足条件走HttpClientFeignLoadBalancedConfiguration才行 </p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fegin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archaius配置中心客户端</title>
      <link href="2020/11/17/Archaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2020/11/17/Archaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Archaius"><a href="#Archaius" class="headerlink" title="Archaius"></a>Archaius</h2><p>Netflix只是开源了其配置中心（Archaius变色龙）的客户端部分，没有开源配套的服务器端。Archaius其实是配置源实现无关的，可以对接各种配置中心作为数据源。</p><h2 id="Archaius在Netflix的用例场景"><a href="#Archaius在Netflix的用例场景" class="headerlink" title="Archaius在Netflix的用例场景"></a>Archaius在Netflix的用例场景</h2><ul><li>根据请求上下文开启或关闭某项功能。</li><li>某个页面缺省显示10个商品，在某些情况下，可以通过Archaius调整配置，只显示5个商品。</li><li>动态调整Hystrix熔断器的行为。</li><li>调整服务调用客户端的连接和请求超时参数。</li><li>如果某个线上服务产生出错告警，可以动态调整日志输出级别(粒度可以细到包或者组件级别)，这样可以通过详细日志排查问题。问题定位以后，再将日志输出级别恢复到默认级别。</li><li>对于多区域或者多国家部署的应用，通过动态配置，可以根据不同区域和国家开启不同的功能。</li><li>可以根据用户的实际访问模式动态调整一些基础中间件的配置，例如缓存的存活时间TTL(Time To Live)。</li><li>数据库访问客户端的连接池配置，可以对不同服务配不同的值。例如，一个请求频率RPS(Request Per Second)小的服务，可以配置较小的连接数，而一个请求频率大的服务，可以配置较大的连接数。</li><li>运行期配置的变更可以在不同维度生效，例如集群中的单个实例维度，多区域部署下的某个区域维度，某个服务栈维度，或者某个应用集群维度。</li><li>功能开关(Feature Flag)发布，有些功能虽然上线，但是并不马上启用，而是通过配置开关动态启用，这样可以根据情况灵活开启或者关闭某项线上功能。</li><li>金丝雀发布(Canary Release)，新功能上线时，让新老集群同时并存一段时间，通过配置将到老集群的流量逐步动态调整到新集群，如果监控显示无异常，则完成新集群的上线，如异常，则快速切回老集群。</li></ul><h2 id="Archaius的特性和设计"><a href="#Archaius的特性和设计" class="headerlink" title="Archaius的特性和设计"></a>Archaius的特性和设计</h2><p>Archaius实际上是对Apache Common Configuration Library的一个封装和扩展，提供了一组基于Java的配置API，主要的特性包括：</p><ul><li>配置可动态调整。</li><li>配置支持类型(Int, Long, Boolean等)。</li><li>高性能和线程安全。</li><li>提供一个拉(pulling)配置的框架，可以从配置源动态拉取变更的配置。</li><li>支持回调(callback)机制，在配置变更时自动调用。</li><li>支持JMX MBean，可以通过JConsole查看配置和修改配置。</li></ul><p>下图是Archaius的总体设计：</p><p><img src="/2020/11/17/Archaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><p>Achaius的核心是一个称为**组合配置(Composite Configuration)**的概念，简单可以理解为一个分层级的配置，层级有优先级，高优先级的层级的配置会覆盖低优先级的配置。每一个层级可以从某个配置源获取配置，例如本地配置文件，JDBC数据源，远程REST API等。配置源还可以在运行时动态拉取变更，例如在上图中，持久化数据库配置(Persisted DB Configuration)是指将配置存在关系数据库中，相应的配置源会定期从数据库拉取变更)。配置的最终值由顶级配置决定，例如，如果多个层级都含有某个配置项，那么应用最终见到的值是配置层级中最顶层的值。配置分层的顺序是可以调整的。</p><h2 id="分级配置案例"><a href="#分级配置案例" class="headerlink" title="分级配置案例"></a>分级配置案例</h2><p>假设你开发了一个叫myapp的应用，在本地开发环境，一般你希望用本地配置，不依赖于远程的配置中心，这个时候你只需为应用写一个本地配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myapp.properties</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这个配置文件里头包含myapp的所有缺省配置。</p><p>当你的应用开发完成，需要分别部署到测试TEST, UAT和生产PROD环境，如果你希望在不同的环境重载某些缺省值，那么你可以为不同环境分别添加本地配置文件，在相关文件中重载缺省值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myapp-test.properties</span><br><span class="line">myapp-uat.properties</span><br><span class="line">myapp-prod.properties</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>例如，在<code>myapp.properties</code>中<code>timeout</code>配置值是<code>500</code>，在<code>myapp-prod.properties</code>中<code>timeout</code>配置值是<code>200</code>，那么应用在生产环境中将使用重载值<code>timeout=200</code>，其它没有重载则使用<code>myapp.properties</code>中的缺省值。</p><p>在Archaius中，可以通过设置<code>archaius.deployment.environment</code>启动参数，来激活不同环境的配置。</p><p>如果你还希望应用上线后，可以通过配置中心动态调整配置值，那么你可以将Achaius和某个配置中心(比如Apollo)进行对接，对接后配置中心中的配置具有最高优先级，其中的配置可以覆盖应用本地配置文件中的配置。例如，应用上线后你发现<code>timeout=200</code>设置太小了，想调大到<code>timeout=1000</code>，可以通过配置中心一键搞定。</p><h2 id="Archaius和Apollo配置中心集成"><a href="#Archaius和Apollo配置中心集成" class="headerlink" title="Archaius和Apollo配置中心集成"></a>Archaius和Apollo配置中心集成</h2><p>Archaius是一款非常优秀的生产级配置客户端组件，比较可惜的是Netflix没有开源它的配置中心的服务器端，幸好业界已经有Apollo这样优秀的配置中心开源产品。Archaius本身是配置源无关的，它提供的拉(pulling)框架可以支持对接各种数据源，而Apollo本身也正好提供基于HTTP REST的配置拉取接口，使得Archaius和Apollo的对接非常简单。</p><p>另外，当你想要使用某些Netflix的组件，比如Zuul网关，它原生是支持Archaius进行动态配置的，如果你又想要使用Apollo配置中心支持集中式动态配置，这个时候你用Apollo客户端去改造Zuul的话，工作量不小。其实不需要这么麻烦，这三者可以简单完美实现集成，如下图所示：</p><p><img src="/2020/11/17/Archaius%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF/%E9%9B%86%E6%88%90%E5%9B%BE.png"></p><p>集成要点：</p><ul><li>通过设置<code>archaius.configurationSource.additionalUrls</code>启动参数，设置为Apollo的配置文件拉取端点，激活Archaius的远程配置数据源。</li><li>Apollo的配置文件拉取端点为：<code>&#123;config_server_url&#125;/configfiles/&#123;appId&#125;/&#123;clusterName&#125;/&#123;namespaceName&#125;</code>，其中：<code>config_server_url</code>是配置中心地址，<code>appId</code>是应用(例如Zuul)在Apollo中的唯一标识，<code>clusterName</code>是应用在Apollo中的集群名，一般用缺省<code>default</code>，<code>namespaceName</code>是应用在Apollo中的名字空间，一般用缺省<code>application</code>。</li><li>注意，对于不同的环境(TEST，UAT，PROD等)，Apollo配置中心的地址一般不同</li><li>Archaius动态拉取配置的周期缺省是60秒，可以调整。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>根据不同上下文动态调整应用的行为逻辑，是现代互联网应用的刚需，配置中心应运而生，它是微服务架构必不可少的组件。</li><li>Archaius是Netflix开源的生产级配置中心客户端组件，它的亮点是支持多维度、分层级的和动态的配置。</li><li>Archaius可以和Apollo配置中可以简单无缝集成，让很多Netflix的开源组件(Zuul，Hystrix，Ribbon等)可以简单接入Apollo。波波2018年在极客时间上的课程《微服务架构和实践160讲》，7月份推出了第3模块：《微服务网关Zuul架构和实践》，其中会通过实验详细分析Archaius和Apollo的集成，通过Apollo+Archaius实现Zuul网关的动态配置，欢迎大家关注。</li><li>关于Archaius的更多技术细节，可以参考其在github上的站点[附录1]，另外拍拍贷框架团队的技术专家<strong>尹作龙</strong>也写了一篇文章《微服务动态配置组件netflix archaius》[附录2]，对Archaius的实现细节、使用案例以及如何与Spring Boot集成进行了深入细致的剖析，欢迎大家学习。</li></ol><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>Archaius 包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等等功能。</p><h2 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h2><p>Archaius 支持配置源包括：文件、URLs、JDBC 以及 Amazon DynamoDB</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a property whose value is type long and use 1000 as the default </span></span><br><span class="line">  <span class="comment">// if the property is not defined</span></span><br><span class="line">  DynamicLongProperty timeToWait = </span><br><span class="line">      DynamicPropertyFactory.getInstance().getLongProperty(<span class="string">&quot;lock.waitTime&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ReentrantLock lock = ...;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  lock.tryLock(timeToWait.get(), TimeUnit.MILLISECONDS); <span class="comment">// timeToWait.get() returns up-to-date value of the property</span></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li><a href="https://github.com/netflix/archaius">Netflix Archaius</a></li><li><a href="http://techblog.ppdai.com/2018/05/08/20180508/">微服务动态配置组件netflix archaius</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
            <tag> Archaius </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置中心对比</title>
      <link href="2020/11/17/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/"/>
      <url>2020/11/17/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式配置中心技术"><a href="#分布式配置中心技术" class="headerlink" title="分布式配置中心技术"></a>分布式配置中心技术</h1><p>配置中心分为二部分，Server服务端及Client客户端。服务端提供数据配置存储；客户端和应用集成，通过通信协议与服务端进行交互，获取服务端数据。</p><h2 id="主流分布式配置中心"><a href="#主流分布式配置中心" class="headerlink" title="主流分布式配置中心"></a>主流分布式配置中心</h2><p>现在比较流行的分布式配置中心如下：</p><ul><li><strong>Nacos</strong> 阿里开源的配置中心，也可以做DNS和RPC的服务发现</li><li><strong>spring cloud config</strong>(借助其它存储服务实现服务端如git)</li><li><strong>Apollo</strong> 携程开源的配置管理中心，具备规范的权限、流程治理等特性</li><li><strong>Disconf</strong> 百度开源的配置管理中心，<strong>目前已经不维护了</strong></li><li><strong>Archaius</strong> Netflix未开源的配置中，其它组件(例如Zuul, Hystrix, Eureka, Ribbon等)都依赖于Archaius</li></ul><h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><p><img src="/2020/11/17/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%941-1605244589166.jpeg"></p><p><img src="/2020/11/17/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%942.jpeg"></p><p><strong>说明：</strong></p><p>压测环境：Nacos和Apollo使用同样的数据库（32C128G）部署Server服务的机器使用的8C16G配置的容器，磁盘是100G SSD。</p><p>Spring Cloud Config使用2.0.0.M9版本，Apollo使用1.2.0 release版本，Nacos使用0.5版本。</p><p>Spring Cloud Config 依赖git，使用局限性较大。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题</title>
      <link href="2020/11/17/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>2020/11/17/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>作者：<a href="http://atecher.com/">Atecher</a></p><p>出处：<a href="http://atecher.com/2018/04/11/Java-Algorithms-Problem/">http://atecher.com/2018/04/11/Java-Algorithms-Problem/</a></p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</p><p>1.程序分析：这个是典型的<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波那契数列</a>，兔子的规律为数列1,1,2,3,5,8,13,21….</p><p>具体分析如下：</p><blockquote><p>f(1) = 1(第1个月有一对兔子）<br>f(2) = 1(第2个月还是一对兔子）<br>f(3) = 2(原来有一对兔子，第3个开始，每个月生一对兔子）<br>f(4) = 3(原来有两对兔子，有一对可以生育）<br>f(5) = 5(原来有3对兔子，第3个月出生的那对兔子也可以生育了，那么现在有两对兔子可以生育）<br>f(6) = 8(原来有5对兔子，第4个月出生的那对兔子也可以生育了，那么现在有3对兔子可以生育）<br>…………..<br>由以上可以看出，第n个月兔子的对数为<br>f(n) = f(n - 1) + f(n - 2);<br>f(n-1)是上个月的兔子数量，是原来有的。<br>f(n-2)是可以生育的兔子数，即多出来的数量。第n-2个月开始后的第3个月是第n个月，此时第n-2个月时的兔子都可以生育了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">            System.out.println(f(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>||x == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> f(x - <span class="number">1</span>) + f(x - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断101-200之间有多少个素数，并输出所有素数"><a href="#判断101-200之间有多少个素数，并输出所有素数" class="headerlink" title="判断101-200之间有多少个素数，并输出所有素数"></a>判断101-200之间有多少个素数，并输出所有素数</h2><p>1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出所有的“水仙花数”"><a href="#打印出所有的“水仙花数”" class="headerlink" title="打印出所有的“水仙花数”"></a>打印出所有的“水仙花数”</h2><p>所谓水仙花数是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 水仙花数 ，因为153=1的三次方＋5的三次方＋3的三次方。</p><p>1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        math mymath = <span class="keyword">new</span> math();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (mymath.shuixianhua(i) == <span class="keyword">true</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shuixianhua</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        i = x/<span class="number">100</span>;</span><br><span class="line">        j = (x % <span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">        k = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == i*i*i + j*j*j + k*k*k)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一个正整数分解质因数。例如：输入90-打印出90-233-5。"><a href="#将一个正整数分解质因数。例如：输入90-打印出90-233-5。" class="headerlink" title="将一个正整数分解质因数。例如：输入90,打印出90=233*5。"></a>将一个正整数分解质因数。例如：输入90,打印出90=2<em>3</em>3*5。</h2><p>1.程序分析：对n进行分解质因数，应先找到一个最小的质数i，然后按下述步骤完成：<br>(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。<br>(2)如果n &gt; i，但n能被i整除，则应打印出i的值，并用n除以i的商,作为新的正整数你,重复执行第一步。<br>(3)如果n不能被i整除，则用i+1作为i的值,重复执行第一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeFactorization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeFactorization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factorization</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                <span class="keyword">if</span>(n!=i)&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                fenjie(n/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入N的值：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        System.out.print( <span class="string">&quot;分解质因数：&quot;</span> + N +<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> PrimeFactorization().factorization(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用条件运算符的嵌套来完成此题：学习成绩-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"><a href="#利用条件运算符的嵌套来完成此题：学习成绩-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。" class="headerlink" title="利用条件运算符的嵌套来完成此题：学习成绩=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"></a>利用条件运算符的嵌套来完成此题：学习成绩=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。</h2><p>1.程序分析：(a&gt;b)?a:b这是条件运算符的基本例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcademicRecord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入N的值：&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        System.out.println(N &gt;= <span class="number">90</span> ?<span class="string">&quot;A&quot;</span>: (N &gt;= <span class="number">60</span> ? <span class="string">&quot;B&quot;</span>:<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入两个正整数m和n，求其最大公约数和最小公倍数。"><a href="#输入两个正整数m和n，求其最大公约数和最小公倍数。" class="headerlink" title="输入两个正整数m和n，求其最大公约数和最小公倍数。"></a>输入两个正整数m和n，求其最大公约数和最小公倍数。</h2><p>1.程序分析：利用辗除法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,m,n;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个正整数：&quot;</span>);</span><br><span class="line">        a=in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;再输入一个正整数：&quot;</span>);</span><br><span class="line">        b=in.nextInt();</span><br><span class="line">        commonDivisor use=<span class="keyword">new</span> commonDivisor();</span><br><span class="line">        m=use.commonDivisor(a,b);</span><br><span class="line">        n=a*b/m;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大公约数：&quot;</span>+m);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小公倍数：&quot;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">commonDivisor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commonDivisor</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=x;</span><br><span class="line">            x=y;</span><br><span class="line">            y=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k=x%y;</span><br><span class="line">                x=y;</span><br><span class="line">                y=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"><a href="#输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。" class="headerlink" title="输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"></a>输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</h2><p>1.程序分析：利用for循环语句,if条件语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串;&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str=in.nextLine();</span><br><span class="line">        <span class="keyword">char</span>[] ch=str.toCharArray();</span><br><span class="line">        count use=<span class="keyword">new</span> count();</span><br><span class="line">        use.count(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">count</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digital,character,blank,other;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">char</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                digital++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((arr[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;z&#x27;</span>)||(arr[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="string">&#x27;Z&#x27;</span>))&#123;</span><br><span class="line">                character++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                blank++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                other++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数字个数：&quot;</span>+digital);</span><br><span class="line">        System.out.println(<span class="string">&quot;英文字母个数：&quot;</span>+character);</span><br><span class="line">        System.out.println(<span class="string">&quot;空格个数：&quot;</span>+blank);</span><br><span class="line">        System.out.println(<span class="string">&quot;其他字符个数：&quot;</span>+other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。"><a href="#求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。" class="headerlink" title="求s = a + aa + aaa + aaaa + aa…a的值，其中a是一个数字。"></a>求s = a + aa + aaa + aaaa + aa…a的值，其中a是一个数字。</h2><p>例如2 + 22 + 222 + 2222 + 22222(此时共有5个数相加)，几个数相加有键盘控制。</p><p>1.程序分析：关键是计算出每一项的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(请输入a的值);</span><br><span class="line">        int a &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(请输入n个数);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        int s &#x3D; 0,t&#x3D;0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            t +&#x3D; a;</span><br><span class="line">            a &#x3D; a*10;</span><br><span class="line">            s +&#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个数如果恰好等于它的因子之和，这个数就称为”完数”。"><a href="#一个数如果恰好等于它的因子之和，这个数就称为”完数”。" class="headerlink" title="一个数如果恰好等于它的因子之和，这个数就称为”完数”。"></a>一个数如果恰好等于它的因子之和，这个数就称为”完数”。</h2><p>例如6=1＋2＋3。编程找出1000以内的所有完数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int s;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">            s &#x3D; 0;</span><br><span class="line">            for (int j &#x3D; 1; j &lt; i; j++)</span><br><span class="line">                if (i % j &#x3D;&#x3D; 0)</span><br><span class="line">                    s &#x3D; s + j;</span><br><span class="line">            if (s &#x3D;&#x3D; i)</span><br><span class="line">                System.out.print(i + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo09&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i,j,sum;</span><br><span class="line">        for(i&#x3D;1;i&lt;1000;i++)&#123;</span><br><span class="line">            sum &#x3D; 0;</span><br><span class="line">            for(j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)&#123;</span><br><span class="line">                if(i%j&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    sum+&#x3D;j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum&#x3D;&#x3D;i)&#123;</span><br><span class="line">                System.out.print(i+&quot; its factors are:   &quot;);</span><br><span class="line">                for(j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)&#123;</span><br><span class="line">                    if(i%j&#x3D;&#x3D;0)</span><br><span class="line">                        System.out.print(j+&quot;, &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？"><a href="#一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？" class="headerlink" title="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？"></a>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double s &#x3D; 0;</span><br><span class="line">        double h &#x3D; 100;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;</span><br><span class="line">            s +&#x3D; h;</span><br><span class="line">            h &#x3D; h&#x2F;2;</span><br><span class="line">            s +&#x3D; h;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;经过路程：&quot;+s);</span><br><span class="line">        System.out.println(&quot;反弹高度：&quot;+h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h2><p>1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 4; i++)</span><br><span class="line">          for (int j &#x3D; 1; j &lt;&#x3D; 4; j++)</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; 4; k++)</span><br><span class="line">              if (i !&#x3D; j &amp;&amp; j !&#x3D; k &amp;&amp; i !&#x3D; k) &#123;</span><br><span class="line">            count +&#x3D; 1;</span><br><span class="line">            System.out.println(i*100 + j*10 + k);</span><br><span class="line">              &#125;</span><br><span class="line">        System.out.println(&quot;共&quot; + count + &quot;个三位数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="企业发放的奖金根据利润提成。"><a href="#企业发放的奖金根据利润提成。" class="headerlink" title="企业发放的奖金根据利润提成。"></a>企业发放的奖金根据利润提成。</h2><p>利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润lirun，求应发放奖金总数sum？</p><p>1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double sum;</span><br><span class="line">        System.out.println(&quot;输入当月利润：(万元)&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        double lirun &#x3D; in.nextDouble();</span><br><span class="line">        if (lirun &lt;&#x3D; 10) &#123;</span><br><span class="line">            sum &#x3D; lirun * 0.1;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 20) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + (lirun - 10) * 0.075;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 40) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + (lirun - 20) * 0.05;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 60) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + (lirun - 40) * 0.03;</span><br><span class="line">        &#125; else if (lirun &lt;&#x3D; 100) &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + 10*0.03 + (lirun - 60) * 0.015;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum &#x3D; 10*0.1 + 10*0.075 + 10*0.05 + 10*0.03 + 10*0.015 + (lirun - 100) * 0.01;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;应发的奖金是：&quot;+sum+&quot;(万元)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"><a href="#一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？" class="headerlink" title="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"></a>一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？</h2><p>1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上168后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo13 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int x&#x3D;1;x&lt;100000;x++)&#123;</span><br><span class="line">          if(Math.sqrt(x+100)%1&#x3D;&#x3D;0)</span><br><span class="line">          if(Math.sqrt(x+100+168)%1&#x3D;&#x3D;0)</span><br><span class="line">            System.out.println(x+&quot;加上100后是一个完全平方数，加上168又是一个完全平方数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入某年某月某日，判断这一天是这一年的第几天？"><a href="#输入某年某月某日，判断这一天是这一年的第几天？" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天？"></a>输入某年某月某日，判断这一天是这一年的第几天？</h2><p>1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本月的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入年,月,日：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int year &#x3D; in.nextInt();</span><br><span class="line">        int month &#x3D; in.nextInt();</span><br><span class="line">        int day &#x3D; in.nextInt();</span><br><span class="line">        Calendar cal &#x3D; Calendar.getInstance();</span><br><span class="line">        cal.set(year, month - 1, day);</span><br><span class="line">        int sum &#x3D; cal.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(&quot;这一天是这一年的第&quot; + sum +&quot;天&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int year,month,day,sum&#x3D;0;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入年：&quot;);</span><br><span class="line">        year&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入月：&quot;);</span><br><span class="line">        month&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入日：&quot;);</span><br><span class="line">        day&#x3D;in.nextInt();</span><br><span class="line"></span><br><span class="line">        switch(month)&#123;</span><br><span class="line">        case 1:</span><br><span class="line">            sum&#x3D;0;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            sum&#x3D;31;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            sum&#x3D;59;</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            sum&#x3D;90;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">            sum&#x3D;120;</span><br><span class="line">            break;</span><br><span class="line">        case 6:</span><br><span class="line">            sum&#x3D;151;</span><br><span class="line">            break;</span><br><span class="line">        case 7:</span><br><span class="line">            sum&#x3D;181;</span><br><span class="line">            break;</span><br><span class="line">        case 8:</span><br><span class="line">            sum&#x3D;212;</span><br><span class="line">            break;</span><br><span class="line">        case 9:</span><br><span class="line">            sum&#x3D;243;</span><br><span class="line">            break;</span><br><span class="line">        case 10:</span><br><span class="line">            sum&#x3D;273;</span><br><span class="line">            break;</span><br><span class="line">        case 11:</span><br><span class="line">            sum&#x3D;304;</span><br><span class="line">            break;</span><br><span class="line">        case 12:</span><br><span class="line">            sum&#x3D;334;</span><br><span class="line">            break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;wrong input!&quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum&#x3D;sum+day;</span><br><span class="line">        boolean leap;</span><br><span class="line">        if(year%400&#x3D;&#x3D;0||(year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0))&#123;</span><br><span class="line">            leap&#x3D;true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            leap&#x3D;false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(leap&amp;&amp;month&gt;2)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;It is the &quot;+sum+&quot;th day.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;请输入年 月 日：&quot;);</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        int year&#x3D;in.nextInt();</span><br><span class="line">        int month&#x3D;in.nextInt();</span><br><span class="line">        int day&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;是该年的第&quot;+count(year,month,day)+&quot;天&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int count(int year,int month,int day)&#123;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        int days&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;month;i++)&#123;</span><br><span class="line">            switch(i)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">            case 3:</span><br><span class="line">            case 5:</span><br><span class="line">            case 7:</span><br><span class="line">            case 8:</span><br><span class="line">            case 10:</span><br><span class="line">            case 12:</span><br><span class="line">                days&#x3D;31;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">            case 6:</span><br><span class="line">            case 9:</span><br><span class="line">            case 11:</span><br><span class="line">                days&#x3D;30;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                if(year%400&#x3D;&#x3D;0||year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)&#123;</span><br><span class="line">                    days&#x3D;29;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    days&#x3D;28;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+&#x3D;days;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+&#x3D;day;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入三个整数x-y-z，请把这三个数由小到大输出。"><a href="#输入三个整数x-y-z，请把这三个数由小到大输出。" class="headerlink" title="输入三个整数x,y,z，请把这三个数由小到大输出。"></a>输入三个整数x,y,z，请把这三个数由小到大输出。</h2><p>1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt;y则将x与y的值进行交换，然后再用x与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(&quot;请输入三个数:&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] arr &#x3D; new int[3];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x &gt; y) &#123; int t &#x3D; x; x &#x3D; y; y &#x3D; t; &#125; if(x &gt; z) &#123; int t &#x3D; x; x &#x3D; z; z &#x3D; t; &#125; if(y &gt; z) &#123; int t &#x3D; y; y &#x3D; z; z &#x3D; t; &#125;</span><br></pre></td></tr></table></figure><h2 id="输出9-9口诀乘法表。"><a href="#输出9-9口诀乘法表。" class="headerlink" title="输出9*9口诀乘法表。"></a>输出9*9口诀乘法表。</h2><p>1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。<br>出现重复的乘积（全矩形）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; 9; j++)</span><br><span class="line">                System.out.print(i + &quot;*&quot; + j + &quot;&#x3D;&quot; + (i*j) + &quot;\\t&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不现重复的乘积(下三角)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; i; j++)</span><br><span class="line">                System.out.print(i + &quot;*&quot; + j + &quot;&#x3D;&quot; + (i*j) + &quot;\\t&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴子吃桃问题"><a href="#猴子吃桃问题" class="headerlink" title="猴子吃桃问题"></a>猴子吃桃问题</h2><p>猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。<br>1.程序分析：采取逆向思维的方法，从后往前推断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo17 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int sum &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 9; i++) &#123;</span><br><span class="line">            sum &#x3D; (sum + 1) * 2;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第一天共摘&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乒乓球比赛"><a href="#乒乓球比赛" class="headerlink" title="乒乓球比赛"></a>乒乓球比赛</h2><p>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Demo18 &#123;</span><br><span class="line">    static char[] m &#x3D; &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;;</span><br><span class="line">    static char[] n &#x3D; &#123; &#39;x&#39;, &#39;y&#39;, &#39;z&#39; &#125;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n.length; j++) &#123;</span><br><span class="line">                if (m[i] &#x3D;&#x3D; &#39;a&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;x&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if (m[i] &#x3D;&#x3D; &#39;a&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;y&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if ((m[i] &#x3D;&#x3D; &#39;c&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;x&#39;)</span><br><span class="line">                        || (m[i] &#x3D;&#x3D; &#39;c&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;z&#39;)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if ((m[i] &#x3D;&#x3D; &#39;b&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;z&#39;)</span><br><span class="line">                        || (m[i] &#x3D;&#x3D; &#39;b&#39; &amp;&amp; n[j] &#x3D;&#x3D; &#39;y&#39;)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else</span><br><span class="line">                    System.out.println(m[i] + &quot; vs &quot; + n[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Demo18 &#123;</span><br><span class="line">    public String a, b, c;</span><br><span class="line">    public Demo18(String a, String b, String c) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">        this.b &#x3D; b;</span><br><span class="line">        this.c &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo18 arr_a &#x3D; new Demo18(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">        String[] b &#x3D; &#123; &quot;x&quot;, &quot;y&quot;, &quot;z&quot; &#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">                 Demo18 arr_b &#x3D; new Demo18(b[i], b[j], b[k]);</span><br><span class="line">                    if (!arr_b.a.equals(arr_b.b) &amp; !arr_b.b.equals(arr_b.c)</span><br><span class="line">                            &amp; !arr_b.c.equals(arr_b.a) &amp; !arr_b.a.equals(&quot;x&quot;)</span><br><span class="line">                            &amp; !arr_b.c.equals(&quot;x&quot;) &amp; !arr_b.c.equals(&quot;z&quot;)) &#123;</span><br><span class="line">                        System.out.println(arr_a.a + &quot;--&quot; + arr_b.a);</span><br><span class="line">                        System.out.println(arr_a.b + &quot;--&quot; + arr_b.b);</span><br><span class="line">                        System.out.println(arr_a.c + &quot;--&quot; + arr_b.c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出如下图案（三角形-菱形）"><a href="#打印出如下图案（三角形-菱形）" class="headerlink" title="打印出如下图案（三角形\菱形）"></a>打印出如下图案（三角形\菱形）</h2><p>1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重for循环，第一层控制行，第二层控制列。</p><p><strong>三角形：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">***</span><br><span class="line">******</span><br><span class="line">********</span><br><span class="line">******</span><br><span class="line">***</span><br><span class="line">*</span><br><span class="line">public class Demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        for ( i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">            for ( j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        for ( i &#x3D; 3; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">            for ( j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>菱形：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   *</span><br><span class="line">  ***</span><br><span class="line"> *****</span><br><span class="line">*******</span><br><span class="line"> *****</span><br><span class="line">  ***</span><br><span class="line">   *</span><br><span class="line">public class Demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        for (i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; 4 - i; k++)</span><br><span class="line">                System.out.print( &quot; &quot; );</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 3; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; 4 - i; k++)</span><br><span class="line">                System.out.print( &quot; &quot; );</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; 2 * i - 1; j++)</span><br><span class="line">                System.out.print(&quot;*&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。"><a href="#有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。" class="headerlink" title="有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。"></a>有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。</h2><p>1.程序分析：请抓住分子与分母的变化规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo20 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float fm &#x3D; 1.0f;</span><br><span class="line">        float fz &#x3D; 1.0f;</span><br><span class="line">        float temp;</span><br><span class="line">        float sum &#x3D; 0f;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            temp &#x3D; fm;</span><br><span class="line">            fm &#x3D; fz;</span><br><span class="line">            fz &#x3D; fz + temp;</span><br><span class="line">            System.out.println((int) fz + &quot;&#x2F;&quot; + (int) fm);</span><br><span class="line">            sum +&#x3D; fz &#x2F; fm;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求1-2-3-…-20-的和"><a href="#求1-2-3-…-20-的和" class="headerlink" title="求1+2!+3!+…+20!的和"></a>求1+2!+3!+…+20!的和</h2><p>1.程序分析：此程序只是把累加变成了累乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo21 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long sum &#x3D; 0;</span><br><span class="line">        long fac &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 20; i++) &#123;</span><br><span class="line">            fac &#x3D; fac * i;</span><br><span class="line">            sum +&#x3D; fac;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用递归方法求5"><a href="#利用递归方法求5" class="headerlink" title="利用递归方法求5!"></a>利用递归方法求5!</h2><p>1.程序分析：递归公式：f(n)=f(n-1)*4!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo22 &#123;</span><br><span class="line">    public static long fac(int n) &#123;</span><br><span class="line">        long value &#x3D; 0;</span><br><span class="line">        if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            value &#x3D; 1;</span><br><span class="line">        &#125; else if (n &gt; 1) &#123;</span><br><span class="line">            value &#x3D; n * fac(n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入一个数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(n + &quot;的阶乘为：&quot; + fac(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算年龄"><a href="#计算年龄" class="headerlink" title="计算年龄"></a>计算年龄</h2><p>有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？</p><p>1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10岁），再往回推。</p><p>直接求解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n &#x3D; 10;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">            n &#x3D; n + 2;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第五个人&quot; + n + &quot;岁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归求解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo23 &#123;</span><br><span class="line">    public static int getAge(int n) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return 2 + getAge(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;第五个的年龄为&quot; + getAge(5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"><a href="#给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。" class="headerlink" title="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"></a>给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。</h2><p>本题原方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo24 use &#x3D; new Demo24();</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        long a &#x3D; in.nextLong();</span><br><span class="line">        if (a &lt; 0 || a &gt;&#x3D; 100000) &#123;</span><br><span class="line">            System.out.println(&quot;Error Input, please run this program Again!&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a &gt;&#x3D; 0 &amp;&amp; a &lt;&#x3D; 9) &#123;</span><br><span class="line">            System.out.println(a + &quot;是一位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;  + a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 10 &amp;&amp; a &lt;&#x3D; 99) &#123;</span><br><span class="line">            System.out.println(a + &quot;是二位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 100 &amp;&amp; a &lt;&#x3D; 999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是三位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 1000 &amp;&amp; a &lt;&#x3D; 9999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是四位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; else if (a &gt;&#x3D; 10000 &amp;&amp; a &lt;&#x3D; 99999) &#123;</span><br><span class="line">            System.out.println(a + &quot;是五位数&quot;);</span><br><span class="line">            System.out.println(&quot;按逆序输出是:&quot;);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void converse(long l) &#123;</span><br><span class="line">        String s &#x3D; Long.toString(l);</span><br><span class="line">        char[] ch &#x3D; s.toCharArray();</span><br><span class="line">        for (int i &#x3D; ch.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.print(ch[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人版方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        if (str.matches(&quot;\\\\d+&quot;)) &#123; &#x2F;&#x2F;正则表达式</span><br><span class="line">            System.out.println(&quot;输入的是&quot; + str.length() + &quot;位数&quot;);</span><br><span class="line">            StringBuffer buf &#x3D; new StringBuffer(str);</span><br><span class="line">            System.out.println(buf.reverse());&#x2F;&#x2F;字符串反转</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"><a href="#一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。" class="headerlink" title="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"></a>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</h2><p>原方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Palindrom &#123;</span><br><span class="line">    static int[] a &#x3D; new int[5];</span><br><span class="line">    static int[] b &#x3D; new int[5];</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        boolean is &#x3D; false;</span><br><span class="line">        System.out.println(&quot;Please input：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        long l &#x3D; in.nextLong();</span><br><span class="line">        if (l &gt; 99999 || l &lt; 10000) &#123;</span><br><span class="line">            System.out.println(&quot;Input error, please input again!&quot;);</span><br><span class="line">            l &#x3D; in.nextLong();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 4; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            a[i] &#x3D; (int) (l &#x2F; (long) Math.pow(10, i));</span><br><span class="line">            l &#x3D; (l % (long) Math.pow(10, i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 0; i &lt; 5; i++, j++) &#123;</span><br><span class="line">            b[j] &#x3D; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 4; i &lt; 5; i++, j--) &#123;</span><br><span class="line">            if (a[i] !&#x3D; b[j]) &#123;</span><br><span class="line">                is &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                is &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (is &#x3D;&#x3D; false) &#123;</span><br><span class="line">            System.out.println(&quot;is not a Palindrom!&quot;);</span><br><span class="line">        &#125; else if (is &#x3D;&#x3D; true) &#123;</span><br><span class="line">            System.out.println(&quot;is a Palindrom!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Palindrom &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        int l &#x3D; Integer.parseInt(str);&#x2F;&#x2F;转换成整数</span><br><span class="line">        if (l &lt; 10000 || l &gt; 99999) &#123;</span><br><span class="line">            System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean is&#x3D;false;</span><br><span class="line">        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">        for(int i&#x3D;0;i&lt;ch.length&#x2F;2;i++)&#123;</span><br><span class="line">            if(ch[i]!&#x3D;ch[ch.length-i-1])&#123;</span><br><span class="line">                is&#x3D;false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                is&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(is)&#123;</span><br><span class="line">            System.out.println(&quot;这是一个回文!&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;不是一个回文!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。"><a href="#请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。" class="headerlink" title="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。"></a>请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。</h2><p>1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo26 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char weekSecond;&#x2F;&#x2F;保存第二字母</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);&#x2F;&#x2F;接收用户输入</span><br><span class="line">        System.out.println(&quot;请输入星期的第一个字母：&quot;);</span><br><span class="line">        String letter &#x3D; in.next();</span><br><span class="line">        if (letter.length() &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;判断用户控制台输入字符串长度是否是一个字母</span><br><span class="line">            char weekFirst &#x3D; letter.charAt(0);&#x2F;&#x2F;取第一个字符</span><br><span class="line">            switch (weekFirst) &#123;</span><br><span class="line">            case &#39;m&#39;:</span><br><span class="line">            case &#39;M&#39;:</span><br><span class="line">                System.out.println(&quot;星期一(Monday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;t&#39;:</span><br><span class="line">            case &#39;T&#39;:</span><br><span class="line">                System.out.print(&quot;由于星期二(Tuesday)与星期四(Thursday)均以字母T开头，故需输入第二个字母才能正确判断：&quot;);</span><br><span class="line">                letter &#x3D; in.next();</span><br><span class="line">                if (letter.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    weekSecond &#x3D; letter.charAt(0);</span><br><span class="line">                    if (weekSecond &#x3D;&#x3D; &#39;U&#39; || weekSecond &#x3D;&#x3D; &#39;u&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期二(Tuesday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else if (weekSecond &#x3D;&#x3D; &#39;H&#39; || weekSecond &#x3D;&#x3D; &#39;h&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期四(Thursday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;Error!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case &#39;w&#39;:</span><br><span class="line">            case &#39;W&#39;:</span><br><span class="line">                System.out.println(&quot;星期三(Wednesday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;f&#39;:</span><br><span class="line">            case &#39;F&#39;:</span><br><span class="line">                System.out.println(&quot;星期五(Friday)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &#39;s&#39;:</span><br><span class="line">            case &#39;S&#39;:</span><br><span class="line">                System.out.print(&quot;由于星期六(Saturday)与星期日(Sunday)均以字母S开头，故需输入第二个字母才能正确判断：&quot;);</span><br><span class="line">                letter &#x3D; in.next();</span><br><span class="line">                if (letter.length() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    weekSecond &#x3D; letter.charAt(0);</span><br><span class="line">                    if (weekSecond &#x3D;&#x3D; &#39;A&#39; || weekSecond &#x3D;&#x3D; &#39;a&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期六(Saturday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else if (weekSecond &#x3D;&#x3D; &#39;U&#39; || weekSecond &#x3D;&#x3D; &#39;u&#39;) &#123;</span><br><span class="line">                        System.out.println(&quot;星期日(Sunday)&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;Error!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;输入错误，不能识别的星期值第一个字母，程序结束！&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求100之内的素数"><a href="#求100之内的素数" class="headerlink" title="求100之内的素数"></a>求100之内的素数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo27 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int sum, i;</span><br><span class="line">        for (sum &#x3D; 2; sum &lt;&#x3D; 100; sum++) &#123;</span><br><span class="line">            for (i &#x3D; 2; i &lt;&#x3D; sum &#x2F; 2; i++) &#123;</span><br><span class="line">                if (sum % i &#x3D;&#x3D; 0)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt; sum &#x2F; 2)</span><br><span class="line">                System.out.println(sum + &quot;是素数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo27&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        int w&#x3D;1;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;100;i++)&#123;</span><br><span class="line">            for(int j&#x3D;2;j&lt;i;j++)&#123;</span><br><span class="line">                w&#x3D;i%j;</span><br><span class="line">                if(w&#x3D;&#x3D;0)break;</span><br><span class="line">                &#125;</span><br><span class="line">            if(w!&#x3D;0)</span><br><span class="line">                System.out.println(i+&quot;是素数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对10个数进行排序。"><a href="#对10个数进行排序。" class="headerlink" title="对10个数进行排序。"></a>对10个数进行排序。</h2><p>1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，下次类推，即用第二个元素与后8个进行比较，并进行交换。<br>本例代码为生成随机10个数排序，并输入1个数，插入重排序输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo28 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] &#x3D; new int[11];</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; r.nextInt(100) + 1; &#x2F;&#x2F;得到10个100以内的整数</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] +&quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;\nPlease Input a int number:&quot; );</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        arr[10] &#x3D; in.nextInt();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] +&quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo28 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入10个数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] arr &#x3D; new int[10];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原数组为：&quot;);</span><br><span class="line">        for (int x : arr) &#123;&#x2F;&#x2F;foreach遍历</span><br><span class="line">            System.out.print( x + &quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;排序后为：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot;\\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求一个3-3矩阵主对角线元素之和"><a href="#求一个3-3矩阵主对角线元素之和" class="headerlink" title="求一个3*3矩阵主对角线元素之和"></a>求一个3*3矩阵主对角线元素之和</h2><p>1.程序分析：利用双重for循环控制输入二维数组，再将a[i][i]累加后输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo29 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double sum &#x3D; 0;</span><br><span class="line">        int array[][] &#x3D; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 7, 8 &#125; &#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)</span><br><span class="line">                    sum &#x3D; sum + array[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主负对角线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        for(j&#x3D;0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           if(i&#x3D;&#x3D;j) sum1+&#x3D;a[i][j];</span><br><span class="line">           if(i+j&#x3D;&#x3D;n-1) sum2+&#x3D;a[i][j];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>##有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。</p><p>1.程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，插入后此元素之后的数，依次后移一个位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">public class Demo30 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        int arr[] &#x3D; new int[12];</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)</span><br><span class="line">            arr[i] &#x3D; r.nextInt(1000);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)</span><br><span class="line">            System.out.print(arr[i] + &quot;\\t&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 9; i++)</span><br><span class="line">            for (int k &#x3D; i + 1; k &lt;&#x3D; 10; k++)</span><br><span class="line">                if (arr[i] &gt; arr[k]) &#123;</span><br><span class="line">                    temp &#x3D; arr[i];</span><br><span class="line">                    arr[i] &#x3D; arr[k];</span><br><span class="line">                    arr[k] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 10; k++)</span><br><span class="line">            System.out.print(arr[k] + &quot;\\t&quot;);</span><br><span class="line">        arr[11] &#x3D; r.nextInt(1000);</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 10; k++)</span><br><span class="line">            if (arr[k] &gt; arr[11]) &#123;</span><br><span class="line">                temp &#x3D; arr[11];</span><br><span class="line">                for (int j &#x3D; 11; j &gt;&#x3D; k + 1; j--)</span><br><span class="line">                    arr[j] &#x3D; arr[j - 1];</span><br><span class="line">                    arr[k] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int k &#x3D; 0; k &lt;&#x3D; 11; k++)</span><br><span class="line">            System.out.print(arr[k] + &quot;\\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一个数组逆序输出"><a href="#将一个数组逆序输出" class="headerlink" title="将一个数组逆序输出"></a>将一个数组逆序输出</h2><p>程序分析：用第一个与最后一个交换。</p><p>用逆序循环控制变量输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo31 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 &#125;;</span><br><span class="line">        for (int i &#x3D; a.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取一个整数a从右端开始的第4～7位数字。"><a href="#取一个整数a从右端开始的第4～7位数字。" class="headerlink" title="取一个整数a从右端开始的第4～7位数字。"></a>取一个整数a从右端开始的第4～7位数字。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo32 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个7位以上的正整数：&quot;);</span><br><span class="line">        long l &#x3D; in.nextLong();</span><br><span class="line">        String str &#x3D; Long.toString(l);</span><br><span class="line">        char[] ch &#x3D; str.toCharArray();</span><br><span class="line">        int j&#x3D;ch.length;</span><br><span class="line">        if (j&lt;7)&#123;System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;截取从右端开始的4～7位是：&quot;+ch[j-7]+ch[j-6]+ch[j-5]+ch[j-4]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo32&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a &#x3D; 0;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        long b &#x3D; s.nextLong();</span><br><span class="line">        a &#x3D; (int) (b % 10000000 &#x2F; 1000);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出杨辉三角形（要求打印出10行如下图）"><a href="#打印出杨辉三角形（要求打印出10行如下图）" class="headerlink" title="打印出杨辉三角形（要求打印出10行如下图）"></a>打印出杨辉三角形（要求打印出10行如下图）</h2><p>1.程序分析：<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo33 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        int a[][];</span><br><span class="line">        int n &#x3D; 10;</span><br><span class="line">        a &#x3D; new int[n][n];</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            a[i][i] &#x3D; 1;</span><br><span class="line">            a[i][0] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 2; i &lt; n; i++) &#123;</span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; i - 1; j++) &#123;</span><br><span class="line">                a[i][j] &#x3D; a[i - 1][j - 1] + a[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt;&#x3D; i; j++) &#123;</span><br><span class="line">                System.out.printf(a[i][j] + &quot;\\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入3个数a-b-c，按大小顺序输出。"><a href="#输入3个数a-b-c，按大小顺序输出。" class="headerlink" title="输入3个数a,b,c，按大小顺序输出。"></a>输入3个数a,b,c，按大小顺序输出。</h2><p>（也可互相比较交换排序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Demo34 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arrays &#x3D; &#123; 800, 56, 500 &#125;;</span><br><span class="line">        Arrays.sort(arrays);</span><br><span class="line">        for (int n &#x3D; 0; n &lt; arrays.length; n++)</span><br><span class="line">            System.out.println(arrays[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x &gt; y) &#123; int t &#x3D; x; x &#x3D; y; y &#x3D; t; &#125; if(x &gt; z) &#123; int t &#x3D; x; x &#x3D; z; z &#x3D; t; &#125; if(y &gt; z) &#123; int t &#x3D; y; y &#x3D; z; z &#x3D; t; &#125;</span><br></pre></td></tr></table></figure><h2 id="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。"><a href="#输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。" class="headerlink" title="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。"></a>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo35 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i, min&#x3D;0, max&#x3D;0, n, temp1, temp2;</span><br><span class="line">        int a[];</span><br><span class="line">        System.out.println(&quot;定义数组的长度:&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        n &#x3D; in.nextInt();</span><br><span class="line">        a &#x3D; new int[n];</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(&quot;输入第&quot; + (i + 1) + &quot;个数据:&quot;);</span><br><span class="line">            a[i] &#x3D; in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            if (a[i] &gt; a[max])</span><br><span class="line">                max &#x3D; i;</span><br><span class="line">            if (a[i] &lt; a[min])</span><br><span class="line">                min &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp1 &#x3D; a[0];</span><br><span class="line">        a[0] &#x3D; a[max];</span><br><span class="line">        a[max] &#x3D; temp1;</span><br><span class="line"></span><br><span class="line">        temp2 &#x3D; a[min];</span><br><span class="line"></span><br><span class="line">        if (min !&#x3D; 0) &#123; &#x2F;&#x2F; 如果最小值不是a[0]，执行下面</span><br><span class="line">            a[min] &#x3D; a[n - 1];</span><br><span class="line">            a[n - 1] &#x3D; temp2;</span><br><span class="line">        &#125; else &#123;  &#x2F;&#x2F;如果最小值是a[0],执行下面</span><br><span class="line">            a[max] &#x3D; a[n - 1];</span><br><span class="line">            a[n - 1] &#x3D; temp1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数"><a href="#有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数" class="headerlink" title="有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数"></a>有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo36 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入数字个数n：&quot;);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        System.out.println(&quot;输入后移位数m：&quot;);</span><br><span class="line">        int m &#x3D; in.nextInt();</span><br><span class="line">        LinkedList&lt;Integer&gt; list &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个数:&quot;);</span><br><span class="line">            list.add(in.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原数据排序为：&quot;);</span><br><span class="line">        for (int t : list) &#123;</span><br><span class="line">            System.out.print(t + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;Integer&gt; temp1 &#x3D; list.subList(list.size() - m, list.size());</span><br><span class="line">        List&lt;Integer&gt; temp2 &#x3D; list.subList(0, list.size() - m);</span><br><span class="line">        temp2.addAll(0, temp1);</span><br><span class="line">        System.out.println(&quot;移动后排序为;&quot;);</span><br><span class="line">        for (int t : temp2) &#123;</span><br><span class="line">            System.out.print(t + &quot; &quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo36&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请定义数组的长度：&quot;);</span><br><span class="line">        int n&#x3D;in.nextInt();</span><br><span class="line">        System.out.println(&quot;请输入移动的位数：&quot;);</span><br><span class="line">        int m&#x3D;in.nextInt();</span><br><span class="line">        int [] arr&#x3D;new int [n];</span><br><span class="line">        int [] brr&#x3D;new int [n];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个数：&quot;);</span><br><span class="line">            arr[i]&#x3D;in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序前：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            brr[i]&#x3D;arr[n-m+i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n-m;i++)&#123;</span><br><span class="line">            arr[m+i]&#x3D;arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i]&#x3D;brr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序后：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。</p><p>（约瑟夫环问题，百度百科有时间复杂度最简单的数学方法）</p><p>原例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输人数n：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        boolean[] arr &#x3D; new boolean[n];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; true; &#x2F;&#x2F;下标为TRUE时说明还在圈里</span><br><span class="line">        &#125;</span><br><span class="line">        int leftCount &#x3D; n;</span><br><span class="line">        int countNum &#x3D; 0;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (leftCount &gt; 1) &#123;</span><br><span class="line">            if (arr[index] &#x3D;&#x3D; true) &#123; &#x2F;&#x2F;当在圈里时</span><br><span class="line">                countNum++;  &#x2F;&#x2F;报数递加</span><br><span class="line">                if (countNum &#x3D;&#x3D; 3) &#123; &#x2F;&#x2F;报数为3时</span><br><span class="line">                    countNum &#x3D; 0; &#x2F;&#x2F;从零开始继续报数</span><br><span class="line">                    arr[index] &#x3D; false; &#x2F;&#x2F;此人退出圈子</span><br><span class="line">                    leftCount--; &#x2F;&#x2F;剩余人数减一</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++; &#x2F;&#x2F;每报一次数，下标加一</span><br><span class="line">            if (index &#x3D;&#x3D; n) &#123; &#x2F;&#x2F;是循环数数，当下标大于n时，说明已经数了一圈，</span><br><span class="line">                index &#x3D; 0; &#x2F;&#x2F;将下标设为零重新开始。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (arr[i] &#x3D;&#x3D; true) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入人数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] a &#x3D; new int[in.nextInt()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int left &#x3D; a.length;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        while (left &gt; 1) &#123;</span><br><span class="line">            if (a[j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (num &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                a[j] &#x3D; 0;</span><br><span class="line">                num &#x3D; 0;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            if (j &#x3D;&#x3D; a.length) &#123;</span><br><span class="line">                j &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                System.out.println(&quot;最后留下的人是&quot;+ (i + 1) + &quot;号&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo37 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; l &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        System.out.println(&quot;请输入人数：&quot;);</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int len &#x3D; in.nextInt();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            l.add(i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; sum !&#x3D; len - 1;) &#123;</span><br><span class="line">            if (l.get(i) !&#x3D; 0) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                l.remove(i);</span><br><span class="line">                l.add(i, 0);</span><br><span class="line">                temp &#x3D; 0;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            if (i &#x3D;&#x3D; l.size()) &#123;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int t : l) &#123;</span><br><span class="line">            if (t !&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(&quot;最后留下的人是&quot; + t + &quot;号&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。"><a href="#写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。" class="headerlink" title="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。"></a>写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo38 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String mys &#x3D; in.next();</span><br><span class="line">        System.out.println(str_len(mys));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int str_len(String x) &#123;</span><br><span class="line">        return x.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo38 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String mys &#x3D; in.next();</span><br><span class="line">        System.out.println(mys.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写一个函数，输入n为偶数时，调用函数求1-2-1-4-…-1-n-当输入n为奇数时，调用函数1-1-1-3-…-1-n"><a href="#编写一个函数，输入n为偶数时，调用函数求1-2-1-4-…-1-n-当输入n为奇数时，调用函数1-1-1-3-…-1-n" class="headerlink" title="编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n"></a>编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo39 &#123;</span><br><span class="line">    public static double ouShu(int n) &#123;</span><br><span class="line">        double result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; n; i &#x3D; i + 2) &#123;</span><br><span class="line">            result +&#x3D;  1 &#x2F; (double) i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public static double jiShu(int n) &#123;</span><br><span class="line">        double result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i &#x3D; i + 2) &#123;</span><br><span class="line">            result +&#x3D; 1 &#x2F; (double) i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入n的值：&quot;);</span><br><span class="line">        int n &#x3D; in.nextInt();</span><br><span class="line">        if (n % 2 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;偶数，1&#x2F;2+1&#x2F;4+...+1&#x2F;n</span><br><span class="line">            System.out.println(ouShu(n));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;奇数，1&#x2F;1+1&#x2F;3+...+1&#x2F;n</span><br><span class="line">            System.out.println(jiShu(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><p>（利用容器类中的sort方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo40 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(&quot;010102&quot;);</span><br><span class="line">        list.add(&quot;010003&quot;);</span><br><span class="line">        list.add(&quot;010201&quot;);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Demo40 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请定义字符串的个数：&quot;);</span><br><span class="line">        int n&#x3D;in.nextInt();</span><br><span class="line">        String[] str&#x3D;new String[n];</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.length;i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;字符串：&quot;);</span><br><span class="line">            str[i]&#x3D;in.next();</span><br><span class="line">        &#125;</span><br><span class="line">        strSort(n,str);</span><br><span class="line">        System.out.println(&quot;字符串排序后：&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.length;i++)&#123;</span><br><span class="line">            System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void strSort(int n,String[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++) &#123;</span><br><span class="line">            for(int j&#x3D;i+1; j&lt;n; j++) &#123;</span><br><span class="line">                if(compare(arr[i], arr[j]) &#x3D;&#x3D; false) &#123;</span><br><span class="line">                    String temp &#x3D; arr[i]; arr[i] &#x3D; arr[j]; arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static boolean compare(String s1, String s2) &#123;</span><br><span class="line">        boolean result &#x3D; true;</span><br><span class="line">        for(int i&#x3D;0; i&lt;s1.length() &amp;&amp; i&lt;s2.length(); i++) &#123;</span><br><span class="line">            if(s1.charAt(i) &gt; s2.charAt(i)) &#123;</span><br><span class="line">                result &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if(s1.charAt(i) &lt;s2.charAt(i)) &#123;</span><br><span class="line">                result &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(s1.length() &lt; s2.length()) &#123;</span><br><span class="line">                    result &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴子分桃"><a href="#猴子分桃" class="headerlink" title="猴子分桃"></a>猴子分桃</h2><p>海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？</p><p>本题源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Demo41 &#123;</span><br><span class="line">    static int ts &#x3D; 0;&#x2F;&#x2F; 桃子总数</span><br><span class="line">    int fs &#x3D; 1;&#x2F;&#x2F; 记录分的次数</span><br><span class="line">    static int hs &#x3D; 5;&#x2F;&#x2F; 猴子数</span><br><span class="line">    int tsscope &#x3D; 5000;&#x2F;&#x2F; 桃子数的取值范围，太大容易溢出。</span><br><span class="line">    public int fT(int t) &#123;</span><br><span class="line">        if (t &#x3D;&#x3D; tsscope) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当桃子数到了最大的取值范围时取消递归</span><br><span class="line">            System.out.println(&quot;结束&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ((t - 1) % hs &#x3D;&#x3D; 0 &amp;&amp; fs &lt;&#x3D; hs) &#123;</span><br><span class="line">                if (fs &#x3D;&#x3D; hs) &#123;</span><br><span class="line">                    System.out.println(&quot;桃子数&#x3D;&quot; + ts + &quot;时满足分桃条件&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                fs +&#x3D; 1;</span><br><span class="line">                return fT((t - 1) &#x2F; 5 * 4);&#x2F;&#x2F; 返回猴子拿走一份后的剩下的总数</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 没满足条件</span><br><span class="line">                fs &#x3D; 1;&#x2F;&#x2F; 分的次数重置为1</span><br><span class="line">                return fT(ts +&#x3D; 1);&#x2F;&#x2F; 桃子数加+1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Demo41().fT(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo41 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 6;; i++) &#123;&#x2F;&#x2F; 最少6个分最后一次</span><br><span class="line">            sum &#x3D; i;&#x2F;&#x2F; 桃子数</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 5; j++) &#123;&#x2F;&#x2F; 分的次数循环</span><br><span class="line">                if ((sum - 1) % 5 &#x3D;&#x3D; 0 &amp;&amp; j &lt; 5) &#123;&#x2F;&#x2F; 如果扔一个后能均分5份，继续分</span><br><span class="line">                    sum &#x3D; (sum - 1) &#x2F; 5 * 4;&#x2F;&#x2F; 每分一次剩余桃子数</span><br><span class="line">                    if (j &#x3D;&#x3D; 4) &#123;&#x2F;&#x2F; 如果已分5次，且仍能除尽，输出，退出程序</span><br><span class="line">                        System.out.println(i);</span><br><span class="line">                        System.exit(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="809-800-9-1。其中-代表的两位数-8-的结果为两位数，9-的结果为3位数。求-代表的两位数，及809-后的结果。"><a href="#809-800-9-1。其中-代表的两位数-8-的结果为两位数，9-的结果为3位数。求-代表的两位数，及809-后的结果。" class="headerlink" title="809*??=800*??+9*??+1。其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。"></a>809*??=800*??+9*??+1。其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。</h2><p>（本题为无解，去掉1有解）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo42 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 10; i &lt; 100; i++) &#123;</span><br><span class="line">            if (809 * i &#x3D;&#x3D; (800 * i + 9 * i + 1) &amp;&amp; 8 * i &gt;&#x3D; 10 &amp;&amp; 8 * i &lt; 100</span><br><span class="line">                    &amp;&amp; 9 * i &gt;&#x3D; 100 &amp;&amp; 9 * i &lt; 1000) &#123;</span><br><span class="line">                System.out.println(&quot;?? &#x3D;&quot; + i);</span><br><span class="line">                System.out.println(&quot;809*??&#x3D;&quot;+ 809 * i);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求0—7所能组成的奇数个数"><a href="#求0—7所能组成的奇数个数" class="headerlink" title="求0—7所能组成的奇数个数"></a>求0—7所能组成的奇数个数</h2><p>暴力算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static boolean isJiShu(int n) &#123;</span><br><span class="line">        if (n % 2 !&#x3D; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean fun(char c) &#123;</span><br><span class="line">        if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;7&#39;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        String s;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">            s &#x3D; &quot;&quot; + i;</span><br><span class="line">            boolean flag &#x3D; true;</span><br><span class="line">            char[] c &#x3D; s.toCharArray();</span><br><span class="line">            for (int j &#x3D; 0; j &lt; c.length; j++) &#123;</span><br><span class="line">                if (!fun(c[j])) &#123;</span><br><span class="line">                    flag &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag &amp;&amp; isJiShu(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            s &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;共&quot; + count + &quot;个。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 因为是奇数，所以个位只能是1，3，5，7共4种，前面可随便排列</span><br><span class="line">        int count &#x3D; 4;&#x2F;&#x2F; 个位的4种</span><br><span class="line">        &#x2F;&#x2F; 2位时，十位有8种，个位4种，8×4</span><br><span class="line">        &#x2F;&#x2F; 3位时，8×8×4……</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 8; i++) &#123;</span><br><span class="line">            count &#x3D; 8 * count;</span><br><span class="line">            System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;组成1位数是4个。</span><br><span class="line">&#x2F;&#x2F;组成2位数是7*4个。</span><br><span class="line">&#x2F;&#x2F;组成3位数是7*8*4个。</span><br><span class="line">&#x2F;&#x2F;组成4位数是7*8*8*4个。</span><br><span class="line"></span><br><span class="line">public class Demo43 &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        int sum&#x3D;4;</span><br><span class="line">        int j;</span><br><span class="line">        System.out.println(&quot;组成1位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        sum&#x3D;sum*7;</span><br><span class="line">        System.out.println(&quot;组成2位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        for(j&#x3D;3;j&lt;&#x3D;9;j++)&#123;</span><br><span class="line">            sum&#x3D;sum*8;</span><br><span class="line">            System.out.println(&quot;组成&quot;+j+&quot;位数是 &quot;+sum+&quot; 个&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个偶数总能表示为两个素数之和"><a href="#一个偶数总能表示为两个素数之和" class="headerlink" title="一个偶数总能表示为两个素数之和"></a>一个偶数总能表示为两个素数之和</h2><p>哥德巴赫猜想是想证明对任何大于6的自然数n之内的所有偶数可以表示为两个素数之和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo44 &#123;</span><br><span class="line">    public static boolean isSuShu(int x) &#123;</span><br><span class="line">        if (x &#x3D;&#x3D; 0 || x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; Math.sqrt(x); i++) &#123;</span><br><span class="line">            if (x % i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 求了下100以内的情况</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i &#x3D; i + 2)&#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;&#x3D; (i + 1) &#x2F; 2; j++)&#123;</span><br><span class="line">                if (isSuShu(j) &amp;&amp; isSuShu(i - j))&#123;</span><br><span class="line">                    System.out.println(i + &quot;&#x3D;&quot; + j + &quot;+&quot; + (i - j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Demo44&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for (int i&#x3D;6;i&lt;&#x3D;100 ;i+&#x3D;2 )&#123;</span><br><span class="line">            for (int j&#x3D;2;j&lt;100 ;j++ )&#123;</span><br><span class="line">                if(!isPrime(j)||!isPrime(i-j)||j&gt;&#x3D;i)</span><br><span class="line">                continue;</span><br><span class="line">                System.out.println(i+&quot;&#x3D;&quot;+j+&quot;+&quot;+(i-j));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isPrime(int n)&#123;</span><br><span class="line">        for (int i&#x3D;2;i&lt;n ;i++ )&#123;</span><br><span class="line">            if(n%i&#x3D;&#x3D;0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断几个9能被一个素数整除"><a href="#判断几个9能被一个素数整除" class="headerlink" title="判断几个9能被一个素数整除"></a>判断几个9能被一个素数整除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class Demo45&#123;</span><br><span class="line">    public static boolean isSuShu(int x)&#123;</span><br><span class="line">        if (x &#x3D;&#x3D; 0|| x &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; Math.sqrt(x); i++)&#123;</span><br><span class="line">            if (x % i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] a &#x3D; new int[100];</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 长度100的素数数组</span><br><span class="line">        while (n &lt; 100) &#123;</span><br><span class="line">            if (isSuShu(num)) &#123;</span><br><span class="line">                a[n] &#x3D; num;</span><br><span class="line">                n++;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* for (int t : a) &#123;</span><br><span class="line">         System.out.println(t);</span><br><span class="line">         &#125;*&#x2F;</span><br><span class="line">        String s &#x3D; &quot;9&quot;;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (s.length() &lt; 9) &#123;</span><br><span class="line">            if (new Integer(s).intValue() % a[index] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(s + &quot;%&quot; + a[index] + &quot;&#x3D;0&quot;);</span><br><span class="line">                if (index &lt; 100 - 1) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    index &#x3D; 0;</span><br><span class="line">                    s &#x3D; s + &quot;9&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; System.exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (index &lt; 100 - 1) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    index &#x3D; 0;</span><br><span class="line">                    s &#x3D; s + &quot;9&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）"><a href="#判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）" class="headerlink" title="判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）"></a>判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo45 &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个整数：&quot;);</span><br><span class="line">        int num &#x3D; in.nextInt();</span><br><span class="line">        int tmp &#x3D; num;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0 ; tmp%9 &#x3D;&#x3D; 0 ;)&#123;</span><br><span class="line">            tmp &#x3D; tmp&#x2F;9;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num+&quot; 能够被 &quot;+count+&quot; 个9 整除。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个字符串连接程序"><a href="#两个字符串连接程序" class="headerlink" title="两个字符串连接程序"></a>两个字符串连接程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo46 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入第一个字符串：&quot;);</span><br><span class="line">        String s1 &#x3D; in.next();</span><br><span class="line">        System.out.println(&quot;输入第一个字符串：&quot;);</span><br><span class="line">        String s2 &#x3D; in.next();</span><br><span class="line">        System.out.println(&quot;连接后：n&quot; + s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo46 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入一个字符串：&quot;);</span><br><span class="line">        String str1 &#x3D; in.nextLine();</span><br><span class="line">        System.out.print(&quot;请再输入一个字符串：&quot;);</span><br><span class="line">        String str2 &#x3D; in.nextLine();</span><br><span class="line">        String str &#x3D; str1+str2;</span><br><span class="line">        System.out.println(&quot;连接后的字符串是：&quot;+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的-号"><a href="#读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的-号" class="headerlink" title="读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的*号"></a>读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的*号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo47 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int n&#x3D;1,num;</span><br><span class="line">        while(n&lt;&#x3D;7)&#123;</span><br><span class="line">            do&#123;</span><br><span class="line">                System.out.print(&quot;请输入一个1--50 之间的整数：&quot;);</span><br><span class="line">                num&#x3D; s.nextInt();</span><br><span class="line">            &#125;while(num&lt;1||num&gt;50);</span><br><span class="line">            for(int i&#x3D;1;i&lt;&#x3D;num;i++)</span><br><span class="line">            &#123;System.out.print(&quot;*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo47 &#123;</span><br><span class="line">    public static void print(int n) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(&quot;*&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 7; i++) &#123;</span><br><span class="line">            int temp &#x3D; in.nextInt();</span><br><span class="line">            print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"><a href="#某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。" class="headerlink" title="某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"></a>某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo48&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个4位数字：&quot;);</span><br><span class="line">        String str &#x3D; in.next();</span><br><span class="line">        if (!((str).matches(&quot;\\d&#123;4&#125;&quot;))) &#123;</span><br><span class="line">            System.out.println(&quot;输入的不是4位数字！&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        char[] c &#x3D; str.toCharArray();</span><br><span class="line">        int[] a &#x3D; new int[4];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] &#x3D; ((int) (c[i] - &#39;0&#39;) + 5) % 10;</span><br><span class="line">        &#125;</span><br><span class="line">        int t;</span><br><span class="line">        t &#x3D; a[0];</span><br><span class="line">        a[0] &#x3D; a[3];</span><br><span class="line">        a[3] &#x3D; t;</span><br><span class="line">        t &#x3D; a[1];</span><br><span class="line">        a[1] &#x3D; a[2];</span><br><span class="line">        a[2] &#x3D; t;</span><br><span class="line">        System.out.println(&quot;结果是：&quot; + a[0] + a[1] + a[2] + a[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo48 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        int num&#x3D;0,temp;</span><br><span class="line">        do&#123;</span><br><span class="line">            System.out.print(&quot;请输入一个4位正整数：&quot;);</span><br><span class="line">            num &#x3D; s.nextInt();</span><br><span class="line">        &#125;while (num&lt;1000||num&gt;9999);</span><br><span class="line">        int a[]&#x3D;new int[4];</span><br><span class="line">        a[0] &#x3D; num&#x2F;1000; &#x2F;&#x2F;取千位的数字</span><br><span class="line">        a[1] &#x3D; (num&#x2F;100)%10; &#x2F;&#x2F;取百位的数字</span><br><span class="line">        a[2] &#x3D; (num&#x2F;10)%10; &#x2F;&#x2F;取十位的数字</span><br><span class="line">        a[3] &#x3D; num%10; &#x2F;&#x2F;取个位的数字</span><br><span class="line">        for(int j&#x3D;0;j&lt;4;j++) &#123;</span><br><span class="line">            a[j]+&#x3D;5; a[j]%&#x3D;10;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;&#x3D;1;j++) &#123;</span><br><span class="line">            temp &#x3D; a[j]; a[j] &#x3D; a[3-j]; a[3-j] &#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;加密后的数字为：&quot;);</span><br><span class="line">        for(int j&#x3D;0;j&lt;4;j++) System.out.print(a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符串中子串出现的次数"><a href="#计算字符串中子串出现的次数" class="headerlink" title="计算字符串中子串出现的次数"></a>计算字符串中子串出现的次数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Demo49 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入主串：&quot;);</span><br><span class="line">        String str1 &#x3D; in.nextLine();</span><br><span class="line">        System.out.println(&quot;请输入子串：&quot;);</span><br><span class="line">        String str2 &#x3D; in.nextLine();</span><br><span class="line">        &#x2F;&#x2F; 生成子串长度的N个字符串数组</span><br><span class="line">        String[] sa &#x3D; new String[str1.length() - str2.length() + 1];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sa.length; i++) &#123;</span><br><span class="line">            sa[i] &#x3D; str1.substring(i, i + str2.length());</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 子串与N个拆开的子串比对</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sa.length; i++) &#123;</span><br><span class="line">            if (sa[i].equals(str2)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 成功配对，计数器+1；</span><br><span class="line">                sum++;</span><br><span class="line">                &#x2F;&#x2F; 因为不计算重叠的子串，所以跳过配对之后的部分拆分子串</span><br><span class="line">                i &#x3D; i + str2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;主串中共包含&quot; + sum + &quot;个字串&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文"><a href="#有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文" class="headerlink" title="有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文"></a>有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">class Student &#123;</span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line">    private String name &#x3D; &quot;&quot;;</span><br><span class="line">    private double[] a &#x3D; new double[3];</span><br><span class="line">    public double getAve() &#123;</span><br><span class="line">        return (a[0] + a[1] + a[2]) &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(int number, String name, double[] a) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.number &#x3D; number;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;学号：&quot; + this.number + &quot;\t姓名：&quot; + this.name + &quot;\r\n各科成绩：\r\n&quot; + a[0] + &quot;\\t&quot; + a[1] + &quot;\\t&quot; + a[2] + &quot;\r\n平均成绩：\r\n&quot;+ this.getAve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo50 &#123;</span><br><span class="line">    public static Student input() &#123;</span><br><span class="line">        Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入学号：&quot;);</span><br><span class="line">        int num &#x3D; s.nextInt();</span><br><span class="line">        System.out.println(&quot;请输入姓名：&quot;);</span><br><span class="line">        String name &#x3D; s.next();</span><br><span class="line">        System.out.println(&quot;请分别输入3门成绩：&quot;);</span><br><span class="line">        double[] a &#x3D; new double[3];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            a[i] &#x3D; s.nextDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        return new Student(num, name, a);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Student[] st &#x3D; new Student[2];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; st.length; i++) &#123;</span><br><span class="line">            st[i] &#x3D; input();</span><br><span class="line">        &#125;</span><br><span class="line">        File f &#x3D; new File(&quot;d:&quot; + File.separator + &quot;123.txt&quot;);</span><br><span class="line">        FileWriter output &#x3D; new FileWriter(f);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; st.length; i++) &#123;</span><br><span class="line">            output.write(st[i].toString() + &quot;\r\n&quot;);</span><br><span class="line">            output.write(&quot;\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon扩展点</title>
      <link href="2020/11/16/Ribbon%E6%89%A9%E5%B1%95%E7%82%B9/"/>
      <url>2020/11/16/Ribbon%E6%89%A9%E5%B1%95%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="7个核心接口"><a href="#7个核心接口" class="headerlink" title="7个核心接口"></a>7个核心接口</h2><table><thead><tr><th>接口</th><th>简述</th><th>默认实现</th></tr></thead><tbody><tr><td>IClientConfig</td><td>定义ribbon中管理配置的接口</td><td>DefaultClientConfigImpl</td></tr><tr><td>IRule</td><td>定义ribbon中负载均衡策略的接口</td><td>ZoneAvoidanceRule</td></tr><tr><td>IPing</td><td>定义定期ping服务，检查可用性的接口</td><td>DummyPing</td></tr><tr><td>ServerList<Server></Server></td><td>定义获取服务列表方法的接口</td><td>ConfigurationBasedServerList</td></tr><tr><td>ServerListFilter<Server></Server></td><td>定义特定场景下，获取服务列表的方法接口</td><td>ZonePreferenceServerListFilter</td></tr><tr><td>ILoadBalancer</td><td>定义负载均衡选择服务的核心方法接口</td><td>ZoneAwareLoadBalancer</td></tr><tr><td>ServerListUpdater</td><td>为DynamicServerListLoadBalancer定义动态更新服务列表的接口</td><td>PollingServerListUpdater</td></tr></tbody></table><p>Ribbon的加载策略是懒加载，即第一次请求的时候才加载对应上下文，正是这个原因，很多时候第一次调用显得很慢，甚至会超时，所以，可以通过指定ribbon具体服务名称来开启饿加载，即在工程启动的时候，加载所有的配置上下文。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: client-a, client-b, client-c</span><br></pre></td></tr></table></figure><p>ribbon在1.2.0版本以后，<font color="red"><strong>可以使用配置文件来定制ribbon客户端，这种优先级最高</strong></font>，高于使用@RibbonClient注解指定配置。</p><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td><clientName>.ribbon.NFLoadBalancerClassName</clientName></td><td>指定ILoadBalancer的实现类</td></tr><tr><td><clientName>.ribbon.NFLoadBalancerRuleClassName</clientName></td><td>指定IRule的实现类</td></tr><tr><td><clientName>.ribbon.NFLoadBalancerPingClassName</clientName></td><td>指定IPing的实现类</td></tr><tr><td><clinetName>.ribbon.NIWSServerListClassName</clinetName></td><td>指定ServerList的实现类</td></tr><tr><td><clientName>.ribbon.NIWSServerListFilterClassName</clientName></td><td>指定ServerListFilter的实现类</td></tr></tbody></table><p>可以使用ribbon的自带实现类，也可以使用我们自定义的接口实现类，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NIWSServerListClass:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span> <span class="comment">#指定ServerList的实现类</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#指定IRule的实现类</span></span><br></pre></td></tr></table></figure><p>默认情况下，ribbon客户端会从eureka注册中心获取服务注册列表，然后做负载均衡策略，但是如果想要ribbon客户端脱离eureka使用，可以为ribbon客户端指定服务的地址，如下操作：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">ribbon.eureka.enabled</span>=<span class="string">false #一定要关闭ribbon中的eureka功能</span></span><br><span class="line"><span class="meta">client.ribbon.listOfServers</span>=<span class="string">http://localhost:7070,http://localhost:7171 #指定服务地址</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon负载均衡</title>
      <link href="2020/11/16/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2020/11/16/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="ribbon负载均衡策略"><a href="#ribbon负载均衡策略" class="headerlink" title="ribbon负载均衡策略"></a>ribbon负载均衡策略</h2><p>ribbon有7种负载均衡策略可供选择：</p><table><thead><tr><th>策略类</th><th>命名</th><th>描述</th></tr></thead><tbody><tr><td>RandomRule</td><td>随机策略</td><td>随机选择server</td></tr><tr><td>RoundRobinRule</td><td>轮询策略</td><td>按照顺序选择server（ribbon默认策略）</td></tr><tr><td>RetryRule</td><td>重试策略</td><td>在一个配置时间段内，当选择server不成功，则一直尝试选择一个可用的server</td></tr><tr><td>BestAvailableRule</td><td>最低并发策略</td><td>逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server</td></tr><tr><td>AvailabilityFilteringRule</td><td>可用过滤策略</td><td>过滤掉一直失败并被标记为circuit tripped的server，过滤掉那些高并发链接的server（active connections超过配置的阈值）</td></tr><tr><td>ResponseTimeWeightedRule</td><td>响应时间加权重策略</td><td>根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间</td></tr><tr><td>ZoneAvoidanceRule</td><td>区域权重策略</td><td>综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server</td></tr></tbody></table><a id="more"></a><h2 id="配置策略"><a href="#配置策略" class="headerlink" title="配置策略"></a>配置策略</h2><ul><li><p>使用java注解配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(value = &#123;</span></span><br><span class="line"><span class="meta">    @RibbonClient(name = &quot;order-service&quot;, configuration = RoundRobinRule.class)</span></span><br><span class="line"><span class="meta">&#125;, defaultConfiguration = NativeRibbonRule.class)</span></span><br></pre></td></tr></table></figure></li><li><p>使用配置文件方式配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#针对client-a服务使用随机策略</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="重试及超时配置"><a href="#重试及超时配置" class="headerlink" title="重试及超时配置"></a>重试及超时配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client-a:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment">#对第一次请求的服务的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment">#要重试的下一个服务的最大数量（不包括第一个服务）</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#说明：这里配置的ConnectTimeout和ReadTimeout是当HTTP客户端使用的是HttpClient才生效，这个时间最终会被设置到HttpClient中。</span></span><br><span class="line"><span class="comment">#在设置的时候需要结合hystrix的超时时间来综合考虑，针对使用的场景，设置太小会导致很多请求失败，设置太大会导致熔断控制变差。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github上创建hexo博客</title>
      <link href="2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装node.js </p></li><li><p>安装hexo。npm install -g hexo-cli</p></li><li><p>hexo项目初始化。hexo init &lt;新建文件夹的名称&gt;</p></li><li><p>如果是从git上下载下来的hexo项目，安装依赖包。npm install –force</p></li><li><p>创建文章。 hexo new post fileName</p></li><li><p>发布文章。hexo d (修改配置文件，安装npm install hexo-deployer-git –save)</p></li><li><p>启动。hexo s</p></li><li><p>编译。hexo g</p></li></ol><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><strong>安装插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/luckyfeing/luckyfeing.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">&#x27;发布文章&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="图片使用"><a href="#图片使用" class="headerlink" title="图片使用"></a>图片使用</h2><ul><li>图床，如七牛云，阿里云，可以借助<a href="http://markdown.xiaoshujiang.com/">小书匠在线markdown工具</a>,可以配置图片上传图床如github。</li><li>相对路径图片，选择<strong>相对路径图片解决方案</strong>，借助Typora配置</li><li>base64图片，在线编码</li></ul><p><strong>安装插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p><strong>修改插件js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">config.post_asset_folder</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>修改_config.yml配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>Typora配置图片设置</strong></p><p>可以配置本地图片（相对路径），也可以配置图片上传，借助PicGo工具，配置图片上传</p><p><img src="/2020/11/13/github%E4%B8%8A%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/Typora%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E8%AE%BE%E7%BD%AE.jpg"></p><h2 id="创建tags"><a href="#创建tags" class="headerlink" title="创建tags"></a>创建tags</h2><p><strong>创建页面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p><strong>修改新文件内容</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tagcloud</span><br><span class="line">date: 2017-06-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>新增文章添加标签tags</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016-03-16 08:12:43</span><br><span class="line">tags:</span><br><span class="line">categories: 前端</span><br><span class="line">--- </span><br></pre></td></tr></table></figure><h2 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h2><p><strong>创建页面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p><strong>修改新文件内容</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>新增文章添加分类categories</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016-03-16 08:12:43</span><br><span class="line">tags:</span><br><span class="line">categories: 前端</span><br><span class="line">--- </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo简单命令</title>
      <link href="2020/11/13/hexo%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
      <url>2020/11/13/hexo%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
